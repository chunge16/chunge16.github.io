<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[页面回流与重绘（Reflow & Repaint)]]></title>
    <url>%2F2018%2F04%2F01%2F%E9%A1%B5%E9%9D%A2%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%EF%BC%88Reflow-Repaint%2F</url>
    <content type="text"><![CDATA[一、什么是Repaint/Reflow?我们首先来说明一下浏览器渲染的大致流程： 解析HTML文档，构建DOM树 解析CSS属性，构建CSSOM树 结合DOM树和CSSOM树，构建render树 在render树计算每个节点的几何结构 把每个节点绘制在屏幕上 一个页面可以简单看成由两个部分组成： DOM节点：描述页面的结构 DOM节点属性：描述页面如何呈现 Repaint（重绘）当 DOM 元素的属性发生变化 (如 color) 时, 浏览器会重新描绘相应的元素, 此过程称为 重绘（Repaint)。 Reflow （回流）当涉及到DOM节点布局属性发生变化时，就会重新计算该属性，浏览器会重新描绘相应的元素。此过程叫 回流（Reflow）。所以这里可以看出，回流必重绘。 二、引起Repaint和Reflow的一些操作浏览器在处理回流时，会递归处理DOM节点，所以导致回流的成本高于重绘。 如果你是Web开发者，可能更关注的是哪些具体原因会引起浏览器的回流，下面罗列一下： 调整窗口大小 字体大小 样式表变动 元素内容变化，尤其是输入控件 CSS伪类激活，在用户交互过程中发生 DOM操作，DOM元素增删、修改 width, clientWidth, scrollTop等布局宽高的计算 这些引起回流的操作中，6和7是和JavaScript相关的，所以前端开发人员应该注意2点： 避免大量的DOM操作 避免过多DOM布局属性的计算 注：display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发生位置变化。 三、如何避免过多的Repaint和Reflow？12345678var s = document.body.style; s.padding = &quot;2px&quot;; // 回流+重绘s.border = &quot;1px solid red&quot;; // 再一次 回流+重绘s.color = &quot;blue&quot;; // 再一次重绘s.backgroundColor = &quot;#ccc&quot;; // 再一次 重绘s.fontSize = &quot;14px&quot;; // 再一次 回流+重绘// 添加node，再一次 回流+重绘document.body.appendChild(document.createTextNode(&apos;abc!&apos;)); Repaint和Reflow是不可避免的，只能说对性能的影响减到最小，给出下面几条建议： 避免逐条更改样式。建议集中修改样式，例如操作className。 避免频繁操作DOM。 建议DOM离线时操作，例如创建一个documentFragment或div，在它上面应用所有DOM操作，最后添加到文档里 设置display:none的元素上操作，最后显示出来。 避免频繁读取元素几何属性（例如scrollTop）。 绝对定位具有复杂动画的元素。绝对定位使它脱离文档流，避免引起父元素及后续元素大量的回流 参考链接 减少页面回流与重绘（Reflow &amp; Repaint） [ JS 进阶 ] Repaint 、Reflow 的基本认识和优化 (2) 页面重构应注意的repaint和reflow]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域聊聊呗]]></title>
    <url>%2F2018%2F03%2F26%2F%E8%B7%A8%E5%9F%9F%E8%81%8A%E8%81%8A%E5%91%97%2F</url>
    <content type="text"><![CDATA[跨域 一、同源策略(Same origin Policy)本质是浏览器的一种安全机制，限制同一个源下的脚本或文档不能读写另外一个源的资源 同源策略本质就是浏览器针对读写不同源资源的一种限制。 那么何为同一个源呢？三同即为同源，如果有一个不满足，即为不同源 相同的协议，例如 http、https 相同的域名， 例如https://www.google.com/a和https://www.google.com/b 相同的端口，例如：80 1234567891011// 协议不同，不同源http://www.google.com/ahttps://www.google.com/a// 域名不同，不同源https://www.google.com/ahttps://www.baidu.com/a// 端口不同，不同源http://www.google.com/ahttps://www.google.com:81/a 二、跨域的几种方式那么如何避免同源策略的限制来访问不同源的资源呢？ 这个时候就需要跨域了 以下是通常跨域通信的几个方式 1、JSONP本质是利用script标签可以不受同源策略的限制来加载其他域的JS。 通过添加script元素，向服务器请求数据，服务器接受到请求后，把数据放在指定名字的回调函数里传回来，只要定义好了函数后，前端接收到数据就会立即执行该函数，这样就绕过跨域拿到数据。 优点：简单方便，老式浏览器都支持，兼容性好 缺点：只支持get请求 123456&lt;script&gt;function getData(ret)&#123;console.log(ret);&#125;&lt;/script&gt;&lt;script src=&quot;http://api.jirengu.com/weather.php?callback=getData&quot;&gt;&lt;/script&gt; 2、CORS跨站资源共享（Cross-Origin Resource Sharing） 在你使用XMLHttpRequest对象发送请求时，浏览器发现不符合同源策略时会在请求里加上请求头：Origin，服务器如果接受该请求会在响应头里加上：Access-Control-Allow-Origin，浏览器接受该响应会判断该响应头里是否包括Origin的值，如果包含浏览器会处理该响应，我们就能拿到数据，如果不包含浏览器直接驳回 本质还是服务器主导，服务器可以自主选择是否允许该域名请求到数据 3、降域iframe元素可以内嵌其他网页。iframe元素本身是独立的窗口，iframe窗口之中的脚本，可以获得父窗口和子窗口。但是不同源的父窗口和子窗口要进行通信，就必须跨域 两个网页里设置document.domain相同的值，就可以实现跨域了，因为浏览器会通过document.domain属性来检查是否同源 1234567891011121314151617// URL: http://a.jrg.com:8080/a.htmldocument.querySelector(&apos;.main input&apos;).addEventListener(&apos;input&apos;, function()&#123; console.log(this.value); window.frames[0].document.querySelector(&apos;input&apos;).value = this.value;&#125;)document.domain = &quot;jrg.com&quot;// URL: http://b.jrg.com:8080/b.html document.querySelector(&apos;#input&apos;).addEventListener(&apos;input&apos;, function()&#123; window.parent.document.querySelector(&apos;input&apos;).value = this.value;&#125;)document.domain = &apos;jrg.com&apos;; 4、postMessage为了跨域窗口通信的问题，HTML5引入了一个全新的API：跨文档通信 API（Cross-document messaging）。 就是为window对象新添加 window.postMessage方法， 允许跨域窗口通信，无论是否同源。 postMessage（message, origin） message事件的参数是事件对象event，提供以下三个属性 event.source：发送消息的窗口 event.origin: 消息发向的网址 event.data: 消息内容 通过这些属性可以进行一些处理，比如event.origin属性可以过滤不是发给本窗口的消息等等 123456789101112131415161718192021222324252627282930313233//URL: http://a.jrg.com:8080/a.html$(&apos;.main input&apos;).addEventListener(&apos;input&apos;, function()&#123; console.log(this.value); // 发送消息 window.frames[0].postMessage(this.value,&apos;*&apos;);&#125;)// 监听 message 消息window.addEventListener(&apos;message&apos;,function(e) &#123; $(&apos;.main input&apos;).value = e.data console.log(e.data);&#125;);// URL: http://b.jrg.com:8080/b.html $(&apos;#input&apos;).addEventListener(&apos;input&apos;, function()&#123; // 发送消息 window.parent.postMessage(this.value, &apos;*&apos;);&#125;)// 监听message消息window.addEventListener(&apos;message&apos;,function(e) &#123; $(&apos;#input&apos;).value = e.data console.log(e.data);&#125;);function $(id)&#123; return document.querySelector(id);&#125; 三、CORS 跨域发送 Cookie默认情况下浏览器跨域请求是不会携带Cookie的，但是鉴于Cookie在身份认证方面等具有重要作用，所以CORS允许设置响应头来允许跨域请求发送Cookie 客户端 在open XMLHttpRequest后，设置withCredentials为true即可让该跨域请求携带 Cookie。 注意携带的是目标页面所在域的 Cookie。 1234567var xhr = new XMLHttpRequest();xhr.open(&apos;GET&apos;, url);xhr.withCredentials = true;xhr.send(); 服务器 只设置客户端当然是没用的，还需要目标服务器接受你跨域发送的 Cookie。 否则会被浏览器的同源策略挡住。 设置Access-Control-Allow-Credentials响应头为”true”， 即可允许跨域请求携带 Cookie 设置Access-Control-Allow-Origin的值不允许设置为通配符（*）且只能指定是单一域名 12345678910111213const express = require(&apos;express&apos;);var app = express();app.get(&apos;/specific-allow-origin-with-credentials&apos;, (req, res) =&gt; &#123; res.set(&#123; &apos;Access-Control-Allow-Origin&apos;: &apos;http://index.com:4001&apos;, &apos;Access-Control-Allow-Credentials&apos;: true &#125;); res.status(200).end(&apos;I got your cookie: &apos; + req.headers.cookie);&#125;);app.listen(4001, () =&gt; console.log(&apos;listening to 4001&apos;)); 参考资料 同源政策 跨域 Ajax跨域时，如何带上目标地址需要的cookie？]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之正则表达式]]></title>
    <url>%2F2018%2F02%2F25%2FJS%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、正则表达式是什么？正则表达式是描述匹配字符串的规则。 本质是用一种描述性的语言给字符串定一种规则，如果符合该规则就说明匹配了 比如，你要找出符合Email地址规则的字符串： 创建匹配Email的正则表达式 用该正则表达式去判断用户输入的邮箱地址是否正确 二、创建一个正则表达式通常有二种方式：字面量和构造函数，字面量不使用引号，而构造函数可以使用引号也可以不使用引号。 字面量 123const regex = /ab+c/;const regex = /^[a-zA-Z]+[0-9]*\W?_$/gi; 构造函数 12345678910 let regex = new RegExp(&quot;ab+c&quot;);let regex = new RegExp(/^[a-zA-Z]+[0-9]*\W?_$/, &quot;gi&quot;);/* 用构造函数创建正则表达式使用引号时，需要常规的字符转义规则（在前面加反斜杠 \）*/let regex = new RegExp(&quot;^[a-zA-Z]+[0-9]*\\W?_$&quot;, &quot;gi&quot;); 三、正则表达式中特殊字符当你匹配简单字符串时，可以直接使用由简单字符构成的正则表达式。比如/abc/就可以匹配出字符串中的“abc”字符串，但是假如匹配一个或多个b等复杂多变规则时，那么就要使用特殊字符。比如/ab*c/匹配了”a”后面跟了零个或多个”b”，”abbbc”或是”ac”都是可以正确匹配的。 这些特殊字符之间相互组合就可以得出复杂的正则表达式，下面来介绍基本常用的特殊字符 字符类别（Character Classes）一般情况下正则表达式一个字符对应字符串一个字符。 字符类别可以简单理解为单个字符类型分类 \d匹配阿拉伯数字类型， \s匹配空字符类型， .匹配除了回车符和换行符之外的所有字符 \w匹配任意来自基本拉丁字母表中的字母数字字符，还包括下划线 1234567/\d/ 匹配 &quot;B2 is the suite number.&quot; 中的 &apos;2&apos;。 /\s\w*/ 匹配 &quot;foo bar&quot; 中的 &apos; bar&apos;。/.y/ 匹配 &quot;yes make my day&quot; 中的 &quot;my&quot; 和 &quot;ay&quot;，但是不匹配 &quot;yes&quot;。/\w/ 匹配 &quot;apple&quot; 中的 &apos;a&apos;，&quot;$5.28&quot; 中的 &apos;5&apos; 和 &quot;3D&quot; 中的 &apos;3&apos;。 当然字符类别不止上面这几个，如果有兴趣查阅请点击这里 字符集合（Character Sets）当然我们也可以自定义自己的字符类别，比如[abcd]代表一个字符，只会匹配集合里abcd任意一个字符，比如匹配”brisket”中的’b’和”chop”中的’c’。当然我们也可以取反[^abcd]，匹配不包括abcd的任意一个字符，比如匹配 “bacon” 中的’o’ 和 “chop” 中的 ‘h’。 [xyz] 匹配集合里任意一个字符 [^xyz] 匹配任意不在集合里的字符 像[abcd]一个字符集合，又叫字符组。匹配集合中任意一个字符，可以使用‘-’指定一个范围，等价于[a-d]。 其实大家会发现/d等价于[0-9],/w等价于[A-Za-z0-9_]，这里就不一一说明了。 边界（Boundaries）正则表达式还提供几个边界限制字符 ^，匹配输入开始，例如/^A/匹配”Abc”的”A”，但不匹配”an A”的”A” $，匹配输入结尾，例如/t$/匹配”eat”的”t”，但不匹配”enter”的”t” \b，匹配单词边界，例如/\babc\b/匹配”abc”的”abc”，不匹配”aabcc”的”abc” \B，匹配非单词边界，例如/\Babc\B/匹配”aabcc”的”abc”，不匹配”abc”的”abc” 注意：-也用于区分单词边界 123const re = /\babc\b/// truere.test(&apos;-abc-&apos;) 数量词（Quantifiers）如果要匹配11位数字，可以写11个/d，这未免太麻烦了。所以这里需要用到数量词/d{11} ?，匹配0次或1次（最多匹配一次） 例如，/ok?/匹配”okkk”的”ok”，”o”的”o” +，匹配1次或多次(至少出现一次) 例如，/a+/匹配”cat”的”a”，”caaaat”的”aaaa” *，匹配0次或多次（任意次） 例如，/bo*/ 匹配 “A ghost booooed” 中的 “boooo”，”A bird warbled” 中的 “b” {n}，匹配n次 例如，a{3}匹配”caaaat”的”aaa”，不匹配”cat”的”a” {n,m}，匹配n到m次 例如，a{1，3}匹配”caaaat”的”aaa”，匹配”cat”的”a” {n,}，至少出现n次 例如，a{3,}匹配”caaaat”的”aaaa”，匹配”caaat”的”aaa”，不匹配”cat”的”a” 贪婪模式与非贪婪模式这里需要注意 贪婪模式 和 非贪婪模式 ，数量词匹配时默认贪婪模式。贪婪模式即为匹配次数最大化，非贪婪模式反之亦然。 如果在数量词 *、+、? 或 {}, 任意一个后面紧跟该符号（?），会使数量词变为非贪婪（ non-greedy） ，即匹配次数最小化。反之，默认情况下，是贪婪的（greedy），即匹配次数最大化。 123456789re = /ok&#123;2,6&#125;//ok&#123;2,6&#125;/re.exec(&apos;okkkkkkkk&apos;)[&quot;okkkkkk&quot;, index: 0, input: &quot;okkkkkkkk&quot;]re2 = /ok&#123;2,6&#125;?//ok&#123;2,6&#125;?/re2.exec(&apos;okkkkkk&apos;)[&quot;okk&quot;, index: 0, input: &quot;okkkkkk&quot;] 分组（grouping）与反向引用（back references）之前都是匹配单个字符而已，假如要匹配&#39;can&#39;20次，该怎么办呢？ 那这里需要用到分组(can){20}即可，利用()把”can”看成整体，我们称为分组 反向引用可以简单理解为指向表达式中第N个括号匹配的子字符串，例如，/apple(,)\sorange\1/ 匹配 “apple, orange, cherry, peach.” 中的 “apple,orange,” (x) 匹配 x 并且捕获匹配项 \n 反向引用，n是正整数，指向表达式中第N个括号匹配的子字符串 (?:x) 匹配 x 但不会捕获匹配项 x(?=y) 当x后面紧跟y时，才匹配x x(?!y) 当x后面紧跟不是y时，才匹配x 123456789101112131415161718192021222324// 匹配 x 并且捕获匹配项var re = /(ok),(shi)/re.exec(&apos;ok,shi1&apos;)[&quot;ok,shi&quot;, &quot;ok&quot;, &quot;shi&quot;, index: 0, input: &quot;ok,shi1&quot;]// 反向引用var re = /(ok),(shi)\1/re.exec(&apos;ok,shiok&apos;)[&quot;ok,shiok&quot;, &quot;ok&quot;, &quot;shi&quot;, index: 0, input: &quot;ok,shiok&quot;]// 匹配 x 但不捕获匹配项var re = /(?:ok),(shi)/re.exec(&apos;ok,shi1&apos;)[&quot;ok,shi&quot;, &quot;shi&quot;, index: 0, input: &quot;ok,shi1&quot;]// x(?=y) 当x后面紧跟y时，才匹配xvar re = /ok(?=,shi)/re.exec(&apos;ok,shi&apos;)[&quot;ok&quot;, index: 0, input: &quot;ok,shi&quot;]// x(?!y) 当x后面紧跟不是y时，才匹配xvar re2 = /ok,(?!shi)/re2.exec(&apos;ok,jack&apos;)[&quot;ok,&quot;, index: 0, input: &quot;ok,jack&quot;] 四、正则表达式——相关方法4.1 RegExp对象实例 global：是否全局搜索，默认是false。如果为true就匹配目标字符串中所有的可能的匹配项，而不是只匹配第一个匹配项 ignoreCase：是否大小写敏感，默认是false。 multiline：多行搜索，默认值是false。如果为true就匹配多行里每一行的开始和结尾，而不仅仅是目标字符串的开始和结尾。 lastIndex：下次匹配开始字符串的索引位置。该属性只有在global为true时才生效 source：正则表达式的文本字符串 12345678910111213var myRe = new RegExp(&quot;d(b+)d&quot;, &quot;g&quot;);var myArray = myRe.exec(&quot;cdbbdbsbz&quot;);myRe.globaltruemyRe.ignoreCasefalsemyRe.multilinefalsemyRe.lastIndex5myRe.source&quot;d(b+)d&quot; 4.1 实例方法test()正则表达式与目标字符串是否匹配，返回true或false。 123456var re = /ok/re.test(&apos;ok&apos;)truere.test(&apos;no&apos;)false exec()对目标字符串进行正则匹配，返回结果数组或null。并且更新正则实例的lastIndex属性值 特性 正则表达式设置了g标识，那么会全局匹配并且返回所有匹配值 正则表达式没有设置g标识，那么始终返回第一个匹配值 12345var re = /quick\s(brown).+?(jumps)/ig;var result = re.exec(&apos;The Quick Brown Fox Jumps Over The Lazy Dog&apos;);result[&quot;Quick Brown Fox Jumps&quot;, &quot;Brown&quot;, &quot;Jumps&quot;, index: 4, input: &quot;The Quick Brown Fox Jumps Over The Lazy Dog&quot;] 对象 属性或索引 描述 例子 re [0] 匹配的目标字符串 “Quick Brown Fox Jumps [1] ~ [n] 括号里的分组捕获 “Brown”, “Jumps” index 匹配的字符串基于目标字符串的索引值 4 input 目标字符串的原始值 “The Quick Brown Fox Jumps Over The Lazy Dog” 4.2 字符串方法match str.match(regexp); regexp包含g 标志时 找到结果，返回所有匹配结果，但是分组捕获、index和input不会返回 没找到结果，返回null regexp不包含g 标志时 找到结果，返回和re.exec()一样的结果 没找到结果，返回null 123456789var re = /\w(\d+)/givar re2 = /\w(\d+)/var str = &apos;aaa23bbbbb222&apos;str.match(re)[&quot;a23&quot;, &quot;b222&quot;]str.match(re2)[&quot;a23&quot;, &quot;23&quot;, index: 2, input: &quot;aaa23bbbbb222&quot;] replace str.replace(regexp|substr, newSubStr|function) 替换成功匹配的字符串并且返回替换后的新字符串 第一个参数 regexp 该正则匹配的字符串会被第二个参数的返回值所替换 substr 被newSubStr所替换的字符串，而已只有第一个匹配能被替换 第二个参数 newSubStr 该字符串用于替换第一参数所匹配的部分 替换字符串可以插入特殊变量名，有兴趣可以点击这里 12345 str = &apos;ok , jack&apos; &quot;ok , jack&quot; str.replace(/(\w+) , (\w+)/g, &apos;$2, $1&apos;)&quot;jack, ok&quot; function 该函数的返回值替换第一参数所匹配的部分 参数 match，成功匹配的字符串 p(n)，捕获的分组（第n个括号匹配的字符串） offset，匹配的字符串在原字符串的位置 string，原字符串 123456 function replacer(match, p1, p2, p3, offset, string) &#123; // p1 is nondigits, p2 digits, and p3 non-alphanumerics return [p1, p2, p3].join(&apos; - &apos;);&#125;var newString = &apos;abc12345#$*%&apos;.replace(/([^\d]*)(\d*)([^\w]*)/, replacer);console.log(newString); // abc - 12345 - #$*% search str.search(regexp) 返回首次匹配在字符串的位置，没有则返回-1 需要注意一点，search会忽略g标志和lastindex属性， 123456789var str = &apos;a1b2c3&apos;&quot;a1b2c3&quot;str.search(/\s/)-1str.search(/\d/)1str.search(/\d/g)1 split str.split([separator[, limit]]) 指定分隔符为界限，将字符串分割成字符串数组。 separator 可以是一个字符串或正则表达式，limit限定返回分割数量 当字符串为空时，split（）返回一个包含一个空字符串的数组，而不是一个空数组. 当字符串不为空时，split（）返回包含一个由整个字符串组成的元素的数组. 如果字符串和分隔符都是空字符串，则返回一个空数组。 空字符串作为分隔符，那么每个字符都会被分割 123456789101112131415str = &apos;&apos;str.split()[&quot;&quot;]str.split(&apos;&apos;)[]str = &apos;hello&apos;str.split()[&quot;hello&quot;]str.split(&apos;&apos;)[&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;] 参考链接 正则表达式 RegExp 正则表达式课件]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解密白屏和 FOUC]]></title>
    <url>%2F2018%2F01%2F30%2F%E8%A7%A3%E5%AF%86%E7%99%BD%E5%B1%8F%E5%92%8C-FOUC%2F</url>
    <content type="text"><![CDATA[前言浏览器加载页面时，由于各种原因可能会导致加载过慢，那么此时不同浏览器对此的渲染机制是不一样的。 一、为什么有白屏和 FOUC呢？浏览器在渲染的时候没有请求到或请求时间过长造成的，那么浏览器会如何应对呢？ 一般分浏览器会采取二种方式针对这样的情况 白屏 FOUC (Flash of Unstyled Content)无样式内容闪烁 二、白屏和 FOUC是什么？白屏和 FOUC是不同浏览器的渲染机制，并不是bug。 这里要说明一下，浏览器的渲染机制 解析 HTML 标签, 构建 DOM 树 解析 CSS 标签, 构建 CSSOM 树 把 DOM 和 CSSOM 组合成 渲染树 (render tree) 在渲染树的基础上进行布局, 计算每个节点的几何结构 把每个节点绘制到屏幕上 (painting) 白屏 CSS全部载入解析完后渲染展示页面。如果没有加载完，就会出现白屏 FOUC (Flash of Unstyled Content)无样式内容闪烁 CSS未完全加载前，会先渲染显示已经解析的HTML内容，然后CSS完全加载完成后，再次渲染。 （逐步载入无样式的内容,等CSS载入后页面才突然展现出样式） 三、CSS 和 JS 放置顺序 使用 link 标签将样式表放在顶部，防止白屏问题意外出现 将JS放在底部，原因如下 脚本会阻塞后面内容的呈现 脚本会阻塞其后组件的下载 参考链接 前端魔法堂：解秘 FOUC 白屏問題和FOUC]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[z-index， 来咋们聊聊]]></title>
    <url>%2F2018%2F01%2F19%2Fz-index-%E6%9D%A5%E5%92%8B%E4%BB%AC%E8%81%8A%E8%81%8A%2F</url>
    <content type="text"><![CDATA[一、什么是层叠上下文?HTML在布局的时候，其实不完全是二维空间，还有一条Z轴，其实和BFC类似，可以理解为Z轴的布局空间。 二、什么是层叠水平？同一个层叠上下文中元素在z轴上的显示顺序，好比封建社会把人分为三六九等类似，所以所有的元素都有层叠水平。 三、什么是层叠顺序？再来说说层叠顺序。“层叠顺序”英文称作”stacking order”. 表示元素发生层叠时候有着特定的垂直显示顺序，注意，这里跟上面两个不一样，上面的层叠上下文和层叠水平是概念，而这里的层叠顺序是规则。 你可以理解为层叠上下文和层叠水平是宪法，而层叠顺序是对宪法的具体解释。 四、z-indexz-index最主要的作用就是 改变同一层叠上下文里元素层叠顺序 生成新的层叠上下文 1. z-index 在什么情况下才生效？ 对已定位的元素（即position属性值是非static的元素） z-index值不为auto的flex子项 2. z-index值越大元素越靠前，对吗？不对，同一层叠上下文值越大越靠前，如果不是，那么就不一定了。 3. z-index 不设置和设置为0有什么区别?如果z-index不设置默认值为auto,那将不会创建层叠上下文，但是如果设置为0，那将会创建创建层叠上下文。 4. z-index 可以为负值吗?可以 5. z-index 在设置元素覆盖时到底有什么规律? 同一层叠上下文里，谁大谁厉害 当元素的层叠水平一致、层叠顺序相同的时候，后面会覆盖前面的 深入理解CSS中的层叠上下文和层叠顺序 How z-index works!]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊字体如何变小]]></title>
    <url>%2F2018%2F01%2F09%2F%E8%81%8A%E8%81%8A%E5%AD%97%E4%BD%93%E5%A6%82%E4%BD%95%E5%8F%98%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[有时候在中文Chrome设置font-size小于12px的时候，依然显示为12px.（注意只是中文Chrome，英文Chrome是没有限制的） 那我们怎么才能成功设置小于12px的字体大小呢？？ 解决方法我先开门见山的介绍解决方法吧 transform scale 缩小（推荐） 12345 font-size: 9px;-webkit-transform: scale(0.75);-webkit-transform-origin-x: 0; scale其实本质就是利用缩放的效果，来达到字体变小的效果。 元素变形基点默认是中心点，所以需要通过设置-webkit-transform-origin-x让变形基点基于left，这样元素布局才不会乱。 字体变小在其他浏览器都是OK的，但是-webkit-transform特性在Safari和Firefox下是生效的（亲测有效），所以此CSS必须在Chrome下才能给元素使用，那么如何判断当前浏览器是Chrome呢？？ 你可以在JavaScript里使用!!wiondw.chrome 返回的布尔值进行判断 手动设置Chrome最小字体 （不推荐，不要给用户添堵） 中文Chrome默认最小字体是12px，如果用户自己手动改变浏览器最小字体，这样设置小于12px，浏览器就可以显示出来了。 目前Chrome-63最小可以设置为6px -webkit-text-size-adjust:none（已废弃） 我看见很多网上资料还在说这个方法，可是人家Chrome 27以后正式取消该特性了，很误导人啊！！！ 参考链接 Chrome取消-webkit-text-size-adjust后的那些事 compatible-with-less-than-12px-fontsize]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说说CSRF]]></title>
    <url>%2F2018%2F01%2F05%2F%E8%AF%B4%E8%AF%B4CSRF%2F</url>
    <content type="text"><![CDATA[CSRF是什么？跨站请求伪造（英语：Cross-site request forgery），维基百科的解释是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法，听起来很厉害的样子。 简单来说，攻击者利用一些技术手段去欺骗用户浏览器去访问一些曾经认证过的网站而执行一些操作。由于认证过，所以浏览器认为是用户的本意。 其实咋们可以简单理解为虎符调兵，正常是大将军颁发虎符才能调兵，但是军队只认虎符不认人，假如奸臣偷取虎符假传命令私自调兵造反，那可就大事不好！ CSRF原理那我们具体看看攻击细节 看图说话 大致过程 用户访问浏览正常网站 正常网站服务器响应并且返回标识该用户身份的cookie 用户未注销正常网站的情况下，访问恶意网站 恶意网站里访问正常网站并且带着标识用户的cookie 正常网站服务器接受来自恶意网站的请求 再次访问正常网站时，浏览器会自动带上标识该用户身份的cookie发送请求，所以正常网站服务器会接受来自恶意网站的请求，从而完成攻击。 当我访问登录一个正常网站，成功访问后服务器会产生一个标识用户身份的cookie给用户的浏览器保存，在标识cookie还存在时访问恶意网站，在该网站里攻击者会让你不知不觉的访问之前的正常网站并且执行一些操作，由于标识用户身份的cookie还存在，所以用户浏览器认为是用户的本意操作而执行该请求，从而攻击成功。 这些欺骗的访问方式有很多，例如“点击小广告、找回密码”等等诱导用户去点击操作。 如何预防CSRF我去，感觉都不敢上网冲浪了。。。 其实现在浏览器和服务端都做了很多安全防范措施，大家还是可以安全上网的。 目前预防方式有二种： 检查Referer字段 HTTP请求head里有个Referer字段，用于表明请求的来源地址。正常情况下，Referer字段和请求的地址是位于同一域名下的，如果是CSRF攻击发起的请求，那么Referer字段和请求的地址就不是同一域名了，那么服务器就能识别出恶意访问。 这个方法缺点是攻击者有可能篡改该Referer字段内容，从而欺骗服务器。 添加校验token 当用户正常访问网站时，服务器会生产一个随机数，并且把该随机数埋入该页面里（一般放在form表单，&lt;input type=&quot;hidden&quot; name=&quot;_csrf_token&quot; value=&quot;xxxx&quot;&gt;）。正常访问，客户的浏览器是能够得到并且返回该字段，而CSRF一开始是不知道该字段的数值，服务器接受请求发现该字段的异常，从而拒绝该请求。 参考资料 跨站请求伪造 CSRF 是什么？]]></content>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滚石爱情故事之爱的代价]]></title>
    <url>%2F2017%2F12%2F31%2F%E6%BB%9A%E7%9F%B3%E7%88%B1%E6%83%85%E6%95%85%E4%BA%8B%E4%B9%8B%E7%88%B1%E7%9A%84%E4%BB%A3%E4%BB%B7%2F</url>
    <content type="text"><![CDATA[滚石爱情故事之爱的代价 01大家好，今天给大家介绍滚石爱情故事之爱的代价。 再美好浪漫的爱情，有时也抵不过时间的消磨而变得平淡如水。 正如女主所说，爱情浪漫的味道慢慢变成了柴米油盐酱醋茶。 02芾思和男友小况交往了10年，毕业后一起在海边投资了一家MOTEL，原本以为这家旅馆是他们之间浪漫爱情的延续，可是7年以来，经营不利、种种挫折和无数的生活琐事让他们身心疲惫，他们的生活和爱情似乎都遇到了瓶颈。 不只這裡投資錯誤，我們之間也是一個錯誤的投資。 又一次事故后，芾思留下眼泪对男友小况说出这句话。 当初选择经营浪漫旅游以为会一直幸福下去，可是7年来她受够了，过得一点都不开心。 男友小况听到这句话，同样爆发积怨已久的情绪，就这样二人决定卖掉这家旅馆，还各自的自由。 03 七年的海盐，才能逼出多少原味。 其实爱情不应该只有浪漫的味道，其实柴米油盐也是爱情的味道。 经历岁月的打磨，留下来的才最珍贵 当买家只肯出不到一半价格的时候，小况觉得这是他和芾思7年的心血，不应该受此奚落。 小况心里还是舍不得他们的心血，而芾思也明白了她们的爱情并没有走到终点。 04 I&gt;B，爱大于弊。让我们两个呀，斩一切厄运。 故事的最后，他们走过自己爱情的七年之痒，最终步入婚姻的殿堂。 爱情的力量最终战胜重重困难，为爱付出的代价永远值得。 看世事无常 看沧桑变化 那些为爱所付出的代价 是永远都难忘的啊]]></content>
      <tags>
        <tag>爱情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高大上的Git]]></title>
    <url>%2F2017%2F12%2F31%2F%E9%AB%98%E5%A4%A7%E4%B8%8A%E7%9A%84Git%2F</url>
    <content type="text"><![CDATA[最近学习Git感觉真是是高大上，用简易的方式解决了复杂的版本管理问题。如果要深入介绍Git，其实够一本书了，所以我根据最近学习情况，总结一下Git的基本知识点吧。 一、Git是什么？Git是目前非常流行的分布式版本管理系统。 开发Git最初目的是为更好地管理Linux内核开发而设计。 什么是版本管理？ 简单说就是记录你的修改。比如你修改一个文档，今天你修改了最后一段文字，过了一周又修改了最后一段文字，但是你后悔了，想恢复到一周前的版本，但是完全记不得之前的内容，怎么办呢？那这个时候就需要版本管理了，版本管理可以记录你的每次修改，这样你就可以回到过去。 为什么使用Git？ 有的人会说，世界这么多版本管理系统，Git有什么好吗？主要有四点： 速度快，操作简单 分布式管理 极其优秀的分支管理 开源项目 二、 Git的安装 Mac下的安装 Mac下安装我推荐使用homebrew，具体方法请参考homebrew的文档 Windows下的安装 在Windows下安装Git，其实和安装其他软件没什么区别，去Git官网下载安装软件即可 三、Git初次体验安装完后，进入一个新建的文件夹里，我们来体验一下Git的使用 初始化仓库 12// 在当前目录新建一个Git代码库git init 添加文件 12345// 新建一个 a.txt 文件touch a.txt// 添加指定文件到暂存区git add a.txt 提交文件 12// 提交暂存区到本地仓库区git commit -m &apos;添加文件 a.txt&apos; 这样你就记录下添加a.txt文件的修改 四、Git的基本使用 4.1 Git的基本概念 工作区 （Working Directory） 工作区就是你本机操作文件的地方 暂存区 (Stage) 当你初始化仓库时，你会发现工作区里多了个.git的文件夹，这就是本地仓库。这里有个很重要的区域就是暂存区，当你执行git add的时候，其实就是把文件修改添加到暂存区。 本地仓库 (History) .git文件夹就是本地仓库，里面还有一个重要区域就是默认的master分支，当你执行git commit的时候，其实就是把暂存区的所有内容添加到当前分支上。 4.2 添加文件并提交 git add 添加修改文件到暂存区 git status 查看工作区的变化 git commit 把暂存区所有内容提交到当前分支上 git pull 取回远程仓库的变化 git push origin master 上传本地master分支到远程仓库 4.3 版本回退现代的人总想回到过去，可是时间是回不去的，但是Git可以实现你的愿望。 首先你要知道你想回到哪个版本，通过git log查看当前分支提交记录，HEAD指向当前分支master，而master指向提交，也就是下面的commit_id （aa81633220d368b5f1…） 12345678910111213git logcommit aa81633220d368b5f1bc0677e676e2a118ab188e (HEAD -&gt; master)Author: JACK &lt;shizhengchun2015@gmail.com&gt;Date: Sun Dec 31 11:28:44 2017 +0800 添加 b.txtcommit 91ff12ff6685a7316cecf83c85bbcc96a8d63e39Author: JACK &lt;shizhengchun2015@gmail.com&gt;Date: Sun Dec 31 11:24:25 2017 +0800 添加 a.txt 其次就是让我们回到过去，通过git reset --hard commit_id 123456789101112131415git reset --hard 91ff12ff668HEAD is now at 91ff12f 添加 a.txt// 查看当前文件夹，发现已经回到添加a.txt的状态了lsa.txt// 再次查看当前提交历史git logcommit 91ff12ff6685a7316cecf83c85bbcc96a8d63e39 (HEAD -&gt; master)Author: JACK &lt;shizhengchun2015@gmail.com&gt;Date: Sun Dec 31 11:24:25 2017 +0800 添加 a.txt 这个时候有人发现，那我还能回到添加 b.txt 文件的状态吗？恩，Git无所不能想要回到未来，通过查看命令历史git reflog，我们就找到添加 b.txt 的commit_id，这样我就可以回到未来了 12345678910111213git reflog91ff12f (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 91ff12ff668aa81633 HEAD@&#123;1&#125;: commit: 添加 b.txt91ff12f (HEAD -&gt; master) HEAD@&#123;2&#125;: commit (initial): 添加 a.txtgit reset --hard aa81633HEAD is now at aa81633 添加 b.txt// 此时文件夹有了b.txt 我们成功回到未来lsa.txt b.txt 总结一下： HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。 用git log可以查看提交历史，以便确定要回退到哪个版本。 用git reflog查看命令历史，以便确定要回到未来的哪个版本。 五、Git的高级使用5.1 本地新建Git项目并推送远程空仓库 本地初始化Git项目库 git init 远程新建空仓库，（注意空仓库就是什么都没有） 到GitHub新建仓库就行，新建成功就是这个样子 关联本地仓库和远程空仓库 123// origin后面是你自己仓库的地址，别搞错了git remote add origin git@server-name:path/repo-name.git 推送本地仓库到远程 关联后，使用命令git push -u origin master第一次推送master分支的所有内容 5.2 分支管理Git还有一个优势就是分支设计非常优秀，之前说过HEAD是指向分支的，当你初始化仓库时会默认产生master分支，所以默认HEAD是指向maser分支的。 其实切换分支的本质就是改变HEAD的指向，工作区什么都没有变。 新建一个分支dev，其实就是新建一个指针dev，并且指向和master相同的提交，同时让HEAD指向dev 123456789// 新建分支devgit branch dev// 切换到分支devgit checkout dev----------------// 其实可以一步到位，加参数-b就可以git checkout -b dev 那现在工作区改变文件，提交文件就是在dev上面了，假如新提交一个commit，那么dev指针向前一步，但maser不变 OK，那我们现在来合并分支，其实原理就是把master指向dev当前的提交 12345678910// 首先切换到master分支git checkout master// 查看分支，带`*`的符合就是当前分支git branch// 把dev分支合并到master分支上git merge dev dev的分支使命已经完成了，那我们那删除dev分支，其实删除分支就是删除dev指针而已。 1git branch -d dev Git上面操作分支就是这样简单有效 总结一下： 查看分支：git branch 创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d 其实Git还有很多命令，这些其实只是很小的一部分，但是我觉得掌握Git的基本概念后，其实遇到问题，其实可以搜索Git来学习。 才疏学浅，欢迎指导批评 参考链接 常用 Git 命令清单 廖雪峰的Git教程 图解Git]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说说Git reset 与 revert 的故事]]></title>
    <url>%2F2017%2F12%2F27%2F%E8%AF%B4%E8%AF%B4Git-reset-%E4%B8%8E-revert%E7%9A%84%E6%95%85%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[俗话说一入Git深似海，单独说Git一本书恐怕都不够，今天只是浅尝止渴而已。 简单说说reset和revert2个主要命令。 要学习Git，首先要明白Git几个基本概念 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） 搞懂了这三个区域，才能更好理解这些Git命令是在干什么。 一、resetreset命令的作用？reset命令把当前分支指向另外一个位置（提交的ID版本号），并且有选择性的变动暂存区和工作区的内容。 原理是基于本地仓库的文件去覆盖暂存区或工作区的内容 reset主要参数的区别当没有指定ID的时候，默认使用HEAD，如果指定ID，那么就是基于指向ID去变动暂存区或工作区的内容 12345// 没有指定ID, 暂存区的内容会被当前ID版本号的内容覆盖，工作区不变git reset// 指定ID，暂存区的内容会被指定ID版本号的内容覆盖，工作区不变git reset &lt;ID&gt; –mixed（默认） 默认的时候，只有暂存区变化 –hard参数 如果使用--hard参数，那么工作区也会变化 –soft 如果使用--soft参数，那么暂存区和工作区都不会变化 二、revertrevert命令撤销指定的commit并且新建一个commit，新建comment的内容由指定commit前一个提交内容保持一致 1git revert &lt;commit&gt; 参考链接 图解Git 猴子都能懂的Git入门 以上图片来源于图解Git]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北京的秋]]></title>
    <url>%2F2017%2F11%2F11%2F%E5%8C%97%E4%BA%AC%E7%9A%84%E7%A7%8B%2F</url>
    <content type="text"><![CDATA[前言孤独的秋，温暖的光 秋天一定要住北平。天堂是什么样子，我不知道，但是从我的生活经验去判断，北平之秋便是天堂。论天气，不冷不热。论吃的，苹果、梨、柿子、枣儿、葡萄，每样都有若干种。论花草，菊花种类之多，花式之奇，可以甲天下。西山有红叶可见，北海可以划船——虽然荷花已残，荷叶可还有一片清香。衣食住行，在北平的秋天，是没有一项不使人满意的。 ——老舍《住的梦》 不少中国文人骚客书写过关于北京秋天各样的美丽的描述，但北京的秋天给我的第一感觉是孤独的、落寞的，当然不完全是看似不好的一面，秋天的阳光还是很温暖的。传统文学里对秋的描述是“悲”字，这个其实应该是每个人对其的第一感觉，因为四季里春天给人感觉是生机的，夏天是繁盛的，而秋天是悲凉的，冬天是冰冷的。一个完美的大自然循环，其实你再看看人的生命走势，太阳的起起落落大概如此。 有点说远了，来北京快一年多，一直想好好感受一下这古都的四季，最令我向往的是秋天和冬天。我喜欢秋天的萧瑟和冬天的安静，因为这两个季节总能触动你心里那一丝丝心弦。特别是每当你看见那落叶从树上落下，飘落在空中时，我总会停下脚步默默欣赏这缓慢的一瞬间。 北京的秋天似乎只有两种颜色可以代表，一种是红色，一种是黄色，红色的代表当然是枫叶，而北京最为有名是香山的枫叶，漫山遍野的枫叶红美不胜收；而黄色的代表则是古老的银杏了。不过香山枫叶的名气太大，所以观赏枫叶的季节人总是很多，所以不推荐大家去看，如果实在想看枫叶，可以推荐去隔壁的西山八大处。而银杏相对就没那么辛苦去观赏了，北京几处观赏银杏的地方基本都在老北京城内，推荐西城钓鱼台的银杏大道、地坛公园的银杏大道、三里屯东五街，这几个地方你可以慢慢观赏。 图片均取景地坛公园]]></content>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017IFE-听指令的小方块（一）]]></title>
    <url>%2F2017%2F10%2F15%2F2017IFE-%E5%90%AC%E6%8C%87%E4%BB%A4%E7%9A%84%E5%B0%8F%E6%96%B9%E5%9D%97%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言2017-百度前端技术学院编码任务：听指令的小方块（一） 任务目的 练习JavaScript在DOM、字符串处理相关知识 练习对于复杂UI，如何进行数据机构建模 任务描述 实现与 （点击查看） 实现一个类似棋盘的格子空间 DEMO 项目地址 实现思路 设置小方块绝对定位，然后通过JS去控制它前进和转向。 但是这里主要有2个问题 复杂UI数据构造 UI构造我是根据自己的DOM棋盘结构来封装构造函数。 小方块的动作设置。格子的动作分为前进和旋转2个动作，前进判断旋转角度后设置left或top的数值来实现前进，旋转通过改变方块CSS3 transform rotate的属性进行旋转角度。 问题如何读写元素最终的CSS属性值呢？ style-可读可写使用style属性，仅仅只能获取和设置行内的样式，如果是通过内联&lt;style&gt;或链接&lt;link&gt;提供的样式规则就无可奈何了 123var box = document.querySelector('.box')box.style.transform // "" 为空字符串，无法获取非style的CSS属性值 getComputedStyle-可读不可写 使用getComputedStyle可以读取元素最终的CSS属性值，但是无法设置。 12345let elem = document.getElementById("elem-container");let theCSSprop = window.getComputedStyle(elem,null).getPropertyValue("height");// window.getComputedStyle(elem,null).height;// getPropertyValue方法可以获取CSS样式申明对象上的属性值（直接属性名称） CSSStyleSheet-对象可读可写 CSSStyleSheet类型表示通过&lt;link&gt;元素和&lt;style&gt;元素（注意这两种形式的都包括）包含的样式表，找到该元素CSSStyleRule对象，通过对style属性进行读写。 123456789document.styleSheets; //StyleSheetList，集合var sheet = document.styleSheets[0];// 查看元素leftsheet.rules[9].style.getPropertyValue('left') // "80px"// 设置元素leftsheet.rules[9].style.left = '120px' 参考链接 获取元素CSS值之getComputedStyle方法 获得div元素的translateY值 getComputedStyle DOM系列—DOM操作样式]]></content>
      <categories>
        <category>IFE</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>IFE</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《硅谷钢铁侠》的读书笔记]]></title>
    <url>%2F2017%2F10%2F14%2F%E3%80%8A%E7%A1%85%E8%B0%B7%E9%92%A2%E9%93%81%E4%BE%A0%E3%80%8B%E7%9A%84%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 最近读了《硅谷钢铁侠》一书，这本书让我对全球科技界的传奇人物“埃隆·马斯克”有了深刻的了解，在他做出一系列令人叹为观止的事情后，让人不禁思考究竟是什么成就了现在的硅谷钢铁侠。 1. 家庭的环境 小时候的成长环境确实很重要，这个道理其实达尔文的进化论早就告诉大家了。这里主要有2点，第一是母亲家族极富冒险主义的基因，从小耳濡目染母亲家族的冒险故事；第二是和他父亲的关系，文中埃隆·马斯克对父亲闭口不提。这样的环境下造就他天使和魔鬼的化身，一部分人认为他果断，睿智，勇敢；另外一部分人认为他冷酷，无情、残忍。其实这就是他本人，我觉得不幸的童年导致他这样特性，同时也造就了他的人生。 2. 梦想的价值 梦想还是要有的，万一实现呢？从小对太空有浓厚兴趣的埃隆·马斯克，通过SpaceX在一步步实现儿时的梦想。从他参加火星协会、提问公司火箭工程师、学习大量专业知识看出，他是真的喜欢。 3. 改变世界 “我认为现在有非常多的聪明人都在致力于互联网、金融和法律，”马斯克在路上说，“这是我们没能看到更多创新的部分原因。” 早期他自己非常想做游戏，但是没有从事的原因是：游戏做的再好，又不能改变世界。他觉得应该对人类的未来发展做出贡献和帮助才行，所以他提出非常大胆的想法，例如移民火星、超级高铁等等。 硅谷钢铁侠]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017IFE-通过HTML及CSS模拟报纸排版]]></title>
    <url>%2F2017%2F08%2F25%2F2017IFE-%E9%80%9A%E8%BF%87HTML%E5%8F%8ACSS%E6%A8%A1%E6%8B%9F%E6%8A%A5%E7%BA%B8%E6%8E%92%E7%89%88%2F</url>
    <content type="text"><![CDATA[前言2017-百度前端技术学院编码任务：通过HTML及CSS模拟报纸排版 任务目的 深入掌握CSS中的字体、背景、颜色等属性的设置 进一步练习CSS布局 任务描述 参考 PDS设计稿（点击下载），实现页面开发，要求实现效果与 样例（点击查看） 基本一致 页面中的各字体大小，内外边距等可参看 标注图（点击查看） 页面宽度固定（定宽） DEMO 项目地址 实现 字体 font简写字体属性 1/* font简写声明顺序：style | variant | weight | size/line-height | family */ font-style定义字体风格 123456789.normal &#123; font-style: normal; //选择 font-family常规字体&#125;.italic &#123; font-style: italic; //选择斜体，如果当前字体没有可用的斜体版本，会选用倾斜体（oblique ）替代&#125;.oblique &#123; font-style: oblique; //选择倾斜体，如果当前字体没有可用的倾斜体版本，会选用斜体（ italic ）替代&#125; font-variant定义小型大写字母的字体 1234p.small &#123; font-variant:small-caps; //设置为小型大写字母的字体 &#125; font-weight定义字体的粗细 123456789101112131415161718/* normal 默认值。定义标准的字符。bold 定义粗体字符。bolder 定义更粗的字符。lighter 定义更细的字符。100200300400500600700800900定义由粗到细的字符。400 等同于 normal，而 700 等同于 bold。*/p.normal &#123;font-weight:normal;&#125; //默认正常p.thick &#123;font-weight:bold;&#125; //字体为粗体p.thicker &#123;font-weight:900;&#125; //可设置数字，由小到大设置粗细 font-size定义字体的尺寸 123456789/*smaller 把 font-size 设置为比父元素更小的尺寸。larger 把 font-size 设置为比父元素更大的尺寸。length 把 font-size 设置为一个固定的值。% 把 font-size 设置为基于父元素的一个百分比值。*/h1 &#123;font-size:18px;&#125;h2 &#123;font-size: smaller;&#125;p &#123;font-size: larger;&#125; font-family定义元素的字体系列 浏览器会使用识别的第一个字体系列，如果没有就使用浏览器默认字体 123456789/*amily-namegeneric-family用于某个元素的字体族名称或/及类族名称的一个优先表。默认值：取决于浏览器。*/p &#123; font-family:"Times New Roman",Georgia,Serif; &#125; 背景 background简写背景属性 background-size 这个属性的定义必须在 之后, 并使用 ‘/‘ 符号分隔 123456789101112background-colorbackground-position/background-sizebackground-repeatbackground-originbackground-clipbackground-attachmentbackground-imagebody &#123; background: #00FF00 url(bgimage.gif) no-repeat fixed top; &#125; background-color设置背景颜色 123456789101112131415161718/**color_name 规定颜色值为颜色名称的背景颜色（比如 red）。hex_number 规定颜色值为十六进制值的背景颜色（比如 #ff0000）。rgb_number 规定颜色值为 rgb 代码的背景颜色（比如 rgb(255,0,0)）。transparent 默认。背景颜色为透明。**/body &#123; background-color:yellow; &#125;h1 &#123; background-color:#00ff00; &#125;p &#123; background-color:rgb(255,0,255); &#125; background-position设置元素背景图片的位置 1234 默认左上角- 关键词：left,top- 百分比：25%，50%，如果只设置一个值，另外自动为50%- 像素：24px,40px, background-size设置元素背景图片的尺寸 12345background-size: length|percentage|cover|contain;length: 固定的像素percentage：百分比设置cover：缩放背景图片以完全覆盖背景区，可能背景图片部分看不见contain：缩放背景图片以完全装入背景区，可能背景区部分空白 background-repeat设置背景图片的平铺模式 1234repeat 默认。背景图像将在垂直方向和水平方向重复。repeat-x 背景图像将在水平方向重复。repeat-y 背景图像将在垂直方向重复。no-repeat 背景图像将仅显示一次。 background-originbackground-origin 属性规定 background-position 属性相对于什么位置来定位。 12345678padding-box(默认)背景图像相对于内边距框来定位。border-box背景图像相对于边框盒来定位。content-box背景图像相对于内容框来定位。 background-clip设置背景的绘制区域 12345678border-box(默认)背景被裁剪到边框盒。padding-box背景被裁剪到内边距框。content-box背景被裁剪到内容框。 background-attachment设置背景图片是否固定或者随着页面滚动 12scroll 默认值。背景图像会随着页面其余部分的滚动而移动。fixed 当页面的其余部分滚动时，背景图像不会移动。 background-image设置元素的背景图片 12url('URL') 指向图像的路径。none 默认值。不显示背景图像。 颜色三种方式描述颜色 关键字：red RGB系统： rgb(255,0,51) rgba(255,0,51,.5) HSL系统：hsl(240,100%,50%)或hsla(240,100%,50%,0.05) currentColor 关键字表示和当前元素的color一样的颜色 文本 text-indent文本缩进 123456length 定义固定的缩进。默认值：0。% 定义基于父元素宽度的百分比的缩进。// 文本缩进2字符text-indent：2em;em默认父元素字体大小的倍数， text-align规定文本水平对齐方式 1234left 把文本排列到左边。默认值：由浏览器决定。right 把文本排列到右边。center 把文本排列到中间。justify 实现两端对齐文本效果。 word-spacing 字（单词）间距； 象形文字的语言或非罗马书写体往往无法指定字间隔，注意对中文无效 123456normal 默认。定义单词间的标准空间。length 定义单词间的固定空间。p &#123; word-spacing:25px; &#125; letter-spacing字母间距 1234与word-spacing类似，区别在于它是对字母或单个字符产生影响h1 &#123;letter-spacing:2px&#125;h2 &#123;letter-spacing:-3px&#125; text-transform 文本大小写 1234none 默认。定义带有小写字母和大写字母的标准的文本。capitalize 文本中的每个单词以大写字母开头。uppercase 定义仅有大写字母。lowercase 定义无大写字母，仅有小写字母。 text-decoration 文本的装饰 一个规则中结合多种装饰 text-decoration属性是一种简写属性，并且可以使用普通属性三个值中的任何一个。普通属性如下：text-decoration-line ，text-decoration-color和text-decoration-style 12345none 默认。定义标准的文本。underline 定义文本下的一条线。overline 定义文本上的一条线。line-through 定义穿过文本下的一条线。blink 定义闪烁的文本。 white-space处理元素内的空白 12345normal 默认。空白会被浏览器忽略。pre 空白会被浏览器保留。其行为方式类似 HTML 中的 &lt;pre&gt; 标签。nowrap 文本不会换行，文本会在在同一行上继续，直到遇到 &lt;br&gt; 标签为止。pre-wrap 保留空白符序列，但是正常地进行换行。pre-line 合并空白符序列，但是保留换行符。 direction属性规定文本的方向 / 书写方向 12ltr 默认。文本方向从左到右。rtl 文本方向从右到左。 问题 首行字母大写的长宽过大，布局变形解答：利用伪元素 first-letter 针对整体第一行的首字母进行处理123456/* 使每段开头的第一个字母变红变大 */p::first-letter &#123; /* 使用:first来兼容IE8- */ color: red; font-size: 130%;&#125; 查看链接 CSS 文本 CSS 背景 CSS 字体 color]]></content>
      <categories>
        <category>IFE</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>IFE</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见排序算法]]></title>
    <url>%2F2017%2F07%2F05%2F%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最近看到一篇介绍排序算法的文章，自己在此学习总结一下。 1-冒泡排序算法思路 依次比较相邻2个数的大小，如果不符合要求则交换。这样第一轮循环结束，最大值或最小值排在数组最后一位。剩下的数值重复以上步骤，直到排序结束。 以对数组[3,2,5,1,4] 进行从小到大排序为例，步骤如下： 3和2比较，3大于2。交换位置，数组为[2,3,5,1,4] 3和5比较，3小于5。不交换位置，数组不变。 5和1比较，5大于1。交换位置，数组为[2,3,1,5,4] 5和4比较，5大于4。交换位置，数组为[2,3,1,4,5] 这样第一轮循环结束，最大值5排在数组最后一位。然后再对剩下的数值重复这个过程，这样下来每次循环都会排到一个正确的数值。直至剩下最后一个位置，所有排序结束。 代码实现1234567891011121314151617181920212223//交互数值函数function swap(myArray, p1, p2)&#123; var temp = myArray[p1]; myArray[p1] = myArray[p2]; myArray[p2] = temp;&#125;//冒泡排序function bubbleSort(myArray) &#123; var len = myArray.length, stop = 0; for(let i = 0; i &lt; len - 1; i++)&#123; for(let j = 0,stop = len - 1 - i; j &lt; stop; j++)&#123; if(myArray[j] &gt; myArray[j+1])&#123; swap(myArray, j, j + 1); &#125; &#125; &#125; return myArray;&#125; 2-选择排序算法思路 选择排序与冒泡类似，也是相邻位2个数比较大小。不同的是当不符合要求时，不是立马交换位置，而是给当前数值标记来表明最小或最大值，并且当前的最小或最大值依次比较数组里的数值。等一轮结束，找出最小或最大值再交换位置，其余位置不变。剩余数值重复以上步骤，直到排序结束。 以对数组[3,2,5,1,4] 进行从小到大排序为例，步骤如下： 假设第一个位置的3为最小值。 最小值3和2比较，3大于2。那么2标记为最小值。 最小值2和5比较，2小于5。最小值标记不变。 最小值2和1比较，2小于1。那么1为最小值。 最小值1和4比较，1小于4。最小值标记不变。 一轮结束后，第一位置的3和第四位置的1交换位置，数组为[1,2,5,3,4] 第一轮结束后，最小值1排到正确位置。剩下数值重复上述步骤，直到排序结束。 代码实现1234567891011121314151617181920212223242526//选择排序function selectionSort(myArray) &#123; let len = myArray.length; for(let i = 0; i &lt; len; i++)&#123; //假设当前位置为最小值 let min = i; //遍历剩下数字是否为最小 for(let j = i + 1; j &lt; len; j++)&#123; if(myArray[j] &lt; myArray[min])&#123; min = j; &#125; &#125; //如果当前位置不是最小值，替换最小值 if(i !== min)&#123; swap(myArray,i,min); &#125; &#125; return myArray;&#125; 3-插入排序算法思路 将数组分为两部分，一个是已排序，一个是未排序。最开始已排序只有一个数值，然后将已排序最后一个元素后面的元素从未排序里取出，插入到已排序里并且进行排序。这样”已排序“增加一个，未排序减少一个。重复以上步骤，直到排序结束。 以对数组[3,2,5,1,4] 进行从小到大排序为例，步骤如下： 数组[3,2,5,1,4]分为已排序为[3]和未排序为[2,5,1,4] 已排序最后一个元素是3，未排序第一个元素是2，2小于3。那么已排序为[2,3]，未排序为[5,1,4] 已排序最后一个元素是3，未排序第一个元素是5，5大于3。那么已排序为[2,3,5]，未排序为[1,4] 已排序最后一个元素是5，未排序第一个元素是1，1小于5。继续比较已排序的前一个元素3，1小于3，继续比较已排序的前一个元素2，1小于2，所以1为第一位元素，那么已排序为[1,2,3,5]，未排序为[4] 已排序最后一个元素是5，未排序第一个元素是4，4小于5。继续比较已排序的前一个元素3，4大于3。因为4是未排序里最后一个元素，所以排序结束，结果为[1,2,3,4,5] 代码实现12345678910111213141516171819202122232425//插入排序function insertionSort(myArray) &#123; let len = myArray.length, value = 0; //需要比较的当前值 for(let i = 0; i &lt; len; i++)&#123; //i 为未排序的当前位置 //负责当前比较的值 value = myArray[i]; /** * 已排序的当当前值大于比较值 * 已排序后移一位再次比较value * **/ for(var j = i - 1; j &gt; -1 &amp;&amp; myArray[j] &gt; value; j--)&#123; //j 为已排序的当前位置 myArray[j+1] = myArray[j]; &#125; myArray[j+1] = value; &#125; return myArray;&#125; 4-合并排序算法思路 基本思路是化整为零，将数组拆分为n个单个元素的数组，然后不断两两合并，直到排序完成。 以对数组[3,2,5,1,4] 进行从小到大排序为例，步骤如下： 拆分为[3,2] 和 [5,1,4] [3,2]拆分为[3] 、[2],然后合并为[2,3] 将[5,1,4]拆分为[5]和[1,4] [1,4]拆分为[1]和[4],然后合并为[1,4] 在将[1,4]和[5]合并起来为[1,4,5] 最后合并[2,3]和[1,4,5]，返回结果[1,2,3,4,5] 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** 合并两个已排序数组，这是关键代码* merge函数将2个已排序的数组进行合并，首先2个数组的第一个元素进行对比，较小的添加到result里，然后较大的元素和另外一个数组的第二个元素继续比较，同时把较小值添加到result，如此循环，直到其中一个数组长度为0,同时result合并截取后的2个数组。*/function merge(left, right)&#123; var result = [], il = 0, ir = 0; while (il &lt; left.length &amp;&amp; ir &lt; right.length)&#123; if (left[il] &lt; right[ir])&#123; result.push(left[il++]); &#125; else &#123; result.push(right[ir++]); &#125; &#125; return result.concat(left.slice(il)).concat(right.slice(ir));&#125;/**mergeSort不断拆分均分数组，直到数组长度为1或0，然后利用merge不断合并**/function mergeSort(myArray) &#123; if(myArray.length &lt; 2)&#123; return myArray; &#125; var middle = Math.floor(myArray.length / 2), left = myArray.slice(0,middle), right = myArray.slice(middle), params = merge(mergeSort(left),mergeSort(right)); //返回的数组头部加2个参数，0 和数组长度 params.unshift(0,params.length); /** * splice的参数无法直接使用数组，所以使用apply， * 第一个参数是开始的位置，第二参数删除元素的个数， 其余参数为需要添加进数组的元素 这样做的原因是避免产生新数组，占用多余空间，直接在原数组修改 * * */ myArray.splice.apply(myArray,params); return myArray;&#125; 5-快速排序算法思路 先确认一个支点，所以小于支点的数值放到该点的左侧，大于支点的数值放到该点的右侧，然后对左右两侧重复上述操作，直到排序结束。 具体做法是： 先确认支点，一般取数组中间值。 建立数组两端的指针，左侧指针指向数组第一个元素，右侧指针指向数组最后一个元素。 左侧指针指向元素值依次与支点比较大小，如果小于支点指针则向后移动，否则指针停止原地。 右侧指针指向元素值依次与支点比较大小，如果大于支点指针则向前移动，否则指针停止原地。 左右两侧指针的下标比较，如果左侧小于右侧则交换数值，而大于则本轮排序结束。 重复以上步骤，排序结束。 以对数组[3,2,5,1,4] 进行从小到大排序为例，步骤如下： 先确认支点，我们这里取中间值5。 左侧指针指向数组第一个元素3，3小于5，指针向后移动一位，2小于5，指针向后移动一位，5等于5，指针停止移动。 右侧指针指向数组最后一个元素4，4小于5，指针停止移动。 左侧指针下标为2，右侧指针下标为4，所以交换数值，交换后数组为[3，2，4，1，5] 左侧指针继续向后移动一位，1小于5，指针向后移动一位，5等于5，指针停止移动。 右侧指针向前移动一位，1是小于5，指针停止移动。 左右指针下标比较，左指针是4，右指针是3，左侧大于右侧，本轮排序结束。 [3,2,4,1]和[5],分别继续以上步骤，直到排序结束。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546//快速排序function partition(myArray, left, right) &#123; var pivot = myArray[Math.floor((left + right) / 2)], i = left, //左侧下标 j = right; //右侧下标 while (i &lt;= j)&#123; while (myArray[i] &lt; pivot)&#123; i++; &#125; while(myArray[j] &gt; pivot)&#123; j--; &#125; if(i &lt;= j)&#123; swap(myArray,i,j); i++; j--; &#125; &#125; return i;&#125;function quickSort(myArray, left, right) &#123; if(myArray.length &lt; 2)&#123; return myArray;&#125; left = (typeof left !== 'number' ? 0 : left); right = (typeof right !== 'number' ? myArray.length - 1 : right); var index = partition(myArray, left, right); //递归 if(left &lt; index -1)&#123; quickSort(myArray,left,index - 1); &#125; if(index &lt; right)&#123; quickSort(myArray,index,right); &#125; return myArray;&#125; 参考链接 排序算法]]></content>
      <categories>
        <category>算法</category>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017IFE-使用CSS实现折叠面板]]></title>
    <url>%2F2017%2F06%2F06%2F2017IFE-%E4%BD%BF%E7%94%A8CSS%E5%AE%9E%E7%8E%B0%E6%8A%98%E5%8F%A0%E9%9D%A2%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[前言2017-百度前端技术学院编码任务：使用CSS实现折叠面板 任务目的 深入理解html中radio的特性 深入理解CSS选择器以及伪元素的使用 任务描述 使用input的radio单选框特性结合CSS中的伪元素实现bootstrap中折叠面板(点击查看样例)，要求样式一致。 DEMO 项目地址 实现 思路就是利用input[type=radio]所具有的单选特性,然后利用伪类或者伪元素来显示或者隐藏。 html中radio的特性label它通常关联一个控件，或者是将控件放置在label元素内，或者是用作其属性。 我这里是利用属性for来关联控件，而input[type=radio]就是单选按钮，这样我们就可以控制显示和隐藏的效果。 1234&lt;label for="headingOne" class="panel"&gt;Collapsible Group Item #1&lt;/label&gt;&lt;input type="radio" id="headingOne" name="Collapsible" checked="checked" &gt;&lt;div class="Accordion-box__content"&gt;Anim pariatur cliche reprehenderit, enim eiusmod high life accusamus terry richardson 。。。&lt;/div&gt; CSS选择器以及伪元素的使用这里我没有使用伪元素去实现，假如每个内容是不一样的，通过元素来设置可以更好的自定义。 兄弟选择器(+ 和 ~) a+b 元素a下一个兄弟元素b a-b 元素a后面拥有共同父元素的兄弟元素b 1234567.Accordion-box input[type=radio]:checked + div &#123; padding: 15px; opacity: 1; height: auto; border-top: 1px solid #ddd; &#125; 参考链接 label 相邻兄弟选择器]]></content>
      <categories>
        <category>IFE</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>IFE</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017IFE-自定义网页右键菜单]]></title>
    <url>%2F2017%2F06%2F05%2F2017IFE-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E9%A1%B5%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[前言2017-百度前端技术学院编码任务：自定义网页右键菜单 任务目的 了解js中的oncontextmenu事件 了解如何获取鼠标位置 了解如何实现页面屏蔽右键菜单 任务描述 实现鼠标右击时，出现自定义菜单。点击非自定义菜单区域时，隐藏自定义菜单。参考样例（点击查看） 实现页面开发，要求实现效果基本一致。 点击自定义菜单条目时，弹出菜单条目名称。 DEMO 项目地址 实现js中的oncontextmenu事件oncontextmenu事件属于鼠标事件类型，在元素中用户右击鼠标时触发并打开上下文菜单。事件属于DOM对象，是和文档交互主要方式。 获取鼠标位置当我们触发事件的时候，函数会返回一个事件对象，其中就有关于鼠标位置的属性，并且这些属性都是只读属性。 event.clientX、event.clientY 返回事件触发时鼠标相对于元素视口的X或者Y坐标，这里元素视口是指浏览器窗口，可视区域不包括工具栏和滚动条，并且是以浏览器左上角为基点来计算长度。 这是W3C认可的标准，IE事件和标准事件都定义了这2个属性。 event.screenX、event.screenY 返回事件触发时鼠标相对于屏幕 的X或者Y坐标，这个很好理解就是相对设备屏幕的距离，同样是左上角作为基点计算长度。 这是W3C认可的标准，IE事件和标准事件都定义了这2个属性。 event.pageX、event.pageY 返回事件触发时鼠标相对于文档 的X或者Y坐标，这里的文档可以理解为document，它们使用的是文档坐标而非窗口坐标，所以包括滚动的距离。 这2个属性不是标准属性，但得到了广泛支持。IE事件中没有这2个属性。 event.offsetX、event.offsetY 返回事件触发时鼠标相对于事件指向元素 的X坐标，这里的距离坐标是相对触发事件的元素而言的。 假设有一个元素&lt;p&gt;test&lt;/p&gt;当鼠标进入元素中触发事件时这是offsetX指的就是鼠标到P元素左边的距离。 但是这个属性并不是标准属性，因此IE和chrome对这个属性的支持并不一样。在chrome中offsetX和offsetY的值均为整数，而在IE中值为小数形式，并且如果元素有border属性也会影响到offsetY的计算。 另外DOM对象会返回元素对象的长宽数据 clientWidth 元素内容+内边距 元素内容的可视宽度（不包括边框，边距或滚动条） offsetWidth 元素内容+内边距+边框 元素的宽度，包括边框 实现页面屏蔽右键菜单通过事件阻止来达到屏蔽右键菜单 事件阻止有三个方法： preventDefault，stopPropagation，stopImmediatePropagation。 preventDefault 简单理解取消事件的默认行为，前提是DOM对象cancelable属性为true。 你可以查看 event.cancelable 属性来判断一个事件的默认动作是否可以被取消. 在cancelable属性为false的事件上调用 preventDefault 方法没有任何效果. stopPropagation 阻止捕获和冒泡阶段中当前事件的进一步传播。标准规定监听事件默认是冒泡模式 stopImmediatePropagation 阻止调用相同事件的其他侦听器。 本身的事件传播被阻止，同时后续的相同类型事件监听函数也被阻止。 如果元素注册了相同类型事件的多个监听函数，那么触发事件将依次执行。但是如果遇到某个监听函数执行event.stopImmediatePropagation()方法，则除了该事件的冒泡行为被阻止之外(event.stopPropagation方法的作用),该元素绑定的后序相同类型事件的监听函数的执行也将被阻止. 参考链接 oncontextmenu 事件 clientX/clientY 与 screenX/screenY 的区别 offsetheight height clientHeight outerHeight等的区别 event.preventDefault event.stopPropagation event.stopImmediatePropagation]]></content>
      <categories>
        <category>IFE</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>IFE</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[徒步北京的中轴线]]></title>
    <url>%2F2017%2F06%2F03%2F%E5%BE%92%E6%AD%A5%E5%8C%97%E4%BA%AC%E7%9A%84%E4%B8%AD%E8%BD%B4%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[前言 北京中轴线，是指北京自元大都、明清北京城以来北京城市东西对称布局建筑物的对称轴，北京市诸多其他建筑物亦位于此条轴线上。明清北京城的中轴线南起永定门，北至钟鼓楼，直线距离长约7.8公里。 上世纪九十年代，北京为连接城市中心和亚运村，在二环路钟鼓楼桥引出鼓楼外大街，向北至三环后改名为北辰路，这条路成为北京中轴线的延伸，西边建造中华民族园，东边则是国家奥林匹克体育中心。 北京申奥成功后，中轴线再次向北延长，成为奥林匹克公园的轴线。东边建造国家体育场（鸟巢），西边则是国家游泳中心（水立方）。再向北，穿过奥林匹克公园，到达奥林匹克森林公园，该公园中间的仰山、奥海均在中轴线上。 计划路线 从南到北徒步，起点是老北京外城的永定门，终点是奥林匹克森林公园南门。 总的长度大概20公里左右，放心一路都是好的风景，包你满意。 建议装备既然是长距离的徒步，总的原则是轻便简单，让我们轻装上阵，专注徒步本身。 一双舒适的运动休闲鞋（徒步诶，不然你穿什么呢） 轻便小巧的包 (装下面的东西) 手机或微单、无线自拍装备 (留下徒步的回忆) 充电宝、运动App (没电怎么记录你的徒步路线) 吃的喝的建议就在路上买吧，那东西不符合轻便的原则。 最后，还有最重要的一点，带着 简单和舒适的心情 ，这样你才能轻松去感受徒步的快乐并且享受其中的过程！ 主要景点起点-永定门我是先坐地铁到永定门外，从A口出来走到永定门的南广场。其实距离广场不远处你就能看见永定门。一般来说同时也会看见天空有许多风筝。 这里风筝比较有意思，首先外观大小上都是比较小型的风筝，其次外形样式上都是大同小异的，我都怀疑是不是同一家买的，最后普遍飞的比较低并且不好控制，你会看见那个风筝呼一下从空中急速下坠从你身边掠过，然后放风筝的大爷通过自己高超的本领让它再次起飞。 说说历史吧，大致了解了一下。永定门，是明清北京外城城墙的正门，位于北京中轴线上，于左安门和右安门中间，是北京外城城门中最大的一座，也是从南部出入京城的通衢要道。 永定门始建于明嘉靖三十二年（1553年），寓“永远安定”之意。永定门瓮城城墙于1950年开始被陆续拆除，1957年以妨碍交通和已是危楼为名，永定门城楼和箭楼遭到拆毁，2004年北京永定门城楼复建，其中瓮城和箭楼尚未修建，成为北京城第一座复建的城门。 绕过永定门后就来到永定门公园，整个公园以中轴线为中心修建，我去的时候是早上，但是已经有很多人在公园里活动了。比较有意思是，很多文艺爱好者在这里活动，比如我就遇到一群大爷大妈文艺爱好者，大爷们大部分吹着口琴，少部分人敲着鼓和其他乐器，基本就是小型的乐队，大妈们随着音乐的节奏翩翩起舞，我都情不自禁的鼓起了掌，实在是精彩，特别是同时吹口琴的大爷们太有魅力了。 天桥 走出公园后面对马路，左边是天桥百货商场，右边是天坛西门。这个地方其实很有意思，这个地方原来有一座桥，是明清皇帝来天坛祭天的必经之路。皇帝又称为天子，天子所走之桥，故叫天桥。因此附近地区因此得名。 这个地方同时也是北京平民游艺场所聚集地和商品市场，内有众多曲艺演出场所。天桥因市场的兴起而繁荣发展，而这一市场，又是面向平民大众，集文化娱乐和商业服务为一体，文商结合, 互为促进。聚集了当时很多的民间艺人，故而形成了许多民间艺术和文化。这个地方很长时间内都是北京民间文艺活动中心，那你可以理解为它就是当时北京的“演艺圈”。 1957年后，天桥的艺人后多不再天桥聚集，这些人有的改做他行，有的成为文化骨干或运动员。中华人民共和国文化部在2004年启动了中国民族民间文化保护工程，天桥文化也被列入其中。 到现在为止这个地方文艺活动还是很丰富，大家熟知的德云社大本营就在天桥剧院隔壁。通往天桥百货商场的地下通道里，我还遇到了许多学习爵士舞的大爷大妈们，穿着专业的舞蹈服饰练习，佩服那样的年纪还有如此活力，感觉岁月在他们的身上只是淡淡的走过而已。不过这时想起之前公园遇到乐队，自然就豁然开朗了，这个地方本身艺术氛围就浓厚啊。你想想，没人跳流行的广场舞，人家都跳爵士舞和吹口琴诶，真潮。 当然附近还有很多地方值得看看，比如首都电影院、天坛和自然博物馆等等，由于时间关系我就没有去仔细看了。 另外，在天桥模型下面的地下通道的墙壁上有许多关于北京桥的介绍，值得大家去看看。 前门大街我一路向北，路过珠市口后，就马上来到了前门大街。前门大街是北京非常著名的商业街。位于京城中轴线，北起前门月亮湾，南至天桥路口，与天桥南大街相连。明嘉靖二十九年（1550）建外城前是皇帝出城赴天坛、山川坛的御路，建外城后为外城主要南北街道。民众俗称前门大街。大街长845米，行车道宽20米。明、清至民国时皆称正阳门大街。1965年正式定名为前门大街。 正阳门正阳门，俗称前门、前门楼子、大前门，原名丽正门，是明清两朝北京内城的正南门。位于北京城南北中轴线上的天安门广场最南端，毛主席纪念堂南边。始建于明成祖永乐十七年（1419年），是老北京“京师九门”之一。它集正阳门城楼、箭楼与瓮城为一体，是一座完整的古代防御性建筑体系。 据地方志上记载：当时的城楼、箭楼规模宏丽，形制高大；瓮城气势雄浑，为老北京城垣建筑的代表之作，现仅存城楼和箭楼，是北京城内唯一保存较完整的城门。城楼上有北京民俗展览馆。 正阳门城楼属于天安门广场，你得先通过安检进入广场才能上城楼。 西交民巷和国家大剧院当然来到正阳门，如果没有去过广场或者想去城楼看看的同学，建议还是可以去看看。我个人去过了，所以我绕道西交民巷，路过国家大剧院，再回到中轴线上继续步行。 这里说一下西交民巷，沿着广场西侧路左手边就会看到许多民国的建筑，那就是西交民巷了。这些民国建筑大部分都是银行旧址，西交民巷是晚清以来到二十世纪后期约一百年的金融街，但是随着北洋政府的倒闭和南京国民政府的成立，金融中心逐渐迁移到上海地区。 我去国家大剧院是因为本身这个建筑很漂亮，这个建筑周围是人工湖，而建筑本身本身很像一滴巨大的“水珠”，显得与周围严肃的人民大会堂和古老的故宫格格不入，但是这样也突出这个建筑的独特之处。 中山公园和故宫看完国家大剧院后，通过安检就来到了天安门城楼区域，由于人太多加上时间的问题我就没进去，本身来过好几次了。我就直接从中山公园南门进东门出，通过阙右门就来到故宫的午门，午门也是参观故宫的入口，这里基本一年四季都是很多人。 中山公园它原是明清两代的社稷坛，与太庙（今劳动人民文化宫）一起沿袭周代以来“左祖右社”的礼制建造。后来是1925年孙中山先生在北京逝世，在园内拜殿（今中山堂）停放灵柩，举行公祭。为纪念这位伟大的民主革命先驱，1928年改名为中山公园。 故宫是那种你去多少次都不会厌的地方，如果参观建议大家早上早点来，避开高峰期人多的时候，故宫会显得格外的安静。 然后从阙左门出来，沿着故宫城墙从东华门出来，沿着北池子大街向北来到了景山公园南门。景山公园是老北京的制高点，从万春亭上可以一览全北京的风景。我自己来过好几次了，个人建议早上或者下午接近太阳下山的时候来，这样你可以看日出和夕阳，老北京的风光在不同的时候拥有不一样的美。图片不好找了，就盗图给大家一意思意思吧。 地安门绕过景山公园，来到地安门内大街，然后走着走着你会来到一个十字路口，这个十字路口就是当初地安门旧址所在地了。地安门 是北京中轴线上的重要标志性建筑之一，是皇城的北门，天安门则是皇城的南门。南北互相对应，寓意天地平安，风调雨顺。很可惜的是建国后同样和北京许多城门一样由于城市建设被拆除了。 由于明清时期一直遵守“前朝后市”的原则，所以地安门外大街很热闹，而且还有很多美食哦。喜欢美食的朋友不要错过。我走到这里差不多中午左右，看到这么多美食，就停下脚步寻找好吃的了。果不然在一个不起眼的小巷里发现重庆特色小吃店，老板是来自重庆一对50多岁的夫妻。说真的，我是重庆人，可能是长期不怎么吃辣，我真的被辣出汗和眼泪了，不过是还是爽翻天。 钟鼓楼吃完饭了，继续向北走就能看见鼓楼了。北京钟鼓楼是坐落在北京市南北中轴线北端的一组古代建筑，位于北京东城区地安门外大街北端，这也是老北京中轴线的终点。 钟鼓楼是元、明、清代都城的报时中心。在古代，鼓楼定更击鼓、钟楼撞钟报时极有规律。古人将黑夜分为五更，每更次为一个时辰，即现代的两个小时。元明两代的报时方法已无据可查，清代原规定报时方法为：定更及亮更，皆先击鼓后敲钟，其二至四更则只敲钟不击鼓。 乾隆后改为只在夜里报两次更，每晚定更（即一更，19点—21点）和亮更（即五更，3点—5点）先击鼓后撞钟。定更时钟声响城门关，交通断，称为“净街”；亮更时，钟声响城门开，所谓“晨钟暮鼓”。 那么有个问题，那鼓手怎么知道现在是几点呢？在古代，铜刻漏计时，鼓手们听到铙响后击鼓定更，钟楼听到鼓声后撞钟报时。铜刻漏就是古代计时装置，它会提醒鼓手什么时辰击鼓。现在的计时是采取国际标准的时区制度，规定将全球划分为24个时区（东、西各12个时区），规定英国（格林尼治天文台旧址）为中时区（零时区），在中国采用首都北京所在地东八区的时间为全国统一使用时间，也就是新闻联播经常说的北京时间。 奥林匹克公园走完老北京的中轴线后，基本没啥好看的了。我们沿着北辰路大步向北走吧，朝着终点奥林匹克森林公园前进。安检进入公园后，你就会看到国家体育场鸟巢和国家游泳中心水立方，两个奥运会的主要建筑分别位于景观大道东侧和西侧，而景观大道本身就是北京中轴线的延伸，大道南起熊猫环岛，北至森林公园南门广场，总长3.7千米。由于办了年卡，我还免费参观了水立方，还不错哦。 北京奥林匹克公园分为三部分：北部是6.8平方千米的奥林匹克森林公园、中部是3.15平方千米的中心区、南部是1.64平方千米的已建成和预留区（奥体中心）。南部是1990亚运会主要场馆区域，中部就是2008奥运会主要区域，鸟巢和水立方主要场馆就在中部，北部就是奥林匹克森林公园了。 景观大道的尽头就是奥林匹克森林公园，图片尽头的小山头就是仰山。 最后来到了北京中轴线徒步路线的终点：奥林匹克森林公园南门，此处应该给自己一点掌声（还要掌声，不要脸）。 最后说真的，写这个感觉比徒步还累啊。。。 个人觉得徒步最大的优势就是你可以通过自己的双脚去感受脚下这片土地上的事物带来的魅力，你的所见所闻是真实的，这是属于你自己的东西。 很多人旅游总喜欢看各种攻略等之类的东西，当然我不是反对这样东西，有时候确实可以让人少走一些坑或者预防一些错误的发生，但是如果太详细或者具体的话，可能会反而失去一些未知或期待。我是觉得旅行中让你印象深刻的总是那些所谓的“意外”。 最后附上徒步的路线图片，推荐大家有时间的话，可以徒步北京的中轴线，去感受和了解这个城市现代和古老的一面。 完 以上部分资料来自百度百科。]]></content>
      <categories>
        <category>随笔</category>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂文</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017IFE-自定义checkbox， radio样式]]></title>
    <url>%2F2017%2F06%2F01%2F2017IFE-%E8%87%AA%E5%AE%9A%E4%B9%89checkbox%EF%BC%8C-radio%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言2017-百度前端技术学院编码任务：自定义checkbox， radio样式 任务目的 深入了解html label标签 了解CSS边框、背景、伪元素、伪类（注意和伪元素区分）等属性的设置 了解CSS中常见的雪碧图，并能自己制作使用雪碧图 任务描述 参考 样例点击查看，实现页面开发，要求实现效果基本一致 注意：尝试背景图和伪元素两种不同方式实现，对比两种方式各自的优缺点。注意测试不同情况，尤其是极端情况下的效果。 DEMO 项目地址 实现 整体解决思路：隐藏表单默认样式，伪类或背景图片来自定义样式，通过伪类:checked来改变选择状态并且切换样式。 label&lt;label&gt;它通常关联一个控件，或者是将控件放置在label元素内，或者是用作其属性。 产生关联可以和控件产生联系，例如：点击标签label元素可以改变&lt;input type=&quot;radio&quot;&gt;的 :checked 状态，或者获得&lt;input type=&quot;text&quot; id=&quot;User&quot; name=&quot;Name&quot; /&gt;的焦点状态。 之前思考过隐藏input后，为什么要用label元素来伪装表单呢？原因是其他元素无法和input产生关联，点击其他元素是无法改变表单的checked 状态，而点击label是可以的。 示例 1234567/*放在标签元素内产生关联*/&lt;label&gt;Click me &lt;input type="text" id="User" name="Name" /&gt;&lt;/label&gt;/*通过设置for属性产生关联*/&lt;label for="User"&gt;Click me&lt;/label&gt;&lt;input type="text" id="User" name="Name" /&gt; 伪类和伪元素的区别其实关于这部分自己之前做过一次总结。结论就是，伪类和伪元素都是给元素添加效果，不同的是伪类是相当于添加一个类class，伪元素相当于添加一个元素element。 另外:checked CSS 伪类选择器表示任何处于选中状态的radio(&lt;input type=&quot;radio&quot;&gt;), checkbox (&lt;input type=&quot;checkbox&quot;&gt;) 或(“select“) 元素中的option HTML元素(“option”)) 。用户通过点击元素或选择其他的值，可以改变该元素的 :checked 状态，并:checked属性赋给一个新的对象(例如其他的option值)。 input[type=”radio”]:checked表示页面上的所有选中的radio按钮 input[type=”checkbox”]:checked表示页面上的所有选中的checkbox按钮 option:checked表示页面上的所有选中的select的选项 CSS 属性 - 伪类和伪元素的区别 伪类和背景图片实现伪类 点击label或者input改变input的checked状态，同时改变样式和添加伪元素来达到模拟表单效果。 12345678910111213141516171819202122232425.input-disguise__radio &gt; input:checked + label::after,.input-disguise2__radio &gt; input:checked::after&#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); content: ''; text-align: center; width: 6px; height: 6px; border-radius: 50%; background: #d81e06;&#125;.input-disguise__checkbox &gt; input:checked + label::after,.input-disguise2__checkbox &gt; input:checked::after&#123; position: absolute; top:-2px; left: 1px; content: '\2714'; text-align: center; color: #d81e06; font-size: 12px;&#125; 背景图片（雪碧图） 之前设置label元素模拟表单样式，这次通过背景图片来达到效果。然后通过background-position来定位背景图片位置.雪碧图的使用就是为了减少图片请求。 1234567891011121314151617181920212223242526.input-sprite__radio &gt; label,.input-sprite__checkbox &gt; label&#123; display: inline-block; width: 12px; height: 12px; border: 1px solid #d9d9d9; border-radius: 2px; background: url(img/input-sprite.png) 12px 0 no-repeat; background-size: 200% 100%;&#125;.input-sprite__radio &gt; input[type=radio]:checked + label&#123; background-position: 0 0; width: 14px; height: 14px; border: none;&#125;.input-sprite__checkbox &gt; input[type=checkbox]:checked + label&#123; background-position: 100% 0; width: 14px; height: 14px; border: none;&#125; 关于伪元素和雪碧图的优缺点： 雪碧图优点是减少代码量，简单有效；缺点是无法精准定位，没有伪元素准确，修改麻烦。 伪元素优点是图片请求减少，定位准确，方便修改；缺点代码量多，实现较复杂的效果比较麻烦。 参考链接 label元素 CSS伪伪类:checked CSS伪元素::after CSS 属性 - 伪类和伪元素的区别]]></content>
      <categories>
        <category>IFE</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>IFE</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017IFE-鼠标悬浮模糊效果]]></title>
    <url>%2F2017%2F05%2F27%2F2017IFE-%E9%BC%A0%E6%A0%87%E6%82%AC%E6%B5%AE%E6%A8%A1%E7%B3%8A%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[前言2017-百度前端技术学院编码任务：鼠标悬浮模糊效果 任务描述 实现图示效果 点击查看 实现文字的流光渐变动画 背景图需要进行模糊处理 实现按钮边框的从中间到两边扩展开 DEMO 项目源码 实现这个任务主要是学习和使用CSS3大部分的属性，主要使用的属性如下： CSS3 背景 - background CSS3 渐变 - gradients CSS3 转换 - transform CSS3 过渡 - transition CSS3 动画 - animation CSS3 滤镜 - filter 页面结构其实刚开始，我就在结构上面犯了错误。如果把图片作为背景图片使用，当使用filter模糊效果的时候，任何子元素都会产生模糊效果，那么后面文字和边框都是模糊不清的，所以应该采用单独使用图片元素 img 来显示背景图片。 1234567&lt;article class="box-warp"&gt; &lt;img src="img/icon_bg.JPG" alt="404" class="box-img"&gt; &lt;div class="box-background"&gt; &lt;h2 class="box-background__title"&gt;浙江美术馆&lt;/h2&gt; &lt;button type="button" class="box-background__btn"&gt;点击查看&lt;/button&gt; &lt;/div&gt;&lt;/article&gt; 实现文字的流光渐变动画 整体思路：利用渐变属性来设置背景颜色效果，同时背景剪裁为文字区域，设置文字颜色为透明色，最后给予动画效果让其动起来。 首先设置背景图片为线性渐变linear-gradient，设置方向为从左到右并且设置2段相同的颜色节点，0%和100%为相同的颜色，这样才可以更好的实现文字流光的效果。 渐变的方向其实是通过设置角度来控制，角度是通过水平线和渐变线之间产生的。默认方向从下到上就是0deg、从左到右就是90deg。 1background-image: linear-gradient(left,red,orange 25%,red 50%,orange 75%,red ); /*背景渐变色*/ 我们发现整个背景都是渐变色，我们只是需要文字的颜色变为渐变而已。我们开始利用-webkit-background-clip属性来背景剪裁为文字，同时设置文字的-webkit-text-fill-color或者color属性让其文字颜色为透明色，这样才有让文字显示为渐变色。 这里需要注意的是：背景裁剪为文字当前只有webkit内核浏览器支持，同时设置-webkit-text-fill-color和color，那么前者会覆盖后者属性值。 另外我们需要设置background-size: 200% 100%;，因为渐变颜色设置为2段相同的颜色节点，目的是为了重复2段相同的颜色，实现动画文字流光效果。 123-webkit-text-fill-color: transparent; /*文字透明 color: transparent; 同样的效果*/-webkit-background-clip: text; /*背景裁剪为文字 当前只有webkit内核浏览器支持*/background-size: 200% 100%; 目前就差动画了，首先需要设置动画规则 keyframes ，然后设置animation动画周期时间、速度曲线和播放次数。因为背景长度为200%，所以动画规则设置100% {background-position: -100% 0;}，让其沿着X轴变化从而产生流动效果。 123456789/*文字流光动画*/@keyframes flowLight&#123; 0% &#123;background-position: 0 0;&#125; 100% &#123;background-position: -100% 0;&#125;&#125;/**规则名称为flowLight，周期时间为3s，速度曲线为匀速，播放次数为无限次（永远）/animation: flowLight 3s linear infinite; 到此文字流光效果实现了 背景图模糊处理背景图模糊处理是设置filter: blur(3px);，CSS3的filter(滤镜) 属性主要是针对图片进行处理，比如黑白、对比和亮度等等。 1.box-warp:hover .box-img&#123; filter: blur(3px); &#125; 这样背景模糊的效果就实现了。 按钮边框的从中间到两边扩展开刚开始没什么思路，后来搜索才知道通过伪元素::before和::after可以实现这样的效果。思路是通过绝对定位设置前后伪元素来显示上下和左右边框，设置元素上下边框的伪元素left：50%，左右top：50%，通过改变其定位、宽度和高度来实现效果。 12345678910111213141516171819202122232425262728293031323334.box-background::before&#123; position: absolute; left: 50%; top:0; content: &apos;&apos;; border: 3px solid #ffcc00; border-width: 3px 0; width: 0; height: 100%; box-sizing: border-box; transition: all 1s; /*过渡*/&#125;.box-background::after&#123; position: absolute; left: 0; top:50%; content: &apos;&apos;; border: 2px solid #ffcc00; border-width: 0 2px; width: 100%; height: 0; box-sizing: border-box; transition: all 1s;&#125;.box-warp:hover .box-background::before&#123; left: 0; width: 100%; &#125;.box-warp:hover .box-background::after&#123; top: 0; height: 100%;&#125; 隐藏和显示隐藏和显示是通过设置opacity属性来实现,初始状态为0，鼠标滑动为1来实现。 1.box-warp:hover .box-background&#123; opacity: 1; &#125; 问题当我想鼠标移动到a元素上面时产生手指效果，但是却发现无效。通过排查是伪元素覆盖在a元素上面，导致根本无法接触。那么怎么能改变其它们的层叠关系呢？我想到了z-index属性，因为这个问题我重新学习了z-index属性的使用。 z-index什么时候有效? 对于一个已经定位的元素（即position属性值是非static的元素) z-index值越大元素越靠前，对吗？ 我们现在div(A)和div(B)中再分别创建一个小的div(c)和div(d) 我们试试把div(A)的Z-index设置成auto。 再试试只把div(a)设置为auto 其实主要是找到对比元素之间的基准堆叠上下文，以此数字越大层级越高。 取值： auto: 元素不会建立一个新的本地堆叠上下文。当前堆叠上下文中新生成的元素和父元素堆叠层级相同。 &lt;integer&gt;: 整型数字是生成的元素在当前堆叠上下文中的堆叠层级。元素同时会创建一个堆叠层级为0的本地堆叠上下文。这意味着子元素的 z-indexes 不与元素外的其余元素的 z-indexes 进行对比。 通俗说，设置auto时元素堆叠等级和父元素一样，遇到堆叠上下文之后根据大小来判断层级。设置具体数字的元素同样遇到堆叠上下文根据大小来判断层级，它的子元素和外界元素进行比较时,采用父元素的Z-index进行比较, 和兄弟元素比较采用自身的Z-index。 z-index 不设置和设置为0有什么区别? 如果不设置Z-index那么默认值为auto,则不建立层叠上下文。设置为0则会脱离文档流,建立层叠上下文。 由于CSS3的兼容性，在完成此效果时，只在webkit内核的浏览器进行测试，如需兼容其他浏览器，请自行加上浏览器前缀。 CSS3的许多新特效非常酷炫，可以实现非常复杂的效果和动画，值得大家好好看看。 参考链接 CSS3实现文字流光渐变动画 CSS3 教程 css元素position定位和z-index z-index]]></content>
      <categories>
        <category>IFE</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>IFE</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习放下]]></title>
    <url>%2F2017%2F05%2F26%2F%E5%AD%A6%E4%B9%A0%E6%94%BE%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[前言舍得，舍得，有舍才有得。 学习放下 我去过一个寺庙，无意发现寺庙的走道墙壁上写着清晰明了的四个大字：学习放下。 这几个字让我想起一个故事，故事大致内容是：一位学者找南隐禅师问禅，南隐禅师没有说话，只是拿起茶壶给学者的茶杯中倒茶。当茶杯里的茶水已经溢出来了，可是禅师还在倒着。 学者忍不住说，不要再倒了，茶已经溢出来了。南隐禅师说，你的心就像这杯子一样是满的，我怎么和你说禅呢？ 我们一直都在做加法，却很少去做减法。在大家的意识里，多一点总比少一点要好一些吧。可是什么东西都往心里放的话，那人活得有多累啊！学习放下，不要让自己的杯子总是满满的。 适当自己做一些减法，筛选出真正对自己有意义的东西，让自己保持对这个世界好奇和兴趣。认识世界和感受生活，让自己总是保持轻盈的状态去和这个世界或自己对话。当我们老的时候，希望自己的回忆里总是快乐大于悲伤，这样我们就能笑着离开了。 放下，是为了更好地前行。好与不好都走了，幸与不幸都过了。人生的际遇，一如窗外的雨，淋过，湿过，走了，远了。曾经的美好留于心底，曾经的悲伤置于脑后，不恋不恨。过去终是过去，那人，那事，那情，任你留恋，都是云烟。学会放下，人生总是从告别中走向明天。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭州游记]]></title>
    <url>%2F2017%2F05%2F22%2F%E6%9D%AD%E5%B7%9E%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言欲把西湖比西子，淡妆浓抹总相宜。 其实现在回想起来，其实不知道自己怎么就决定来杭州？我真的不知道，好像就是一个突然的想法，然后大致计划了一下。没什么重要的理由，有时候真的好像不需要理由吧，理由这东西更多的时候是给自己一个安慰和借口罢了。 第一天为了赶早上8点多的火车，我6点就起来收拾行李。其实就一个背包而已，重量还不到5斤左右，所以早早就出发了。 北京6点多的地铁人还是挺多的，虽然难得有座位，但是想到火车上又要坐那么久，所以就没有坐。赶车总是无聊的，闲没事看看周围事物打发一下时间，可能大家都起得早，所以普遍都是睡眠不足。只见有的人向后靠背，仰面朝天张大了嘴，看起来实在滑稽可笑。 由于距离发车还有一段时间，所以就自顾找了个地方吃早饭，稀里糊涂点不怎么喜欢的美式咖啡和三明治，果然没吃完。看来我是和文艺气息浓郁的咖啡注定无缘了。 火车晚了20分钟才到达杭州东站，虽然杭州也是和北京差不多的热，但是有所不同的是多了些湿热。 至此，我是真的到杭州了。我的杭州之游算是开始了。 杭州图书馆 我去到每个地方，都会特别想看看当地的图书馆，我是觉得图书馆能够一定反映这个地方文化和历史，另外我喜欢图书馆的安静，走走看看你的心自然而然静下来。当然图书馆自身就是设计出众的建筑艺术，也是值得看看的。如果你来杭州又喜欢安静的地方，我会推荐你去杭州图书馆，而且一楼的面包店很不错哦，特别是蛋挞！ 京杭运河 心满意足的欣赏杭州图书馆后，出发下一个地点：京杭运河。从武林门码头坐水上巴士去拱宸桥，可以沿途看运河的夜景。确实很漂亮，下船沿着河边散步，感受一下江南水乡的模样。一路上有很多咖啡馆、工艺品店和一些博物馆。在江南水乡由于水路众多，所以船是一种重要的交通工具，虽然杭州已经是交通现代化的城市，但是水上交通依旧还是生生不息。 龙翔桥商圈这个时候天已经黑了，肚子不争气叫唤起来。得找个地方吃东西，推荐骑个单车大致沿着运河南下，如果你喜欢时尚、购物和逛街之类，推荐杭州最繁华的龙翔桥商圈，银泰在附近，基本都是一些奢侈品商店。另外亚洲最大的苹果直营店也是在那里而且就在西湖边上。 其实西湖晚上人还是挺多的，毕竟晚上比白天凉快一些。很多本地人和游客都会选择夜游西湖，我从西湖北面的白堤出发，由于是晚上11点左右了，所以只是走完了白堤就回旅馆了。 西湖白天和晚上完全是不一样的景色，晚上西湖是另外一种美丽。 第二天环游西湖 由于昨天晚上并没有欣赏到西湖全景，所以决定早点起来去环游西湖。骑着单车迎面吹来微凉的风的同时还可以一路观赏西湖的美景，真是安逸惨了。我是从北山路的白堤出发，然后回到起点，环游西湖一圈。白堤早上那会会有许多大爷放风筝，白堤过去后就是孤山，孤山上有当初乾隆皇帝为六下江南而设立的行宫，而后就是苏堤。 其实很可惜，我也是第一次去西湖，后来才发现西湖一路上的博物馆、名人故居、公园、寺庙，名人墓地和好山好水等等太多了。我所见到的不过是冰山的一角而已。如果大家时间够多，建议一路慢慢浏览，时间比较紧的话，可以挑选自己比较喜欢的地方。 浙江美术馆 走过苏堤后，来到南山路你就会看见人突然多了起来，因为来到了雷峰塔景区。一走进景区大门，假石头伪装的音响不断响起熟悉的旋律：“千年等一回等一回啊~ 千年等一回我无悔啊~ ”，不过我还是喜欢《渡情》，就是那个：“西湖美景三月天哪，春雨如酒柳如烟哪”。 由于我不是很感冒加上人太多了，我就在外面看看了雷峰塔，雷峰塔现在是多次修复而成的，听说里面很现代化，所以反而失去古塔的韵味。人们多少都是因为《新白娘子传奇》而熟知雷峰塔。而我直接去了我特别期待的 浙江美术馆。 自己运气还不错，刚好正在展览刘墉老师的书画，展览主题是 书卷江山，虽然我看不懂，不过确实很好看啊，中国的山水画拥有特殊的想象力。 西湖博物馆 浏览完了美术馆后，来到西湖博物馆。既然来到西湖，我们应该知道西湖的历史发展，而西湖博物馆将全面介绍西湖历史来源发展，让自己对西湖有更深的认识。建议大家来到西湖，都应该去参观一下西湖博物馆。 六合塔 之所以没去雷峰塔，是因为我发现 六合塔，相对雷峰塔的声名远播，六合塔估计很多人都不知道，但是确实值得一看，它位于钱塘江边，你可以登上塔顶位置俯瞰钱塘江美景。 六和塔位于西湖之南，钱塘江畔月轮山上。北宋开宝三年(公元970年)，当时杭州为吴越国国都，吴越王为镇住钱塘江潮水，派僧人智元禅师建造了六和塔，现在的六和塔塔身重建于南宋。取佛教“六和敬”之义，命名为六和塔。六和塔又名六合塔，取“天地四方”之意。 浙江大学（之江校区） 浙江大学之江校区前身是之江学院，如今是浙江大学光华法学院校舍。整个校园沿着钱塘江边的之江路依山而建，有保存相当完整的近代大学建筑群，被称为“杭州最美的大学校园”。这里游客很少，是拍照散心的好去处。 **它绝对能进中国最美大学前十，有保存相当完整的近代大学建筑群，获“世界近代学府建筑完整保护建筑”第二名。 这是一座建在山中的学校，依山傍水，景致优美，这里哪是大学，分明是山中的秘境公园。** 音乐喷泉 打字好累啊，之后大哥我一人骑了10公里回到起点，来看西湖边上的音乐喷泉，结果人超级多，还得安检进去。7点和8点各有2场，每次15分钟，大概3首歌左右。如果你想获得观看的最佳视野，你得提前2个小时来才行哦。 晚上手机拍不好，我盗图给你看看吧 宝石山 在西湖边上的北山路有座宝石山，推荐晚上爬山去看西湖夜景，包你满意。喜欢图书的爬山你会路过一个叫纯真年代的书店，值得一看。最重要的是人都超级少，不会有人打扰你安安静静的欣赏西湖的美丽。 手机拍得太烂了，实在是体现不出西湖夜晚的美，我又盗图了。。。 结尾到此我的杭州之旅结束了，我一次冲动的决定，冲动的出发，但是好像没有冲动的惩罚，反而结局还是不错的。有时目的性太强的旅行会失去旅行的意义。 我去旅行，是因为我决定了要去，并不是因为对风景的兴趣。– 加西亚-马尔克斯]]></content>
      <categories>
        <category>随笔</category>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂文</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASCII，Unicode和UTF-8 (Charset and Encoding)]]></title>
    <url>%2F2017%2F05%2F19%2FASCII%EF%BC%8CUnicode%E5%92%8CUTF-8-Charset-and-Encoding%2F</url>
    <content type="text"><![CDATA[前言：相信很多人都听说过ASCII，Unicode和UTF-8这些词汇，但可能还是不清楚其中的具体含义。当然一开始我也是粗略认识，所以自己决定重新深入学习一下，并且总结如下。 才疏学浅，多多指教！！！ 一、历史渊源关于历史来源，在此引用前人的总结，写的很清晰明了。自己截取其中主要部分并且加以修饰一下，正文如下： 很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们看到8个开关状态是好的，每个于是他们把这称为”字节“。再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为”计算机“。这就是计算机来源，每个晶体管只有0和1两个状态。现在计算机，8位二进制通常被称为一个字节，这是计算机最小存储单位。 计算机是美国人发明的。八位二进制一共可以组合出256(2的8次方)种不同的状态。 他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作。遇上0×10, 终端就换行，遇上0×07, 终端就向人们嘟嘟叫，例好遇上0x1b, 打印机就打印反白的字，或者终端就用彩色显示字母。他们看到这样很好，于是就把这些0×20以下的字节状态称为控制码。他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做 ANSI 的Ascii编码 （American Standard Code for Information Interchange，美国信息互换标准代码） 当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。 世界各地的都开始使用计算机，但是很多国家用的不是英文，他们的字母里有许多是ASCII里没有的，为了可以在计算机保存他们的文字，他们决定采用127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128到255这一页的字符集被称扩展字符集。 等到中国人民使用计算机后，发现没有中文怎么办呢？中国人的解决方案是：小于127号的还是继续使用，并且用2个大于127的字节表示一个中文字符，前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的 全角 字符，而原来在127号以下的那些就叫 半角 字符了。 中国人民看到这样很不错，于是就把这种汉字方案叫做 “GB2312“。GB2312 是对 ASCII 的中文扩展。 但是中文还是不够用，大家发现冷门生僻字和繁体字等等还是无法识别。于是就只是要求高字节大于127就认为是2字节的中文字符，这样结果扩展之后的编码方案被称为 GBK 标准，GBK包括了GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。但是还有少数民族同胞也需要使用电脑，于是有扩展少数民族字符，这样GBK扩成了 GB18030,从此之后，中华民族的文化就可以在计算机时代中传承了。 中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 DBCS（Double Byte Charecter Set 双字节字符集）。 但是每个国家都搞一套自己的字符编码，自己只能看自己，别人的看不来，这不符合web开放的文化啊。 正在这时一个叫 ISO（国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称 UCS, 俗称 Unicode。但是后来扩展标准，2或者4字节来表示字符编码。 Unicode开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用 两个字节 ，也就是16位来统一表示所有的字符，对于ASCII里的那些“半角”字符，unicode包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于”半角”英文符号只需要用到低8位，所以其高8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。 Unicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。目前最新Unicode标准分为17组编排，0x0000 至 0xFFFF，每组称为平面（Plane），而每平面拥有65536个码位，共1114112（65536*17）个。 但是Unicode同样也有2个问题 一、计算机怎么知道二个字节为一个字符，如何识别二个字节为什么一个字符？ 二、针对英文字符，如果使用大于1个字节来表示，那么低位的前面几个字节全是0。很奢侈浪费空间，因为现在计算机大部分内容还是英文。 二、Charset and Encoding大家了解一下历史后，应该对字符集有大致了解，那我们来说说字符集和字符编码，其实你可以这样理解： 字符集就是我们用十进制来表示世界上各种字符 字符编码就是通将十进制转换为计算机识别的二进制编码的规则 Charset (Character set) 字符集： 是对字符抽象表示的集合。包括世界上各种文字、符合和字符。 Encoding (Charset Encoding) 字符编码：建立字符集合和计算机系统对应的规则。简单来说就是，将字符转化为计算机可识别的二进制编码的规则。 三、ASCII计算机使用二进制保存指令和数据，字节作为计算接处理数据的基本单位，有256(2的8次方)种可能状态。这些状态被人们利用来标记指令和文字。最初前32(0x20)种状态被用来表示终端、打印机等设备的某些特殊动作，比如终端遇到字节0x10则换行，类似的还有回车(CR 0x0D)，震铃(BELL 0x07)等。这前32种状态又被称为控制码。除了这些特殊用途的状态外，还有256-32=224种状态没有被利用，资源浪费怎么能忍，何况除了控制指令外，咱们的文字还没有被表示。于是这些多出来的状态被用来表示文字(English Character)和符号标点等，如此这般，计算机就可以显示和记录文字了，这便是ASCII(American Standard Code for Information Interchange)最初的由来。 四、UnicodeUnicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准,包括字符集、编码方案等。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。 在表示一个Unicode的字符时，通常会用“U+”然后紧接着一组十六进制的数字来表示这一个字符。在基本多文种平面（英文为 Basic Multilingual Plane，简写 BMP。它又简称为“零号平面”, plane 0）里的所有字符，要用四位十六进制数（例如U+4AE0，共支持六万多个字符）；在零号平面以外的字符则需要使用五位或六位十六进制数了。Unicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。目前的Unicode字符分为17组编排，0x0000 至 0xFFFF，每组称为平面（Plane），而每平面拥有65536个码位，共1114112个。然而目前只用了少数平面。UTF-8、UTF-16、UTF-32都是将数字转换到程序数据的编码方案。 通用字符集（Universal Character Set, UCS）是由ISO制定的ISO 10646（或称ISO/IEC 10646）标准所定义的标准字符集。UCS-2用两个字节编码，UCS-4用4个字节编码。 UCS-4根据最高位为0的最高字节分成27=128个group。每个group再根据次高字节分为256个平面（plane）。每个平面根据第3个字节分为256行 （row），每行有256个码位（cell）。group 0的平面0被称作BMP（Basic Multilingual Plane）。如果UCS-4的前两个字节为全零，那么将UCS-4的BMP去掉前面的两个零字节就得到了UCS-2。每个平面有216=65536个码位。Unicode计划使用了17个平面，一共有17×65536=1114112个码位。 UTF(Unicode Transformation Format), Unicode字符集的编码方式，主要有UTF-8，UTF-16，UTF-32等。由于UTF-32采用定长四字节编码，这里不多说，下面主要介绍UTF-8，附带介绍UTF-16。 UTF-8UTF-8是变长编码，使用1~4个字节来表示一个字符，UTF-8的特点是对不同范围的字符使用不同长度的编码。 单字节表示对应Unicode码点0x0000-0x007F的字符，且此时首位为0，有效位7位，也就是说可以表示27=128种字符，这部分其实刚好兼容了ASCII编码规则，而Unicode0x0000-0x007F的字符也就是ASCII字符。 双字节表示对应Unicode码点0x0080-0x07FF的字符，且此时第一个字节以110开头，后面的字节以10开头，有效 位数为11位，可以表示2048种字符。其实由上图可以看到UTF-8变长编码的规律，为了让计算机知道以几个字节来断句（即翻译为一个字符），在首字节的前几位就有几个1，例如如果是双字节断句，则首字节开头以110，如果是三字节断句，则首字节以1110开头。 三字节表示对应Unicode码点0x0800-0xFFFF的字符，有效位为16位，可以容纳65536种字符，我们常用的中文字符也都落在三字节部分。因此UTF-8是以三个字节来表示常用汉字字符的，当然实际上汉字有将近十万个，65536无法容纳如此庞大的汉字体系，因此有些冷门汉字只能用四字节表示了。我们知道Unicode将人们常用的字符都放在BMP平面（U+0000-U+FFFF），而至此，UTF-8已经用1-3个字节表示了BMP平面的全部内容。 例1：“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将0x6C49写成二进制是：0110 1100 0100 1001， 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。 UTF-16UTF-16是以二字节或四字节表示一个字符的变长编码。Unicode在BMP平面的字符（U+0000~U+FFFF）用二字节来编码，其余字符用四字节来编码。对于二字节编码部分直接用码点值来编码，四字节编码部分的转换规则这里不再详述。我们只需记住常用的中英文字符在UTF-16中使用二字节表示即可。 乱码编码方式不兼容会导致乱码。例如，编码A和编码B采用不同方式来编码，当一个文件使用编码A在只有编码B的设备上解码时候，肯定是乱码，因为不识别啊。打个比方，战争中谍报的密码本，每次传递情报需要使用不的密码本来解密，但是你用错了，当然翻译的内容是错的，读起来肯定不通顺。 文笔有限，才疏学浅，文中若有不对之处，还望告知。 参考链接 Charset and Encoding Java字符的编码解码与乱码问题 Unicode 和 UTF-8 有何区别？]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[地下通道]]></title>
    <url>%2F2017%2F05%2F16%2F%E5%9C%B0%E4%B8%8B%E9%80%9A%E9%81%93%2F</url>
    <content type="text"><![CDATA[前言： 地下通道中一束光照射在路人身上，如同地狱中的希望之光。-《地狱》 地下通道这个地下通道其实很普通，它不过是这个城市渺小的一部分。但是我每天下班回家都会穿过这里到对面街道上去，所以对他格外熟悉一些。 每次走近通道向下阶梯的时候，人们的脚步声会变得清晰起来，熙熙攘攘的脚步声再次提醒我这是下班时间。不知道为什么，下班的时间里不管是年轻人还是人到中年的大叔和阿姨，大家都喜欢戴上耳机，不过有的人喜欢把放音乐的手机拿在手里、有的喜欢放在裤子前面的裤兜而女士一般都是放在包里，好像戴上耳机后可以短暂隔离这个世界，从而获得自己的空间和时间。 当然可能并且没那么复杂，可能只是简单的想通过音乐来消去一天的疲惫而已。其次还有一个现象比较奇特，就是不管男女老幼背书包比例比较大。小朋友书包里的课本和作业，对于大部分的小朋友来说都不感冒，我们童年的回忆里，没人会说作业和课本是美好的记忆吧。但是大人背包里的东西可能对他们的工作和生活都很重要，对他们而言没有讨厌、排斥的说法。 最后还有一个现象就是大家下班回家的步伐都是那么匆匆，有句话是这么说：“这个城市发展的速度，从人们走路的步伐就能看出来”。嗯，北京发展的节奏看来还是很迅速的。 我总想放慢自己步伐缓慢的回到家，但是每次穿过这个地下通道，当身边的人们行色匆匆的时候，我总会下意识的身子前倾、加快步伐而且用手把耳机塞得更紧一些了。]]></content>
      <categories>
        <category>随笔</category>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂文</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发者关系大会的思考]]></title>
    <url>%2F2017%2F05%2F14%2F%E5%BC%80%E5%8F%91%E8%80%85%E5%85%B3%E7%B3%BB%E5%A4%A7%E4%BC%9A%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[参会经历说来惭愧，5月6日参加的大会，到现在才想起写一些东西。不过没关系，不要在意细节问题。。。我是通过FCC的微信公众号了解到这次活动，看了演讲的嘉宾的基本介绍，个人很是期待。感受一下高质量的技术交流，虽然我全程划水。。。 会议的举办给人严谨和有序的感觉，我第一次参加这样的IT活动，还是有些激动的。给活动组织者们点个赞，特别说明活动的下午茶真的特别赞，不要误会，我去之前不知道有下午茶而且这么丰富，我是抱着学习的态度去的，真的。 布道师的疑惑 七牛云首席布道师何李石老师提到“布道师”这个词汇，应该是我孤陋寡闻，我是第一次听到这个词，当时听老师演讲时候不是很明白到底是什么含义，回来之后自己大致了解了一下。 百度百科的解释：“技术布道是随着IT产业的兴起而兴起的职业。与传统的“宣传推广”不同，它是针对特殊产品、面向特殊人群、采用特殊方法进行“宣传推广”，百度百科解释还是一如既往的深刻晦涩。 布道这个词最早来源宗教，为了推广教义和宗教信仰，信徒们到处传播和推广，而他们就是扮演着布道师的角色。 什么是布道师？我觉得可以简单理解为“技术的传播者”。那这个职业存在的意义是什么呢？后来看过腾讯云的布道师贺嘉老师的文章，他的解释让我更加理解这个问题的答案。 布道师的价值在于消解技术复杂度，降低用户认知成本 如果你在公司内外部尝试推进react或是node.js这样的新技术，内外部的其他技术人员可能会这样回答你：“用了有啥好处？”、“你的技术能解决问题么？”、“不愿意换，现在的技术挺好的”。那么布道师就要去解答这些困惑并且让大家感受到新技术的魅力。 寄望人工智能(AI) CSDN创始人蒋涛老师演讲内容关于AI，最近几年时间里人工智能非常活跃，特别是IT巨头Google有意识推广人工智能概念。一场围棋比赛，把全世界的目光一下子吸引到“人工智能”这个热点上面，AlphaGo（阿尔法）战胜人类的消息，让大家吃惊不已。 并且5月23日，谷歌人工智能DeepMind的急先锋AlphaGo2.0，将披挂上阵，与人类最强棋手——柯洁，展开三番棋的较量。我有点替柯洁担心啊。 其实关于人工智能的想法很早之前就存在，并且那个时候就已经表达了对人工智能的担忧，人工智能到底对人类是敌是友？大家应该特别熟悉机器人三定律。1942年，阿西莫夫在短篇小说”Runaround”（《环舞》）中首次提出了三定律： 一 机器人不得伤害人类，或因不作为使人类受到伤害。 二 除非违背第一定律，机器人必须服从人类的命令。 三 除非违背第一及第二定律，机器人必须保护自己。 那个时候更多是对人工智能的担忧，认为它会对人类社会发展造成破坏。大家应该还记得电影 《终结者》 系列机器人破坏人类文明，《黑客帝国》 系列人类被智能控制而苟活，它从侧面再次反映人们对人工智能技术的担心甚至是反对。 而为什么今天反对的声音越来越弱呢？我想科技发展给人们带来实际有效的便捷，说白了就是尝到了甜头。我对人工智能是持开放的态度，科技发展必定是服务人类社会，它是社会发展的重要推动力。 当然，发展的过程中同样有许多问题产生，例如科技让人类缺乏真实的社交和沟通，网络世界让许多人沉沦，科技发展让人慢慢失去了人类的本性。我想说的是，我们应该包容，新生事物的发展必然会产生一系列的问题，但我们不应该全盘否定，合理分析控制让人工智能成为推动人类社会发展的新动力来源。 现在很多互联网公司都把 人工智能 当做下一个科技发展的浪潮，让我们一起期待寄望那个时代的到来吧！ 图片大部分来源：猿生态开发者社区，侵删。]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汶川大地震9周年忆]]></title>
    <url>%2F2017%2F05%2F12%2F%E6%B1%B6%E5%B7%9D%E5%A4%A7%E5%9C%B0%E9%9C%879%E5%91%A8%E5%B9%B4%E5%BF%86%2F</url>
    <content type="text"><![CDATA[前言 都说傻瓜最快乐，因为傻瓜什么事情都不会放在心上。 可能很多人都忘记9年前的今天一场大地震突然降临在四川，短短几分钟夺取几万人的生命。汶川大地震已经过去9年了，但它不能被遗忘，也不应该被遗忘。 那个下午我中午偶然看见一位四川老乡的朋友圈，当我看见汶川二字时，我急忙看看今天的日期。5月12日，汶川大地震都过去9年了啊，但是当我看见汶川二字的时候，时间一下子把我拉回2008年5月12日-14时28分那个时刻。 那一年到现在我都记得特别清楚，初中我在教室睡午觉，突然感觉桌子在晃动，一开始只是轻微的，我以为是前面同学在捣乱，但是后面越来越剧烈，看见水杯里的水急剧震荡，大家才发现不对劲。在此，我想特别向我初中历史老师致敬，她指挥大家有序跑出教室，最后自己才跑到空旷的地带。在生命的危急关头，老师她把学生放在第一位，只是但是大家被吓傻了，跑下来才知道老师还在里面，想回去找她时被其他老师拉住，最后看见老师她安全下来，班上很多女同学都哭了。 很可惜，我不记得老师的名字了，很惭愧。但是我9年后还记得你当初勇敢的为保护学生而做出的无私行为，在那一刻你是英雄和伟人。 后来恢复上课，大家商量历史老师来上课，大家全体起立向老师鞠个躬。我还是记得很清楚，老师哽咽了一会，眼泪不断留下，强忍住自己的眼泪对大家说了一声“谢谢”，当然大家都哭个不停。那个时候，才发现原来老师和学生是可以走到对方的心里的。那一年应该是我哭的最多的时候，实在是忍不住啊。 生命可贵这场灾难让我觉得生命真是伟大又可贵。地震带给人不单是痛苦，其实还有很多感动。我记得当时余秋雨老师说过，在那个时候他看见了中华民族的伟大。全国人们乃至全世界的华人几乎疯狂失去理性的募捐，在那一刻真是验证余老师所说。 灾难总是让人性体现得无比清楚，大地震让我看见了作为一个人的善良本性和一个生命的价值。背着亡妻的丈夫、抱着孩子尸体的父亲、选择救儿子放弃女儿的母亲和保护学生失去生命的老师等等。是他们用生命让我们明白作做人的基本本性和生命的价值的追求。 所以现在活着的人们应该珍惜自己的生命，因为生命太可贵了，这是用其他东西根本换不了。我们应该好好把握自己的生命，去追求和实现自己的生命的价值。 希望活着的人带着逝去的人的那份悲伤和幸福一起前进。]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的this的值到底是什么？]]></title>
    <url>%2F2017%2F04%2F29%2FJavaScript%E7%9A%84this-%E7%9A%84%E5%80%BC%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[前言JavaScript 有一套完全不同于其它语言的对 this 的处理机制。 一般有四种不同的情况下 ，this 指向的各不相同。但是有一个总的原则，那就是this指的是，调用函数的那个对象。 一、函数调用函数调用时，this指向全局对象，如果是在浏览器中中，这个对象是window。 请看下面这段代码： 12345678var fn = function() &#123; function test() &#123; console.log(this); // this 将会被设置为全局对象（译者注：浏览器环境中也就是 window 对象） &#125; test();&#125;fn() //执行函数fn，结果指向window 二、方法调用当函数作为对象的方法时，this指向该对象 请看下面这段代码： 123456789var age = 10;var xiaoming = &#123;&#125;;xiaoming.age = 18;xiaoming.getAge = function()&#123; console.log(this.age);&#125;xiaoming.getAge(); //18 之所以为18不是10，因为this指向xiaoming这个对象，所以打印出来是18 三、调用构造函数如果函数倾向于和 new 关键词一块使用，则我们称这个函数是 构造函数。 在函数内部，this 指向新创建的对象。 请看下面这段代码： 123456789var x = 0;function test()&#123; this.x = 1;&#125;var obj = new test();console.log(obj.x); // 1 打印出来为1不为0，表明this指向新对象obj，而不是全局对象。 四、显式的设置 this (apply和call)当使用 Function.prototype 上的 call 或者 apply 方法时，函数内的 this 将会被 显式设置为函数调用的第一个参数. 当第一参数为null 或者 undefined，在浏览器环境里那么window对象就是默认的this指向。123456789101112131415var age = 0;var xiaoming = &#123;&#125;;function setAge(age)&#123;this.age = age;&#125;xiaoming.age = 18;xiaoming.setAge = setAge;xiaoming.setAge.apply(null,[20]);xiaoming.age // 18age // 20xiaoming.setAge.call(xiaoming,25);xiaoming.age // 25age // 20 apply和call区别在于传递参数格式不同，call()接受一个参数列表，而apply()接受包含多个参数的数组（或类数组对象） 文笔有限，才疏学浅，文中若有不对之处，还望告知。 参考文章 this 的工作原理 this 的值到底是什么？一次说清楚 Javascript的this用法 Function.prototype.apply()]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说说Javascript原型链]]></title>
    <url>%2F2017%2F04%2F24%2F%E8%AF%B4%E8%AF%B4Javascript%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[前言在写复杂的 JavaScript 应用之前，充分理解原型链继承的工作方式是每个 JavaScript 程序员必修的功课。 JavaScript中并没有类（class）；Js是基于原型（prototype-based）来实现的面向对象（OOP）的编程范式的，但并不是所有的对象都拥有prototype这一属性 123456789var a = &#123;&#125;,b = 'shi';var fn = function()&#123;&#125;;a.prototype // undefinedb.prototype // undefinedfn.prototype // Object &#123;constructor: function&#125; prototype属性只有 function对象定义时才有，函数本身也是对象。想要明白原型问题我们先明白几个基本概念。 一、function、Function、Object和{} function是JavaScript的关键字，用于定义函数变量，一般有2种定义方式 123456789function f1()&#123; console.log('This is function f1!');&#125;typeof(f1); //=&gt; 'function'var f2 = function()&#123; console.log('This is function f2!');&#125;typeof(f2); //=&gt; 'function' Function是函数类型实例的构造函数（constructor）, 本质也是函数，类似还有Object或String、Number等，都是Js内置类型实例的构造函数，构造函数主要作用就是创建相应类型的实例，实现原型链。 12345var f3 = new Function("console.log('This is function f3!');"); f3(); //=&gt; 'This is function f3!' typeof(f3); //=&gt; 'function'typeof(Function); //=&gt; 'function' Object，它用于生成对象类型，其简写形式为{}，其实和function和Function的关系类似。 1234567var o1 = new Object(); typeof(o1); //=&gt; 'object'var o2 = &#123;&#125;; typeof(o2); //=&gt; 'object'typeof(Object); //=&gt; 'function' 二、prototype 和 __proto__prototype属性只有函数类型对象才有，上面说的很清楚了。而__proto__是所有JavaScript对象都内置的属性[[Prototype]]，而这个属性指向构造函数（类似父类）的prototype属性，从而继承属性. 通俗一点讲，prototype中定义的属性和方法都是留给自己的“后代”用的，因此，子类完全可以访问prototype中的属性和方法。 举个例子： 123456789101112var Person = function()&#123;&#125;; Person.prototype.type = 'Person'; Person.prototype.maxAge = 100;var p = new Person(); console.log(p.maxAge); p.name = 'rainy';// 修正Person.prototype.constructor为Person本身Person.prototype.constructor === Person; //=&gt; true p.__proto__ === Person.prototype; //=&gt; true console.log(p.prototype); //=&gt; undefined 一图胜千言 Person是一个函数类型的变量，因此自带了prototype属性，prototype属性中的constructor又指向Person本身；通过new关键字生成的Person类的实例p1，通过__proto__属性指向了Person的原型。 注意：遵循ECMAScript标准，someObject.[[Prototype]] 符号是用于指派 someObject 的原型。这个等同于 JavaScript 的 __proto__ 属性。从 ECMAScript 6 开始, [[Prototype]] 可以用Object.getPrototypeOf()和Object.setPrototypeOf()访问器来访问。 三、原型链原型链是基于 __proto__ 的。JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依此层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。 举例说明： 1234567891011121314151617// Nodevar Obj = function()&#123;&#125;; var o = new Obj(); o.__proto__ === Obj.prototype; //=&gt; true o.__proto__.constructor === Obj; //=&gt; trueObj.__proto__ === Function.prototype; //=&gt; true Obj.__proto__.constructor === Function; //=&gt; trueFunction.__proto__ === Function.prototype; //=&gt; true Object.__proto__ === Object.prototype; //=&gt; false Object.__proto__ === Function.prototype; //=&gt; trueFunction.__proto__.constructor === Function;//=&gt; true Function.__proto__.__proto__; //=&gt; &#123;&#125; Function.__proto__.__proto__ === o.__proto__.__proto__; //=&gt; true o.__proto__.__proto__.__proto__ === null; //=&gt; true 来张图更直观一些 到了这里，其实有个问题大家没注意，new关键词到底起了什么作用呢？ 其实开头的图已经给出答案：new关键词的作用就是完成上图所示实例与父类原型之间关系的串接，并创建一个新的对象.简单来说，new就是把父类的prototype赋值给实例的__proto__ 有兴趣深入看这里：JS 的 new 到底是干什么的？ 文笔有限，才疏学浅，文中若有不对之处，还望告知。 参考文章 继承与原型链 原型 图解Javascript原型链 关于js中,原型对象，原型链，构造函数，实例之间关系的理解与区别]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《一念无明》的感触]]></title>
    <url>%2F2017%2F04%2F16%2F%E3%80%8A%E4%B8%80%E5%BF%B5%E6%97%A0%E6%98%8E%E3%80%8B%2F</url>
    <content type="text"><![CDATA[一念无明，如坠地狱；众生皆苦，万念皆空。 其实每个人都有病，只是你自己不觉得而已！ 关于电影名“一念”来自佛家的说法，是指人不断产生的念想，“无明”是看不见，看不清楚。人们的想法最终导致人性的迷失，从而不断的产生矛盾和伤害。 对于这个电影名，导演自己之所以选择用“一念无明”作为片名，是希望以此呈现片中人物之间的状态：“他们都是爱对方的，他们都不是外人，电影里面我自己觉得没有外人”，但正是这样的一群人，因为无法看清自己，看清他人，看清人生，最终却在不停地互相伤害，“他们互相伤害的时候就是‘无明’的，看不清楚他真的要做什么。” 电影最后字幕用《小王子》的一句话来提醒观众: “只有用心才能看得清楚，真正重要的东西，用眼睛是看不见的”。 因果循环佛家一般讲究 “天地万物，因果循环”，一切有始有终。 母亲把失败婚姻和悲剧人生的怨念，无情地抱怨发泄在身边唯一亲人并且照顾自己的阿东的身上。父亲的逃避、母亲抱怨最终让阿东躁郁症的爆发并且让自己未婚妻的人生陷入谷底。阿东出院后，本来想和未婚妻和好如初，但是未婚妻的愤怒和仇恨让阿东再次病发。照顾发病的阿东，让父亲身心憔悴，父亲此时终于尝到当初自己对亲人的伤害的滋味。自己身边最亲近的人就这样互相伤害，让其中每个人都陷入无尽的伤痛。 从阿东的家庭来看，其实具有普遍性。基本每个人都能从这个家庭找到自己的影子，因为你也是父亲，母亲或者是父母的儿女。 阿东的父母应该是比较极端的，阿东从小几乎没有父母的爱和呵护，这个家对他而言似乎无关，家庭的冷漠导致阿东的人格缺陷。但是这样类似的悲剧在中国的家庭都曾经上演过，可能是中国儒家文化的根深蒂固，中国的父母缺乏和孩子的交流，一句“我是为你好”就可以完美的表达父母对孩子的爱，但问题是孩子自己接受吗、快乐吗、同意吗？这就是问题所在，父母认为我是为孩子着想，但是结局往往都是悲剧。 那些离家出走、跳楼自杀和绝望痛哭的孩子，社会对这些孩子的评价总结起来基本都是没出息，从来没有人去质问父母的问题，把问题产生的原因归结于孩子的身上。 人性的一面人和动物最大的区别，应该是人有着丰富的感情。 从社会角度去看，电影描述一个近乎“吃人”的香港社会，随着城市的高速、现代的发展，人这个物种似乎慢慢失去了情感，甚至变得麻木。孤独是现在描述“空巢青年”用得最多的词汇，因为城市的现实社会给人孤独感，陌生感和冷漠感。 科技进步和城市的发展带给人们物质的提升和享受，但是同时也改变了人的本质，我们失去了作为一个生命的价值，似乎作为一个人的价值慢慢从生命里流逝。 网络时代，大家把自己情绪和感情投入在虚拟的世界里，导致现实世界人性的缺失。都是去虚拟的世界学做人，反而在真实的世界忘记自己是人了。 问问自己，你有多久没有和你最亲近的人面对面的交流了呢？ “那时，我还没弄懂人性是如何矛盾，我不知道真诚中有多少做作，高贵中有多少卑鄙，或者，邪恶中有多少善良。”“如今我是充分懂得了，小气与大方、怨怼与仁慈、憎恨与热爱，是可以并存于同一颗心中的”－－《月亮与六便士》]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识JavaScript闭包]]></title>
    <url>%2F2017%2F04%2F02%2F%E5%88%9D%E8%AF%86JavaScript%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[前言：学习JavaScript的时候老是听说闭包，感觉他很厉害的样子，所以就来会会他吧！ 闭包是什么？闭包是指有权访问另外一个函数作用域里的变量和参数的函数 闭包的特点以及优缺点特点 函数嵌套函数 函数内部可以引用外部的参数和变量 参数和变量不会被垃圾回收机制回收 一般函数执行结束后，局部变量会被销毁（垃圾回收机制所回收），内存只会保存全局作用域的变量。 但是闭包就不同了，闭包会使变量继续保存在内存里，当然如果使用不当会增大内存使用量。 12345678910function aaa() &#123; var a = 1; return function()&#123; alert(a++) &#125;; &#125; var fun = aaa(); fun();// 1 执行后 a++，，然后a还在~ fun();// 2 fun = null;//a被回收！！ 优点 希望一个变量长期驻扎在内存中 避免全局变量的污染 私有成员的存在 缺点 闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。 循环中的闭包一个常见错误是在循环中使用变量，我们看个例子： 1234567891011121314function count() &#123; var arr = []; for (var i=1; i&lt;=3; i++) &#123; arr.push(function () &#123; return i * i; &#125;); &#125; return arr;&#125;var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2]; 你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是: 123f1(); // 16f2(); // 16f3(); // 16 原因很简单，当你执行返回的函数时，闭包继续保持对变量i的访问，此时for循环已经结束并且i = 4,所以结果都是16。 为了得到想要的结果，需要在每次循环中创建变量 i 的拷贝。为此我们一般采用自执行匿名函数 1234567891011121314151617181920function count() &#123; var arr = []; for (var i=1; i&lt;=3; i++) &#123; arr.push((function (n) &#123; return function () &#123; return n * n; &#125; &#125;)(i)); &#125; return arr;&#125;var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2];f1(); // 1f2(); // 4f3(); // 9 自执行匿名函数 创建一个自执行匿名函数123456(function (x) &#123; return x * x;&#125;)(3); // 9//另外一种写法(function (x) &#123; return x * x &#125;) (3); 总结很多初学者学了闭包后，可能也不懂到底在哪里才有用到，甚至不懂闭包到底有啥用。其实你写的每一个js函数都是闭包，一个js函数的顶层作用域就是window对象，js的执行环境本身就是一个scope（浏览器的window/node的global），我们通常称之为全局作用域。每个函数，不论多深，都可以认为是全局scope的子作用域，可以理解为闭包。 闭包的概念其实是针对作用域而言的，闭包的当前作用域总是能够访问外部作用域中的变量，因为 函数 是 JavaScript 中唯一拥有自身作用域的结构，因此闭包的创建依赖于函数。 文笔有限，才疏学浅，文中若有不对之处，还望告知。 参考文章 详解js闭包 JavaScript 秘密花园 廖雪峰JavaScript教程-闭包]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《秋菊打官司》观后感]]></title>
    <url>%2F2017%2F03%2F29%2F%E3%80%8A%E7%A7%8B%E8%8F%8A%E6%89%93%E5%AE%98%E5%8F%B8%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[前言：在中国社会里，到底是情大于法，还是法大于情呢？ &#8194;&#8194;从影片最后的结尾来看，秋菊对这个结果是无奈的。她只是想要个说法，这个说法是基于情理上。但是迫于无奈她采取告状的方式，最后法律制度是给了秋菊一个明确的说法，但是从秋菊失望的脸上很明显告诉观众这不是她要的“说法”。 &#8194;&#8194;中国人普遍的意识里是大事化小，小事化了，法律一般是最后的手段。针对生活里的一般矛盾，人们更多倾向通过道德权威的情理方式去解决，自古以来道德文化一直是法律制度完美辅助。]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发移动端页面时，字体自动变大]]></title>
    <url>%2F2017%2F03%2F23%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%8C%E5%AD%97%E4%BD%93%E8%87%AA%E5%8A%A8%E5%8F%98%E5%A4%A7%2F</url>
    <content type="text"><![CDATA[前言： 工作中开发移动端页面时会有部分内容字体无故变大，自己排查代码却没有解决，后来搜索问题才发现这是webkit内核下的特性 Text Autosizer」，又称「Font Boosting」、「Font Inflation」导致的。 问题描述之前开发移动端页面，发现同一个页面里有的内容字体大小会无故变大，有的却正常。例如，你设置font-size: 40px;,但是实际为60px。 解决之路没办法，自己搜索一下。一看还真有人遇到我和一样的问题。 首先，这个准确说不是由开发人员导致的bug,这是webkit内核移动浏览器特性导致的，这个特性被称做「Text Autosizer」，又称「Font Boosting」、「Font Inflation」，是 Webkit 给移动端浏览器提供的一个特性：当我们在手机上浏览网页时，很可能因为原始页面宽度较大，在手机屏幕上缩小后就看不清其中的文字了。而 Font Boosting 特性在这时会自动将其中的文字字体变大，保证在即不需要左右滑动屏幕，也不需要双击放大屏幕内容的前提下，也可以让人们方便的阅读页面中的文本。 问题解决思路：关闭该特性或让其无效，让字体无法变大 解决方法： 元素单独设置width或height或max-height； 推荐{max-height：100%;}，因为内容显示一般不会固定高和宽。 给元素设置 -webkit-text-size-adjust: none; 可禁用Text Autosizer，这个属性还能使得我们在移动端使用小于12px的字体。此属性在桌面版中无效。 WebKit 中应该有判断如果initial-scale=1时，不触发Text Autosizer目的是为了放大，而设置屏幕不能放大，自然Text Autosizer就失去的意义 123&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;&lt;!-- 或 --&gt;&lt;meta name ="viewport" content ="initial-scale=1, maximum-scale=1, minimum-scale=1"&gt; 个人思考什么条件下会触发这个Text Autosizer?? 个人水平有限，如有不对之处，还望指正！！！ 参考链接 webkit内核下，字号会自动放大的问题 做一个手机端页面时，遇到了一个奇怪的问题：字体的显示大小，与在CSS中指定的大小不一致]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式之入门]]></title>
    <url>%2F2017%2F03%2F14%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B9%8B%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[前言：自己有之前刷FCC的算法题，发现自己的正则了解的很少，所以自己找各种资料学习，并且总结了一下。 正则表达式是什么？ 正则表达式是用于匹配字符串中字符组合的模式。简单来说，用一种描述性语言去规定字符串的一种规则，如果符合，就匹配了，否则就是不匹配。 定义总是很枯燥不直观，我们来举个例子吧。假如你想从”hi my friend”里找出hi单词，我们定义正则表达式：/hi/，比如你想匹配三位数字 123，235等，你可以定义表达式/\d\d\d/,这里的\d我们称为元字符，它含义是匹配一个数字字符，那这里是3个\d所以就可以匹配3个数字，是不是很简单啊。 \d{3}表示匹配3个数字，例如’010’； \d{3,8}表示3-8个数字，例如’1234567’。 ‘00\d’可以匹配’007’，但无法匹配’00A’； 这里的{}也是元字符，后面会介绍。 正则表达式基本语法既然是一种描述性语言，那么就有自己特殊的语法，所以需要大致记忆一下。当然使用的多了，自然就熟悉了。 元字符具有特殊意义的正则表达式，这样可以更好描述需要匹配的字符串。 上面介绍过\d匹配一个数字字符，还有\w匹配一个单字字符（字母、数字或者下划线）,\s匹配任意的空白符. .(小数点）匹配除换行符之外的任何单个字符。 例如.b,就会匹配“bcd abc”中的ab,而不会匹配bc \b\w{6}\b 匹配6个字符的单词，{6}重复6次 ^和$都表示匹配一个位置，^表示字符串开头位置，$表示字符串结尾，例如我们匹配QQ号^\d{5,12}$,{5,12}重复5到12次，因为前后匹配位置，所以必须输入5到12位数字才能匹配。 限定符表示前面正则字符重复的次数 例如： bc*匹配 “bc”或“bcccccccccccccc” a+/匹配了在 “candy” 中的 ‘a’，和在 “caaaaaaandy” 中所有的 ‘a’ e?le? 匹配 “angel” 中的 ‘el’，和 “angle” 中的 ‘le’ 以及”oslo’ 中的’l’。 定位符定位符用来描述字符串或单词的边界 例如你要寻找字符串中hi，但是如果没有设置单词边界，就有可能匹配出him,history,high,但是使用\bhi\b就只会匹配hi单词。 而/B其实是\b的取反，oo\B可以匹配“foot”里的oo 字符转义如果你想查找本身具有特殊意义的元字符，如果直接使用就会产生问题，这时你就得使用\来取消这些字符的特殊意义。 因此，你应该使用\.和\*。当然，要查找\本身，你也得用\\. 字符类有的时候我只是想找元音字母a,e,i,o,u，其他字母不需要怎么办?很明显\w不适合的。 那我们应该自定义自己需要的字符集[a,e,i,o,u], 其实\d等于[0-9],而\w等于[a-z0-9A-Z_] 分枝条件x|y你可以理解为逻辑运算里“或” 例如：green|red匹配“green apple”中的‘green’和“red apple”中的‘red’ 分组我们可以重复单个字符多次，但是怎么可以重复多个字符多次呢？？你可以用小括号()来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了 模式 (foo) (bar) \1 \2 中的 ‘(foo)’ 和 ‘(bar)’ 匹配并记住字符串 &quot;foo bar foo bar&quot; 中前两个单词,每个小括号表示一个分组，1和2是组号而\1表示第一个分组匹配。 例如：\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, 或者kitty kitty 贪婪与懒惰正则表达式默认是尽可能匹配多的字符，以这个表达式为例：a.*b,这样，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。 但是很明显有时候我们需要尽可能匹配少的字符，那我们可以加限定符?,a.*?b,这样如果用它来搜索aabab的话，它会匹配整个字符串aab和ab 标志正则表达式有四个可选参数进行全局和不分大小写搜索。这些参数既可以单独使用也可以一起使用在任何顺序和包含正则表达式的部分中。 使用正则表达式创建一个正则表达式 正则表达式字面量 1234567/* /pattern/flags*/const regex = /ab+c/;const regex = /^[a-zA-Z]+[0-9]*\W?_$/gi; 调用RegExp对象的构造函数 123456789/* new RegExp(pattern [, flags])*/let regex = new RegExp("ab+c");let regex = new RegExp(/^[a-zA-Z]+[0-9]*\W?_$, "gi");let regex = new RegExp("^[a-zA-Z]+[0-9]*\W?_$", "gi"); 使用正则表达式的方法 正则表达式可以被用于RegExp的exec和test方法以及 String的match、replace、search和split方法。 个人水平有限，如有错误，还望指正，感激不尽！！！ 参考链接正则表达式 正则表达式30分钟入门教程 正则表达式 - 教程]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 属性 - 伪类和伪元素的区别]]></title>
    <url>%2F2017%2F03%2F13%2FCSS-%E5%B1%9E%E6%80%A7-%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言：之前自己一直没有弄清楚伪类和伪元素的区别，所以自己打算总结回顾一下。 一、伪类和伪元素的定义伪类(Pseudo-classes) CSS 伪类用于向某些选择器添加特殊的效果 伪元素 CSS 伪元素用于向某些选择器设置特殊效果。 分析一下有2点共同点： 作用于选择器 显示特殊效果 二、伪类和伪元素分类伪类的分类 伪元素分类 三、伪类和伪元素的区别这里用伪类 :first-child 和伪元素 ::first-letter 来进行比较。 123456789//css.par p:first-child&#123; color:red;&#125;&lt;div class='par'&gt; &lt;p class='one'&gt;123&lt;/p&gt; &lt;p class='two'&gt;456&lt;/p&gt;&lt;/div&gt; //伪类 :first-child将样式添加给第一个p子元素 但是如果不用伪类first-child，那么应该怎么显示这个效果呢？我们来试试 123456789//css.one&#123; color:red;&#125;&lt;div class='par'&gt; &lt;p class='one'&gt;123&lt;/p&gt; &lt;p class='two'&gt;456&lt;/p&gt;&lt;/div&gt; 效果是一样的，伪类 :first-child相当于给子元素添加一个类并且定义样式 我们来看看伪元素::first-letter 12345//CSS.text:first-letter&#123; color: red&#125; &lt;p class='text'&gt;文本啊&lt;/p&gt; 但是，如果我们不用伪元素::first-letter，应该怎么显示这个效果呢？我们继续来尝试一下 123456//css.text-one&#123; color: red;&#125;&lt;p&gt;&lt;span class='text-one'&gt;文&lt;/span&gt;本啊&lt;/p&gt; 到达这样的效果，我先添加元素span，然后添加样式。 到这里伪类和伪元素的区别已经很明显了 针对作用选择器的效果，伪类需要添加类来达到效果，而伪元素需要增加元素，所以一个叫伪类，另外一个叫伪元素。 由于二者之间产生的效果十分相似，所以CSS3标准里，为了区分二者已经规定伪类用单冒号:，伪元素用双冒号::，但是由于兼容性问题，大部分还是使用单冒号，如果不存在兼容问题，还是建议使用标准写法 :Pseudo-classes ::Pseudo-elements 个人水平有限，如有不对之处，还望指正！！！ 参考链接谈谈css的伪类和伪元素 详解 CSS 属性 - 伪类和伪元素的区别 CSS中伪类及伪元素用法详解]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex 布局入门]]></title>
    <url>%2F2017%2F03%2F13%2FFlex-%E5%B8%83%E5%B1%80%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[前言：相对float和position会更加灵活处理父元素和子元素之间布局关系，Flex让布局更加直观和灵活简单，你值得拥有。 Flex布局是什么？ W3C针对布局设计的新标准，相对float和position会更加灵活处理父元素和子元素之间布局关系，让布局更加直观和灵活简单。有效的针对不同屏幕宽度大小的情况下，让元素自动有效合理处理布局结构。 适用范围弹性盒子布局主要适用于应用程序的组件及小规模的布局，而（新兴的）栅格布局则针对大规模的布局。 Flex布局基本概念 弹性容器(Flex container)通过设置 display 属性的值为 flex 或 inline-flex来定义弹性容器。 弹性项目(Flex item)弹性容器里子元素自动成为弹性项目，并且弹性项目的float、clear和vertical-align属性将失效。 轴(Axis) 主轴（main axis） 交叉轴（cross axis）这个2个轴决定了容器里的项目整体布局效果。 Flex容器属性 flex-direction flex-wrap flex-flow justify-content align-items align-content flex-direction flex-direction决定主轴方向，默认情况下，元素都是从左到右地分布在主轴上 4个取值： 123456flex-direction: row | row-reverse | column column-reverse;row（默认值）：主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端。column：主轴为垂直方向，起点在上沿。column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap 是否可以换行（默认不换行），以及如果可以换行，如何排列 3个取值1234flex-wrap: nowrap | wrap | wrap-reverse;nowrap: 默认不换行wrap: 可以多行，第一行在上方wrap-reverse: 可以多行，第一行在下方 flex-flow flex-direction 和 flex-wrap 的简写,默认row nowrap 1flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; justify-content 决定项目在主轴上的对齐方式 5种取值： 1234567justify-content: flex-start | flex-end | center | space-between | space-around;flex-start: 左对齐（默认）flex-end: 右对齐center: 居中对齐space-between: 两端对齐，项目之间的间距相等space-around: 均匀对齐，每个项目两端的间距相等 align-items 决定交叉轴的对齐方式 1234567align-items: flex-start | flex-end | center | baseline | stretch;flex-start: 交叉轴起点对齐flex-end: 交叉轴终点对齐center: 交叉轴居中对齐baseline: 第一行文字的底部对齐stretch: （默认）如果项目木有设置高度或者高度为auto,那么项目拉伸充满整个交叉轴空间 注意：记住justify-content是沿着主轴的，align-items是沿着交叉轴的，而flex-direction是转换主轴的。这对整体移动元素很关键。 align-content 定义多行轴线的对齐方式（如果只有一行，该属性不起作用） 1234567align-content: flex-start | flex-end | center | space-between | space-around | stretch;flex-start: 交叉轴起点对齐flex-end: 交叉轴终点对齐space-between: 交叉轴两端对齐，行之间间距相等space-around: 交叉轴均匀对齐，行两端间距相等stretch: 平均分配交叉轴空间，相邻行间距相等（默认，前提如果项目木有设置高度或者高度为auto） 注意：当项目的高度之和小于容器的高度并且项目高度固定时，会以交叉轴起点对齐并且项目之间间距相等，但不是flex-start对齐方式，如果此时设置flex-start是没有间距的。 这里项目设置了固定高度，所以stretch无效 Flex项目属性 order align-self flex-grow flex-shrink flex-basis order 根据order的值定义项目排列顺序。数值越小，排列越靠前，默认为0 align-self 定义单个项目在交叉轴的对齐方式，可覆盖align-items属性 取值和align-items一样： flex-grow 定义项目放大比例，默认为0，当容器有剩余空间时不放大.重点在于，每个方块的 flex-grow 和其他方块的是成比例的。 1flex-grow: &lt;number&gt;; /* default 0 */ 第3个项目flex-grow 为3,其他5个项目为1，共 5+3 = 8,第3个占比为3/8,其他为1/8. flex-shrink 定义项目缩小比例。默认为1，随着容器缩小而等比例缩小。如果设置为0，项目将不缩小。基本和flex-grow类似，不过一个是缩小，一个是放大。 1flex-shrink: &lt;number&gt;; /* default 1 */ flex-basis 定义项目占据的主轴空间（main size）,默认是auto.还有就是它可能被其他flex属性所影响。 1flex-basis: &lt;length&gt; | auto; /* default auto */ 下面这个 GIF 表示的是它和 width 属性是可以互换的。（但是不完全是这样） 注意：flex-basis 和 width 不同的地方是，它是和 flex 坐标轴保持一致的，flex-basis是影响主轴上大小。 下面保持flex-basis不变，改变主轴方向 这个时候改变height，而不是width，flex-basis 根据 flex-direction 的不同会影响到 width 或者 height。 flex flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 12345678910/*简写auto (1 1 auto)none (0 0 auto)*/.square#one &#123; flex: 2 1 300px;&#125;.square#two &#123; flex: 1 2 300px;&#125; 最后注意：主轴和交叉轴需要特别注意方向，因为flex属性大部分是作用与轴上的,而方向不同就会导致不同布局效果。 参考链接通过动图形象地为你介绍 flexbox 是如何工作的（一） 通过动图形象地为你介绍 Flexbox 是如何工作的（二） Flex 布局教程：语法篇 flex基础布局详解 使用 CSS 弹性盒子]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议的初步认识]]></title>
    <url>%2F2017%2F02%2F20%2F%E5%89%8D%E7%AB%AF%E7%9A%84http%E5%88%9D%E8%AE%A4%2F</url>
    <content type="text"><![CDATA[前言： 对于前端而言除了那个前端“三剑客”以外，其实HTTP协议也是非常重要的。所以自己也就小小的总结一下，在此写下自己对前端部分HTTP的浅识。 http协议是什么？？ 协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。 简单来说，HTTP协议(HTTP-Hypertext transfer protocol)是一种详细规定了万维网不同设备之间互相通信的规则。 URL详解schema://host[:port#]/path/.../[;url-params][?query-string][#anchor] scheme: //有我们很熟悉的http、https、ftp以及著名的ed2k，迅雷的thunder等。 host: //HTTP服务器的IP地址或者域名 port#: //HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如tomcat的默认端口是8080 http://localhost:8080/ path: //访问资源的路径 url-params: //所带参数 query-string: //发送给http服务器的数据 anchor: //锚点定位 123456789101112http://www.mywebsite.com/sj/test;id=8079?name=sviergn&amp;x=true#stuffSchema: httphost: www.mywebsite.compath: /sj/testURL params: id=8079Query String: name=sviergn&amp;x=trueAnchor: stuff HTTP的工作流程第一步：建立TCP/IP连接，客户端与服务器通过Socket三次握手进行连接 三次握手涉及TCP协议，有兴趣请看关于三次握手 第二步：客户端向服务端发起HTTP请求（例如：POST/login.html http/1.1） 第三步：客户端发送请求头信息，请求内容，最后会发送一空白行，标示客户端请求完毕 第四步：服务器做出应答，表示对于客户端请求的应答，例如：HTTP/1.1 200 OK 第五步：服务器向客户端发送应答头信息 第六步：服务器向客户端发送请求头信息后，也会发送一空白行，标示应答头信息发送完毕，接着就以Content-type要求的数据格式发送数据给客户端 第七步：服务端关闭TCP连接，如果服务器或者客户端增Connection:keep-alive就表示客户端与服务器端继续保存连接，在下次请求时可以继续使用这次的连接 HTTP消息的结构Request 消息的结构 第一部分：请求行 Method表示请求方法，比如”POST”，”GET” Path-to-resoure表示请求的资源 Http/version-number 表示HTTP协议的版本号 第二部分：http header 第三部分：body（请求方法为get时为空）header和body之间有个空行 Response消息的结构 第一部分：request line 状态行 HTTP/version-number表示HTTP协议的版本号， status-code 和message 可另行了解 第二部分：request header 第三部分：body（请求方法为get时为空）header和body之间有个空行 HTTP请求详解 General Request URL：客户端请求服务器的URL地址 Request Method：请求的方式，最基本的有四种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息. Status Code：服务器响应请求后返回的code,code标示请求的状态，一般反应了通信的信息。 Remote Address：直译过来叫做远程地址，其实怎么理解呢？也就是说的是你请求发出的那个地址… Request Header 请求头 Accept：浏览器端可以接受的媒体类型 例如： Accept: text/html 代表浏览器可以接受服务器回发的类型为 text/html 也就是我们常说的html文档, Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）; Accept-Language: 浏览器申明自己接收的语言。 语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等； Cache-Control: 指定Response-Request遵循的缓存机制 Cache-Control:Public 可以被任何缓存所缓存 Cache-Control:Private 内容只缓存到私有缓存中 Cache-Control:no-cache 所有内容都不会被缓存 Connection: 客户端和服务器之间用于传输HTTP数据的TCP是否持续连接 Connection: keep-alive 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接 Connection: close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。 Cookie: 将cookie的所有值发送给HTTP 服务器 Host: 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的 Pragma: 防止页面被缓存，只有一个用法Pragma: no-cache Upgrade-Insecure-Requests: https页面不在显示http警告该指令用于让浏览器自动升级请求从http到https,用于大量包含http资源的http网页直接升级到https而不会报错.简洁的来讲,就相当于在http和https之间起的一个过渡作用. 详情查看Upgrade-Insecure-Requests User-Agent: 告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本. Response Headers Date：表明了响应的时间 -GMT(标准时间) Content-Type： 发送给客户端的实体正文的媒体类型 Connection： 允许客户端或服务器中任何一方关闭底层的连接双方都会要求在处理请求后关闭或者保持它们的TCP连接。 Server：服务器软件的信息 Transfer-Encoding:定义请求的传输编码 基础的状态码Response 消息中的第一行叫做状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。 状态码用来告诉HTTP客户端，HTTP服务器是否产生了预期的Response. HTTP/1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别 1XX 提示信息 - 表示请求已被成功接收，继续处理 2XX 成功 - 表示请求已被成功接收，理解，接受 3XX 重定向 - 要完成请求必须进行更进一步的处理 4XX 客户端错误 - 请求有语法错误或请求无法实现 5XX 服务器端错误 - 服务器未能实现合法的请求 文笔有限，才疏学浅，文中若有不正之处，还望告知。 参考文章 HTTP 协议详解 大前端学习笔记整理【七】HTTP协议以及http与https的区别 upgrade-insecure-requests “Upgrade-Insecure-Requests:1”表示什么意思？]]></content>
      <categories>
        <category>前端</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《爱乐之城》观后感]]></title>
    <url>%2F2017%2F02%2F18%2F%E3%80%8A%E7%88%B1%E4%B9%90%E4%B9%8B%E5%9F%8E%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[前言：梦想的公交车上你是司机，而其他人都是乘客，到站了就要下车。 之前偶然发现《爱乐之城》这部电影，看到很多对它的无尽的赞美之词，个人很是期待，所以今天去观看后感触很多，在此将自己的许多体会写下。 感受真实的梦想电影很好的体现一个人追求梦想的真实状态，梦想对每个人来说都很美好，但是实现的过程总是一路坎坷，自我怀疑或动摇。主角们最后都是实现了自己当初的梦想，但是结局似乎很无奈。电影在体现真实的梦想时，同时也给予人们温暖继续鼓励大家不要放弃梦想。尽管有些无奈和伤痛，但是整体而言还是美好。 如果没有如果电影最后的几分钟，给出主角们的另外一种完美的人生经历和选择，给观众一个十分美好几乎完美的人生过程。但是回到现实，镜头的最后分别给了男女主角，只是见他们相视一笑，各自的眼中满是无奈和伤痛，但是笑了说明他们接受自己当初的选择。是啊，人生没有如果，现实总是在你我的眼前。]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端疲惫阅读感想]]></title>
    <url>%2F2016%2F12%2F27%2F%E5%89%8D%E7%AB%AF%E7%96%B2%E6%83%AB%E9%98%85%E8%AF%BB%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[前言 唐僧师徒四人去西天取经，一路克服重重困难而最终取得真经。记得悟空在路上一脸困惑的问师傅：“师傅，敢问路在何方？”，唐僧若有沉思缓缓回答道：“路在脚下”。悟空似乎明白了什么，又继续抬头赶路了。 今天读到一篇文章，文章名字叫前端疲惫，看着名就感受到一股程序员段子手的味道，细细阅读果然风趣幽默，让人有所沉思。 其实正如文章所说，水是喝不完的，游泳才是正道。我个人一直对目前前端各种新型技术充满困难，不知道自己的路在何方？看到这篇文章的时候，相信很多都会很有共鸣。这些新技术只是用来提高开发效率的，基础的东西是真的很重要。 另外作者给出如何应对目前的前端疲惫的建议 夯实基础基础的东西永远不会落后，计算机的底层知识永远是适用计算机各个领域的。 放松心态面对这些新东西，可以去了解，太过深入反而给自己压力，放松心态，专注于自己目前正在使用的技术栈。对于那些新技术，有兴趣当然可以去尝试，不去尝试也没有关系。不过，如果确实准备去尝试了，要专一不要贪心，千万别给自己列一堆新技术的学习计划，然后最后没有完成就只能变成无形的压力堆积在心里了。 实践最重要你见过谁学会游泳是通过看书学会的吗？？都是一头扎进水，反复尝试学会吧。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端页面开发适配-rem布局]]></title>
    <url>%2F2016%2F12%2F26%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91%E9%80%82%E9%85%8D-rem%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[前言：现在的手机终端各式各样，分辨率不同，逻辑像素不同 ，适口不同，所以为了让我们的页面在每个设备上都可以良好的展示，那么就需要为这些设备做统一的处理，这个过程就称为移动端适配，目前基本采用rem布局方式来适配。 在我们给出移动端适配的方法之前，我们首先了解一些基本概念 什么是PPI？PPI全称为Pixel Per Inch，译为每英寸像素取值，更确切的说法应该是像素密度，也就是衡量单位物理面积内拥有像素值的情况。一般来讲PPI越高，显示效果越清晰，当然不是越高越好，过高对图片的适配带来压力。另外，请记住，当我们在谈论一台显示设备的像素密度时，dpi与ppi是等价的 PPI的计算是物理像素除以物理尺寸，一般是采取对角线的数据PPI = 对角线的分辨率/对角线英寸，当然水平和垂直也是可以的。 什么是Pixel（像素）？针对前端开发，像素一般分为2种 物理像素 CSS像素 接下来我会分别解释上面2个概念： 物理像素买手机的时候会有一个 n*m 的分辨率，那是屏幕的n*m个呈像的点，一个点（小方格）为一个物理像素。它是屏幕能显示的最小粒度 CSS像素css的1px 和物理的1px有什么关系呢？？那么CSS中的1px是什么？浏览器是怎么渲染它的？ 网页在一个叫viewport的东西里渲染，可以理解为画布，画布被分成 N x M 个小方格，1个CSS像素，就是其中的一个小方格。 viewport又是什么？网页在viewport上渲染，可以想像在PS上画东西时，上面也有个画布，这个画布分割了 N x M 个方格，N是它的宽度，M是它的高度。宽高都可以任意设置，所以说viewport是虚拟的。假设设置宽度是400，那么浏览器显示区域的横向将被分为400份，CSS的1px占的宽度就是显示区域的 1/400。如果是980，那就是1/980。 viewport = 500 viewport = 900 viewport取不同值时，对布局会产生影响，很明显900的布局缩小了。例如我们只分析用户头像的图片，已知头像宽度是50px。 当viewport宽度为500时，屏幕横向被分为500份，每份1px，所以头像宽度是屏幕的1/10。（500/50=10） 当viewport宽度为900时，屏幕横向被分为900份，每份1px，所以头像宽度是屏幕的1/18。 （900/50=18） 所以，在CSS中，1px是指viewport中的一个小方格，而viewport宽度是可以任意设置的。 怎么合理设置viewport的宽度？viewport的宽度可以是数字和字符串”device-width”。device-width指设备宽度。 当取值为数字时，指不论是什么手机屏幕，viewport都被分为那么多份 当取值为device-width时，指的是手机屏幕的viewport宽度被设置为跟手机宽度一样。 因为很明显device-width的宽度值单位是CSS像素。所以当viewport设置为device-width时，我们必须明白一个概念就是：DevicePixelRatio DevicePixelRatio定义如下： window.devicePixelRatio = physical pixels / dips 分母dips全称为device-independent pixels，译为与设备无关像素。 更通俗的说应为与物理像素无关的CSS像素。 devicePixelRatio说白了就是手机的物理像素与实际使用像素的缩放比。 例如：某台安卓手机，分辨率是 1920*1080，屏幕对象线是5英寸。那么在这台手机上1个CSS像素，占了多少个物理像素？ 第一步：勾股定理算出对角线的分辨率，即 √(1920²+1080²)≈2203px 第二步：算出dpi。对角线的分辨率/对角线英寸 = 2203/5≈440dpi 第三步：得出转换系数。根据上面的图片，安卓手机440dpi，属于XXHDPI，转换系数是3 因此这台手机中，1个CSS像素 = 3*物理像素。即1个CSS像素占了3个物理像素。 这个转换系数，也等同于dpr，设备像素比。 该台安卓手机的device-width是1080/3 = 360，即viewport的宽度是 360 CSS像素。 注意devicePixelRatio并非是一个默认值。在默认情况下CSS像素是由手机默认的缩放决定的。但同时因为浏览器页面也可以被人为的进行缩放。比如iPhon4中默认的分辨率宽度为320px。浏览网页时我们完全可以自行放大两倍为160px。这样以来window.devicePixelRatio就变味了 640 / 160 = 4。通过改变dips而改变dpr. 多屏适配布局问题？业内比较流行的做法（参考阿里的flexible）阿里的flexible 基于rem的原理，针对不同手机屏幕尺寸和dpr动态的改变根节点html的font-size大小(基准值)。 设置viewport为设备宽度（这里不一定，但目前先这样足矣） 将viewport分成10rem，并计算出1rem在当前浏览器的像素值，把它赋予html标签的font-size（分成10rem只是为了方便计算而已,同时为了以后vw和vh） 写CSS代码时，遇到要适配的地方，比如width，margin，padding等，就不要再用px了，改成用rem 最后字体大小问题，一般还是基于dpr使用px 对于字体缩放问题，设计师原本的要求是这样的：任何手机屏幕上字体大小都要统一，所以我们针对不同的分辨率(dpr不同)，会做如下处理：1234font-size: 16px;[data-dpr=&quot;2&quot;] input &#123; font-size: 32px;&#125; (注意，字体不可以用rem，误差太大了，且不能满足任何屏幕下字体大小相同) 参考文章 移动适配-移动Web怎么做屏幕适配（三） 浅谈移动Web开发（上）：深入概念 移动端高清、多屏适配方案]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爆裂鼓手观后感]]></title>
    <url>%2F2016%2F12%2F18%2F%E7%88%86%E8%A3%82%E9%BC%93%E6%89%8B%2F</url>
    <content type="text"><![CDATA[前言：比你牛逼的人比你还努力！！！ 首先这部电影在评价上有很多分歧，但是大家基本都认为这是一部还不错的电影，不管是技巧和艺术价值上。有巨大的分歧，说明电影让观众得到了不同的感受，这是成功的。正如一千个读者就有一千个哈姆雷特。 其次，我个人认为追求价值和梦想时，背后往往是黑暗、孤独等很多负面的东西，因为现实往往是残酷的。这点是大多数人应该认可的，当然不乏有天赋的人并没有经历这残酷的事实同样也获得个人价值的提升，但是有天赋的人毕竟是少数。 最后对我而言，让我觉得大多数的人（包括我自己）对梦想和个人价值的追求根本谈不上努力，看看安德鲁就知道了，那是要付出血的代价！！！]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F11%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>教学</category>
      </categories>
      <tags>
        <tag>说明文档</tag>
      </tags>
  </entry>
</search>