<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[移动端，字体自动变大]]></title>
      <url>%2F2017%2F03%2F23%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%8C%E5%AD%97%E4%BD%93%E8%87%AA%E5%8A%A8%E5%8F%98%E5%A4%A7%2F</url>
      <content type="text"><![CDATA[前言： 工作中开发移动端页面时会有部分内容字体无故变大，自己排查代码却没有解决，后来搜索问题才发现这是webkit内核下的特性 Text Autosizer」，又称「Font Boosting」、「Font Inflation」导致的。 问题描述之前开发移动端页面，发现同一个页面里有的内容字体大小会无故变大，有的却正常。例如，你设置font-size: 30px;,但是实际为52px。 解决之路没办法，自己搜索一下。一看还真有人遇到我和一样的问题。 首先，这个准确说不是由开发人员导致的bug,这是webkit内核移动浏览器特性导致的，这个特性被称做「Text Autosizer」，又称「Font Boosting」、「Font Inflation」，是 Webkit 给移动端浏览器提供的一个特性：当我们在手机上浏览网页时，很可能因为原始页面宽度较大，在手机屏幕上缩小后就看不清其中的文字了。而 Font Boosting 特性在这时会自动将其中的文字字体变大，保证在即不需要左右滑动屏幕，也不需要双击放大屏幕内容的前提下，也可以让人们方便的阅读页面中的文本。 问题解决思路：关闭该特性或让其无效，让字体无法变大 解决方法： 元素单独设置width或height或max-height； 有的人喜欢max-height: 999999px;，一般推荐{max-height：100%;}，因为内容显示一般不会固定高和宽。 给元素设置 -webkit-text-size-adjust: none; 可禁用Text Autosizer，这个属性还能使得我们在移动端使用小于12px的字体。此属性在桌面版中无效。 WebKit 中应该有判断如果initial-scale=1时，不触发Text Autosizer目的是为了放大，而设置屏幕不能放大，自然Text Autosizer就失去的意义 123&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;&lt;!-- 或 --&gt;&lt;meta name ="viewport" content ="initial-scale=1, maximum-scale=1, minimum-scale=1"&gt; 个人思考什么条件下会触发这个Text Autosizer?? 个人水平有限，如有不对之处，还望指正！！！ 参考链接 webkit内核下，字号会自动放大的问题 做一个手机端页面时，遇到了一个奇怪的问题：字体的显示大小，与在CSS中指定的大小不一致]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正则表达式之入门]]></title>
      <url>%2F2017%2F03%2F14%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B9%8B%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[前言：自己有之前刷FCC的算法题，发现自己的正则了解的很少，所以自己找各种资料学习，并且总结了一下。 正则表达式是什么？ 正则表达式是用于匹配字符串中字符组合的模式。简单来说，用一种描述性语言去规定字符串的一种规则，如果符合，就匹配了，否则就是不匹配。 定义总是很枯燥不直观，我们来举个例子吧。假如你想从”hi my friend”里找出hi单词，我们定义正则表达式：/hi/，比如你想匹配三位数字 123，235等，你可以定义表达式/\d\d\d/,这里的\d我们称为元字符，它含义是匹配一个数字字符，那这里是3个\d所以就可以匹配3个数字，是不是很简单啊。 \d{3}表示匹配3个数字，例如’010’； \d{3,8}表示3-8个数字，例如’1234567’。 ‘00\d’可以匹配’007’，但无法匹配’00A’； 这里的{}也是元字符，后面会介绍。 正则表达式基本语法既然是一种描述性语言，那么就有自己特殊的语法，所以需要大致记忆一下。当然使用的多了，自然就熟悉了。 元字符具有特殊意义的正则表达式，这样可以更好描述需要匹配的字符串。 上面介绍过\d匹配一个数字字符，还有\w匹配一个单字字符（字母、数字或者下划线）,\s匹配任意的空白符. .(小数点）匹配除换行符之外的任何单个字符。 例如.b,就会匹配“bcd abc”中的ab,而不会匹配bc \b\w{6}\b 匹配6个字符的单词，{6}重复6次 ^和$都表示匹配一个位置，^表示字符串开头位置，$表示字符串结尾，例如我们匹配QQ号^\d{5,12}$,{5,12}重复5到12次，因为前后匹配位置，所以必须输入5到12位数字才能匹配。 限定符表示前面正则字符重复的次数 例如： bc*匹配 “bc”或“bcccccccccccccc” a+/匹配了在 “candy” 中的 ‘a’，和在 “caaaaaaandy” 中所有的 ‘a’ e?le? 匹配 “angel” 中的 ‘el’，和 “angle” 中的 ‘le’ 以及”oslo’ 中的’l’。 定位符定位符用来描述字符串或单词的边界 例如你要寻找字符串中hi，但是如果没有设置单词边界，就有可能匹配出him,history,high,但是使用\bhi\b就只会匹配hi单词。 而/B其实是\b的取反，oo\B可以匹配“foot”里的oo 字符转义如果你想查找本身具有特殊意义的元字符，如果直接使用就会产生问题，这时你就得使用\来取消这些字符的特殊意义。 因此，你应该使用\.和\*。当然，要查找\本身，你也得用\\. 字符类有的时候我只是想找元音字母a,e,i,o,u，其他字母不需要怎么办?很明显\w不适合的。 那我们应该自定义自己需要的字符集[a,e,i,o,u], 其实\d等于[0-9],而\w等于[a-z0-9A-Z_] 分枝条件x|y你可以理解为逻辑运算里“或” 例如：green|red匹配“green apple”中的‘green’和“red apple”中的‘red’ 分组我们可以重复单个字符多次，但是怎么可以重复多个字符多次呢？？你可以用小括号()来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了 模式 (foo) (bar) \1 \2 中的 ‘(foo)’ 和 ‘(bar)’ 匹配并记住字符串 &quot;foo bar foo bar&quot; 中前两个单词,每个小括号表示一个分组，1和2是组号而\1表示第一个分组匹配。 例如：\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, 或者kitty kitty 贪婪与懒惰正则表达式默认是尽可能匹配多的字符，以这个表达式为例：a.*?b,这样，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。 但是很明显有时候我们需要尽可能匹配少的字符，那我们可以加限定符?,a.*?b,这样如果用它来搜索aabab的话，它会匹配整个字符串aab和ab 标志正则表达式有四个可选参数进行全局和不分大小写搜索。这些参数既可以单独使用也可以一起使用在任何顺序和包含正则表达式的部分中。 使用正则表达式创建一个正则表达式 正则表达式字面量 1234567/* /pattern/flags*/const regex = /ab+c/;const regex = /^[a-zA-Z]+[0-9]*\W?_$/gi; 调用RegExp对象的构造函数 123456789/* new RegExp(pattern [, flags])*/let regex = new RegExp("ab+c");let regex = new RegExp(/^[a-zA-Z]+[0-9]*\W?_$, "gi");let regex = new RegExp("^[a-zA-Z]+[0-9]*\W?_$", "gi"); 使用正则表达式的方法 正则表达式可以被用于RegExp的exec和test方法以及 String的match、replace、search和split方法。 个人水平有限，如有错误，还望指正，感激不尽！！！ 参考链接正则表达式 正则表达式30分钟入门教程 正则表达式 - 教程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS 属性 - 伪类和伪元素的区别]]></title>
      <url>%2F2017%2F03%2F13%2FCSS-%E5%B1%9E%E6%80%A7-%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[前言：之前自己一直没有弄清楚伪类和伪元素的区别，所以自己打算总结回顾一下。 一、伪类和伪元素的定义伪类(Pseudo-classes) CSS 伪类用于向某些选择器添加特殊的效果 伪元素 CSS 伪元素用于向某些选择器设置特殊效果。 分析一下有2点共同点： 作用于选择器 显示特殊效果 二、伪类和伪元素分类伪类的分类 伪元素分类 三、伪类和伪元素的区别这里用伪类 :first-child 和伪元素 ::first-letter 来进行比较。 123456789//css.par p:first-child&#123; color:red;&#125;&lt;div class='par'&gt; &lt;p class='one'&gt;123&lt;/p&gt; &lt;p class='two'&gt;456&lt;/p&gt;&lt;/div&gt; //伪类 :first-child将样式添加给第一个p子元素 但是如果不用伪类first-child，那么应该怎么显示这个效果呢？我们来试试 123456789//css.one&#123; color:red;&#125;&lt;div class='par'&gt; &lt;p class='one'&gt;123&lt;/p&gt; &lt;p class='two'&gt;456&lt;/p&gt;&lt;/div&gt; 效果是一样的，伪类 :first-child相当于给子元素添加一个类并且定义样式 我们来看看伪元素::first-letter 12345//CSS.text:first-letter&#123; color: red&#125; &lt;p class='text'&gt;文本啊&lt;/p&gt; 但是，如果我们不用伪元素::first-letter，应该怎么显示这个效果呢？我们继续来尝试一下 123456//css.text-one&#123; color: red;&#125;&lt;p&gt;&lt;span class='text-one'&gt;文&lt;/span&gt;本啊&lt;/p&gt; 到达这样的效果，我先添加元素span，然后添加样式。 到这里伪类和伪元素的区别已经很明显了 针对作用选择器的效果，伪类需要添加类来达到效果，而伪元素需要增加元素，所以一个叫伪类，另外一个叫伪元素。 由于二者之间产生的效果十分相似，所以CSS3标准里，为了区分二者已经规定伪类用单冒号:，伪元素用双冒号::，但是由于兼容性问题，大部分还是使用单冒号，如果不存在兼容问题，还是建议使用标准写法 :Pseudo-classes ::Pseudo-elements 个人水平有限，如有不对之处，还望指正！！！ 参考链接谈谈css的伪类和伪元素 详解 CSS 属性 - 伪类和伪元素的区别 CSS中伪类及伪元素用法详解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flex 布局入门]]></title>
      <url>%2F2017%2F03%2F13%2FFlex-%E5%B8%83%E5%B1%80%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[前言：相对float和position会更加灵活处理父元素和子元素之间布局关系，Flex让布局更加直观和灵活简单，你值得拥有。 Flex布局是什么？ W3C针对布局设计的新标准，相对float和position会更加灵活处理父元素和子元素之间布局关系，让布局更加直观和灵活简单。有效的针对不同屏幕宽度大小的情况下，让元素自动有效合理处理布局结构。 适用范围弹性盒子布局主要适用于应用程序的组件及小规模的布局，而（新兴的）栅格布局则针对大规模的布局。 Flex布局基本概念 弹性容器(Flex container)通过设置 display 属性的值为 flex 或 inline-flex来定义弹性容器。 弹性项目(Flex item)弹性容器里子元素自动成为弹性项目，并且弹性项目的float、clear和vertical-align属性将失效。 轴(Axis) 主轴（main axis） 交叉轴（cross axis）这个2个轴决定了容器里的项目整体布局效果。 Flex容器属性 flex-direction flex-wrap flex-flow justify-content align-items align-content flex-direction flex-direction决定主轴方向，默认情况下，元素都是从左到右地分布在主轴上 4个取值： 123456flex-direction: row | row-reverse | column column-reverse;row（默认值）：主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端。column：主轴为垂直方向，起点在上沿。column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap 是否可以换行（默认不换行），以及如果可以换行，如何排列 3个取值1234flex-wrap: nowrap | wrap | wrap-reverse;nowrap: 默认不换行wrap: 可以多行，第一行在上方wrap-reverse: 可以多行，第一行在下方 flex-flow flex-direction 和 flex-wrap 的简写,默认row nowrap 1flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; justify-content 决定项目在主轴上的对齐方式 5种取值： 1234567justify-content: flex-start | flex-end | center | space-between | space-around;flex-start: 左对齐（默认）flex-end: 右对齐center: 居中对齐space-between: 两端对齐，项目之间的间距相等space-around: 均匀对齐，每个项目两端的间距相等 align-items 决定交叉轴的对齐方式 1234567align-items: flex-start | flex-end | center | baseline | stretch;flex-start: 交叉轴起点对齐flex-end: 交叉轴终点对齐center: 交叉轴居中对齐baseline: 第一行文字的底部对齐stretch: （默认）如果项目木有设置高度或者高度为auto,那么项目拉伸充满整个交叉轴空间 注意：记住justify-content是沿着主轴的，align-items是沿着交叉轴的，而flex-direction是转换主轴的。这对整体移动元素很关键。 align-content 定义多行轴线的对齐方式（如果只有一行，该属性不起作用） 1234567align-content: flex-start | flex-end | center | space-between | space-around | stretch;flex-start: 交叉轴起点对齐flex-end: 交叉轴终点对齐space-between: 交叉轴两端对齐，行之间间距相等space-around: 交叉轴均匀对齐，行两端间距相等stretch: 平均分配交叉轴空间，相邻行间距相等（默认，前提如果项目木有设置高度或者高度为auto） 注意：当项目的高度之和小于容器的高度并且项目高度固定时，会以交叉轴起点对齐并且项目之间间距相等，但不是flex-start对齐方式，如果此时设置flex-start是没有间距的。 这里项目设置了固定高度，所以stretch无效 Flex项目属性 order align-self flex-grow flex-shrink flex-basis order 根据order的值定义项目排列顺序。数值越小，排列越靠前，默认为0 align-self 定义单个项目在交叉轴的对齐方式，可覆盖align-items属性 取值和align-items一样： flex-grow 定义项目放大比例，默认为0，当容器有剩余空间时不放大.重点在于，每个方块的 flex-grow 和其他方块的是成比例的。 1flex-grow: &lt;number&gt;; /* default 0 */ 第3个项目flex-grow 为3,其他5个项目为1，共 5+3 = 8,第3个占比为3/8,其他为1/8. flex-shrink 定义项目缩小比例。默认为1，随着容器缩小而等比例缩小。如果设置为0，项目将不缩小。基本和flex-grow类似，不过一个是缩小，一个是放大。 1flex-shrink: &lt;number&gt;; /* default 1 */ flex-basis 定义项目占据的主轴空间（main size）,默认是auto.还有就是它可能被其他flex属性所影响。 1flex-basis: &lt;length&gt; | auto; /* default auto */ 下面这个 GIF 表示的是它和 width 属性是可以互换的。（但是不完全是这样） 注意：flex-basis 和 width 不同的地方是，它是和 flex 坐标轴保持一致的，flex-basis是影响主轴上大小。 下面保持flex-basis不变，改变主轴方向 这个时候改变height，而不是width，flex-basis 根据 flex-direction 的不同会影响到 width 或者 height。 flex flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 12345678910/*简写auto (1 1 auto)none (0 0 auto)*/.square#one &#123; flex: 2 1 300px;&#125;.square#two &#123; flex: 1 2 300px;&#125; 最后注意：主轴和交叉轴需要特别注意方向，因为flex属性大部分是作用与轴上的,而方向不同就会导致不同布局效果。 参考链接通过动图形象地为你介绍 flexbox 是如何工作的（一） 通过动图形象地为你介绍 Flexbox 是如何工作的（二） Flex 布局教程：语法篇 flex基础布局详解 使用 CSS 弹性盒子]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP协议的初步认识]]></title>
      <url>%2F2017%2F02%2F20%2F%E5%89%8D%E7%AB%AF%E7%9A%84http%E5%88%9D%E8%AE%A4%2F</url>
      <content type="text"><![CDATA[前言： 对于前端而言除了那个前端“三剑客”以外，其实HTTP协议也是非常重要的。所以自己也就小小的总结一下，在此写下自己对前端部分HTTP的浅识。 http协议是什么？？ 协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。 简单来说，HTTP协议(HTTP-Hypertext transfer protocol)是一种详细规定了万维网不同设备之间互相通信的规则。 URL详解schema://host[:port#]/path/.../[;url-params][?query-string][#anchor] scheme: //有我们很熟悉的http、https、ftp以及著名的ed2k，迅雷的thunder等。 host: //HTTP服务器的IP地址或者域名 port#: //HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如tomcat的默认端口是8080 http://localhost:8080/ path: //访问资源的路径 url-params: //所带参数 query-string: //发送给http服务器的数据 anchor: //锚点定位 123456789101112http://www.mywebsite.com/sj/test;id=8079?name=sviergn&amp;x=true#stuffSchema: httphost: www.mywebsite.compath: /sj/testURL params: id=8079Query String: name=sviergn&amp;x=trueAnchor: stuff HTTP的工作流程第一步：建立TCP/IP连接，客户端与服务器通过Socket三次握手进行连接 三次握手涉及TCP协议，有兴趣请看关于三次握手 第二步：客户端向服务端发起HTTP请求（例如：POST/login.html http/1.1） 第三步：客户端发送请求头信息，请求内容，最后会发送一空白行，标示客户端请求完毕 第四步：服务器做出应答，表示对于客户端请求的应答，例如：HTTP/1.1 200 OK 第五步：服务器向客户端发送应答头信息 第六步：服务器向客户端发送请求头信息后，也会发送一空白行，标示应答头信息发送完毕，接着就以Content-type要求的数据格式发送数据给客户端 第七步：服务端关闭TCP连接，如果服务器或者客户端增Connection:keep-alive就表示客户端与服务器端继续保存连接，在下次请求时可以继续使用这次的连接 HTTP消息的结构Request 消息的结构 第一部分：请求行 Method表示请求方法，比如”POST”，”GET” Path-to-resoure表示请求的资源 Http/version-number 表示HTTP协议的版本号 第二部分：http header 第三部分：body（请求方法为get时为空）header和body之间有个空行 Response消息的结构 第一部分：request line 状态行 HTTP/version-number表示HTTP协议的版本号， status-code 和message 可另行了解 第二部分：request header 第三部分：body（请求方法为get时为空）header和body之间有个空行 HTTP请求详解 General Request URL：客户端请求服务器的URL地址 Request Method：请求的方式，最基本的有四种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息. Status Code：服务器响应请求后返回的code,code标示请求的状态，一般反应了通信的信息。 Remote Address：直译过来叫做远程地址，其实怎么理解呢？也就是说的是你请求发出的那个地址… Request Header 请求头 Accept：浏览器端可以接受的媒体类型 例如： Accept: text/html 代表浏览器可以接受服务器回发的类型为 text/html 也就是我们常说的html文档, Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）; Accept-Language: 浏览器申明自己接收的语言。 语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等； Cache-Control: 指定Response-Request遵循的缓存机制 Cache-Control:Public 可以被任何缓存所缓存 Cache-Control:Private 内容只缓存到私有缓存中 Cache-Control:no-cache 所有内容都不会被缓存 Connection: 客户端和服务器之间用于传输HTTP数据的TCP是否持续连接 Connection: keep-alive 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接 Connection: close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。 Cookie: 将cookie的所有值发送给HTTP 服务器 Host: 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的 Pragma: 防止页面被缓存，只有一个用法Pragma: no-cache Upgrade-Insecure-Requests: https页面不在显示http警告该指令用于让浏览器自动升级请求从http到https,用于大量包含http资源的http网页直接升级到https而不会报错.简洁的来讲,就相当于在http和https之间起的一个过渡作用. 详情查看Upgrade-Insecure-Requests User-Agent: 告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本. Response Headers Date：表明了响应的时间 -GMT(标准时间) Content-Type： 发送给客户端的实体正文的媒体类型 Connection： 允许客户端或服务器中任何一方关闭底层的连接双方都会要求在处理请求后关闭或者保持它们的TCP连接。 Server：服务器软件的信息 Transfer-Encoding:定义请求的传输编码 基础的状态码Response 消息中的第一行叫做状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。 状态码用来告诉HTTP客户端，HTTP服务器是否产生了预期的Response. HTTP/1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别 1XX 提示信息 - 表示请求已被成功接收，继续处理 2XX 成功 - 表示请求已被成功接收，理解，接受 3XX 重定向 - 要完成请求必须进行更进一步的处理 4XX 客户端错误 - 请求有语法错误或请求无法实现 5XX 服务器端错误 - 服务器未能实现合法的请求 文笔有限，才疏学浅，文中若有不正之处，还望告知。 参考文章 HTTP 协议详解 大前端学习笔记整理【七】HTTP协议以及http与https的区别 upgrade-insecure-requests “Upgrade-Insecure-Requests:1”表示什么意思？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《爱乐之城》观后感]]></title>
      <url>%2F2017%2F02%2F18%2F%E3%80%8A%E7%88%B1%E4%B9%90%E4%B9%8B%E5%9F%8E%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F%2F</url>
      <content type="text"><![CDATA[前言：梦想的公交车上你是司机，而其他人都是乘客，到站了就要下车。 之前偶然发现《爱乐之城》这部电影，看到很多对它的无尽的赞美之词，个人很是期待，所以今天去观看后感触很多，在此将自己的许多体会写下。 感受真实的梦想电影很好的体现一个人追求梦想的真实状态，梦想对每个人来说都很美好，但是实现的过程总是一路坎坷，自我怀疑或动摇。主角们最后都是实现了自己当初的梦想，但是结局似乎很无奈。电影在体现真实的梦想时，同时也给予人们温暖继续鼓励大家不要放弃梦想。尽管有些无奈和伤痛，但是整体而言还是美好。 如果没有如果电影最后的几分钟，给出主角们的另外一种完美的人生经历和选择，给观众一个十分美好几乎完美的人生过程。但是回到现实，镜头的最后分别给了男女主角，只是见他们相视一笑，各自的眼中满是无奈和伤痛，但是笑了说明他们接受自己当初的选择。是啊，人生没有如果，现实总是在你我的眼前。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端疲惫阅读感想]]></title>
      <url>%2F2016%2F12%2F27%2F%E5%89%8D%E7%AB%AF%E7%96%B2%E6%83%AB%E9%98%85%E8%AF%BB%E6%84%9F%E6%83%B3%2F</url>
      <content type="text"><![CDATA[前言 唐僧师徒四人去西天取经，一路克服重重困难而最终取得真经。记得悟空在路上一脸困惑的问师傅：“师傅，敢问路在何方？”，唐僧若有沉思缓缓回答道：“路在脚下”。悟空似乎明白了什么，又继续抬头赶路了。 今天读到一篇文章，文章名字叫前端疲惫，看着名就感受到一股程序员段子手的味道，细细阅读果然风趣幽默，让人有所沉思。 其实正如文章所说，水是喝不完的，游泳才是正道。我个人一直对目前前端各种新型技术充满困难，不知道自己的路在何方？看到这篇文章的时候，相信很多都会很有共鸣。这些新技术只是用来提高开发效率的，基础的东西是真的很重要。 另外作者给出如何应对目前的前端疲惫的建议 夯实基础基础的东西永远不会落后，计算机的底层知识永远是适用计算机各个领域的。 放松心态面对这些新东西，可以去了解，太过深入反而给自己压力，放松心态，专注于自己目前正在使用的技术栈。对于那些新技术，有兴趣当然可以去尝试，不去尝试也没有关系。不过，如果确实准备去尝试了，要专一不要贪心，千万别给自己列一堆新技术的学习计划，然后最后没有完成就只能变成无形的压力堆积在心里了。 实践最重要你见过谁学会游泳是通过看书学会的吗？？都是一头扎进水，反复尝试学会吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端页面开发适配-rem布局]]></title>
      <url>%2F2016%2F12%2F26%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91%E9%80%82%E9%85%8D-rem%E5%B8%83%E5%B1%80%2F</url>
      <content type="text"><![CDATA[前言：现在的手机终端各式各样，分辨率不同，逻辑像素不同 ，适口不同，所以为了让我们的页面在每个设备上都可以良好的展示，那么就需要为这些设备做统一的处理，这个过程就称为移动端适配，目前基本采用rem布局方式来适配。 在我们给出移动端适配的方法之前，我们首先了解一些基本概念 什么是PPI？PPI全称为Pixel Per Inch，译为每英寸像素取值，更确切的说法应该是像素密度，也就是衡量单位物理面积内拥有像素值的情况。一般来讲PPI越高，显示效果越清晰，当然不是越高越好，过高对图片的适配带来压力。另外，请记住，当我们在谈论一台显示设备的像素密度时，dpi与ppi是等价的 PPI的计算是物理像素除以物理尺寸，一般是采取对角线的数据PPI = 对角线的分辨率/对角线英寸，当然水平和垂直也是可以的。 什么是Pixel（像素）？针对前端开发，像素一般分为2种 物理像素 CSS像素 接下来我会分别解释上面2个概念： 物理像素买手机的时候会有一个 n*m 的分辨率，那是屏幕的n*m个呈像的点，一个点（小方格）为一个物理像素。它是屏幕能显示的最小粒度 CSS像素css的1px 和物理的1px有什么关系呢？？那么CSS中的1px是什么？浏览器是怎么渲染它的？ 网页在一个叫viewport的东西里渲染，可以理解为画布，画布被分成 N x M 个小方格，1个CSS像素，就是其中的一个小方格。 viewport又是什么？网页在viewport上渲染，可以想像在PS上画东西时，上面也有个画布，这个画布分割了 N x M 个方格，N是它的宽度，M是它的高度。宽高都可以任意设置，所以说viewport是虚拟的。假设设置宽度是400，那么浏览器显示区域的横向将被分为400份，CSS的1px占的宽度就是显示区域的 1/400。如果是980，那就是1/980。 viewport = 500 viewport = 900 viewport取不同值时，对布局会产生影响，很明显900的布局缩小了。例如我们只分析用户头像的图片，已知头像宽度是50px。 当viewport宽度为500时，屏幕横向被分为500份，每份1px，所以头像宽度是屏幕的1/10。（500/50=10） 当viewport宽度为900时，屏幕横向被分为900份，每份1px，所以头像宽度是屏幕的1/18。 （900/50=18） 所以，在CSS中，1px是指viewport中的一个小方格，而viewport宽度是可以任意设置的。 怎么合理设置viewport的宽度？viewport的宽度可以是数字和字符串”device-width”。device-width指设备宽度。 当取值为数字时，指不论是什么手机屏幕，viewport都被分为那么多份 当取值为device-width时，指的是手机屏幕的viewport宽度被设置为跟手机宽度一样。 因为很明显device-width的宽度值单位是CSS像素。所以当viewport设置为device-width时，我们必须明白一个概念就是：DevicePixelRatio DevicePixelRatio定义如下： window.devicePixelRatio = physical pixels / dips 分母dips全称为device-independent pixels，译为与设备无关像素。 更通俗的说应为与物理像素无关的CSS像素。 devicePixelRatio说白了就是手机的物理像素与实际使用像素的缩放比。 例如：某台安卓手机，分辨率是 1920*1080，屏幕对象线是5英寸。那么在这台手机上1个CSS像素，占了多少个物理像素？ 第一步：勾股定理算出对角线的分辨率，即 √(1920²+1080²)≈2203px 第二步：算出dpi。对角线的分辨率/对角线英寸 = 2203/5≈440dpi 第三步：得出转换系数。根据上面的图片，安卓手机440dpi，属于XXHDPI，转换系数是3 因此这台手机中，1个CSS像素 = 3*物理像素。即1个CSS像素占了3个物理像素。 这个转换系数，也等同于dpr，设备像素比。 该台安卓手机的device-width是1080/3 = 360，即viewport的宽度是 360 CSS像素。 注意devicePixelRatio并非是一个默认值。在默认情况下CSS像素是由手机默认的缩放决定的。但同时因为浏览器页面也可以被人为的进行缩放。比如iPhon4中默认的分辨率宽度为320px。浏览网页时我们完全可以自行放大两倍为160px。这样以来window.devicePixelRatio就变味了 640 / 160 = 4。通过改变dips而改变dpr. 多屏适配布局问题？业内比较流行的做法（参考阿里的flexible）阿里的flexible 基于rem的原理，针对不同手机屏幕尺寸和dpr动态的改变根节点html的font-size大小(基准值)。 设置viewport为设备宽度（这里不一定，但目前先这样足矣） 将viewport分成10rem，并计算出1rem在当前浏览器的像素值，把它赋予html标签的font-size（分成10rem只是为了方便计算而已,同时为了以后vw和vh） 写CSS代码时，遇到要适配的地方，比如width，margin，padding等，就不要再用px了，改成用rem 最后字体大小问题，一般还是基于dpr使用px 对于字体缩放问题，设计师原本的要求是这样的：任何手机屏幕上字体大小都要统一，所以我们针对不同的分辨率(dpr不同)，会做如下处理：1234font-size: 16px;[data-dpr=&quot;2&quot;] input &#123; font-size: 32px;&#125; (注意，字体不可以用rem，误差太大了，且不能满足任何屏幕下字体大小相同) 参考文章 移动适配-移动Web怎么做屏幕适配（三） 浅谈移动Web开发（上）：深入概念 移动端高清、多屏适配方案]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[爆裂鼓手观后感]]></title>
      <url>%2F2016%2F12%2F18%2F%E7%88%86%E8%A3%82%E9%BC%93%E6%89%8B%2F</url>
      <content type="text"><![CDATA[前言：比你牛逼的人比你还努力！！！ 首先这部电影在评价上有很多分歧，但是大家基本都认为这是一部还不错的电影，不管是技巧和艺术价值上。有巨大的分歧，说明电影让观众得到了不同的感受，这是成功的。正如一千个读者就有一千个哈姆雷特。 其次，我个人认为追求价值和梦想时，背后往往是黑暗、孤独等很多负面的东西，因为现实往往是残酷的。这点是大多数人应该认可的，当然不乏有天赋的人并没有经历这残酷的事实同样也获得个人价值的提升，但是有天赋的人毕竟是少数。 最后对我而言，让我觉得大多数的人（包括我自己）对梦想和个人价值的追求根本谈不上努力，看看安德鲁就知道了，那是要付出血的代价！！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[科班狗的前端之路]]></title>
      <url>%2F2016%2F11%2F05%2F%E7%A7%91%E7%8F%AD%E7%8B%97%E7%9A%84%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF%2F</url>
      <content type="text"><![CDATA[前言：面试成功后余老师希望我和大家分享一下个人经历，群里也有很多朋友私信我，希望分享一下个人学习经历，所以自己单独写一篇文章和大家一起学习交流。才疏学浅，菜鸟一只，求轻拍！！！ 一、前端学习之路我是今年毕业的科班狗，大学“不务正业”对MOOC感兴趣，从而接触到前端开发。最开始是看视频学习，后面发现视频学习太慢了，上万能的知乎寻找学习方法，发现这个零基础的前端开发初学者应如何系统地学习的回答 ，也是这个回答了解到FCC，所以是缘分啊。其次觉得需要通过实际动手操作来获得提高，所以找到百度前端技术学院，这里面的项目真的很好，由浅入深地在实践中掌握技术，基本可以掌握了解、认识、学习、掌握HTML、CSS和JavaScript。最后通过余老师的在上面的回答了解到FCC，真是大开眼界，里面课程丰富、教学合理、理念优秀。另外建议看看余老师的知乎专栏，构建自己散乱的前端知识体系并且从中提高自己在其中的不足。 二、求职1.简历私信时有同学说，我刚毕业没工作经验，简历压根没人看。是的，我刚开始也是这样，一周内根本没人搭理我。所以简历在撬开面试的大门很重要，它可以理解为敲门砖，公司招聘时人事应该是通过技术主管的要求去筛选简历，即使你很有实力，但是人事找不到相关要求关键词的话，抱歉你可能连面试的机会都没有。 简历不能写什么？通过招聘信息总结，看看大部分招聘公司不喜欢的招聘要求有哪些。例如，社会招聘中你写应届生，可能就没什么面试机会。有的同学说我不想说谎，是就是，不是就不是，我承认诚信很重要，但是这个社会招聘环境就是这样，如果你不能改变它，就只能适应它。不说谎，你可以取巧，例如要求计算机相关专业出身，结果你是文科，那么我建议你不写专业，就写学历和毕业院校，这是避免短处。 简历写什么？同样的方式，看看招聘公司需要哪些技能并且与自己匹配，如果有就写上去，突出自己的能力。另外具体如何去书写，请看看余老师的文章前端开发者如何写好简历 总结：简历内容需要扬长避短，突出自己的特长，一句话就是吸引HR的眼球打开面试大门。 2.招聘网站下面的回答内容针对招聘网站有很详细的说明，建议大家可以看看。我个人使用智联招聘、前程无忧、拉钩、猎聘和boss直聘。其中智联和无忧可以海投，好处简单粗暴，坏处是针对性不强效率不高。拉钩针对有一定工作经验的应聘人会好一些，但是也有一些机会，所以不能放弃。另外，个人建议使用招聘网站的个人服务，比如花钱简历置顶什么的，还是会增加面试的机会的。boss直聘针对移动端，比较方便，而已可以和招聘主管直接沟通，针对性很强，效率很高。找工作，我建议基本都可以去使用和投递。 找工作是去智联招聘、前程无忧，还是 58 、赶集？ 三、面试首先推荐一篇文章，写的真的很好，文章提供一种很好的面试思路，你不必完全按照里面的技巧去使用，体会里面的面试思维方式并且举一反三。我自己面试基本遇到的都是这些问题，不过形式大同小异，所以大家理解这里的思路足够了。一般来讲是人事进行初面，就是大概了解你的基本素养和让你做面试题，例如你表达和沟通能力，但是也有公司是技术主管直接面试。谁面试没有关系，首先你和公司是一个平等位置，你有权选择他，他有权选择你，自己不要觉得弱势，保持你的自信，大声说出自己的名字，清楚说明每一句话。 1.自我介绍相当自豪介绍自己的基本情况，在这个问题里，你要体现自己的优势部分，例如我大学成绩优异，我获得什么编程比赛好名次之类的。 2.项目描述如果你实际项目经历，面试官希望你大概描述项目基本情况，项目的周期，项目团队人数，你的项目职责，个人而言项目中遇到什么问题，是怎么解决的。回答要体现自己的主动性和团队协作能力。如果是你自己的项目，给面试官展示一下，这样面试官方便向你提问（不然面试官也是不知道问什么，最怕空气突然安静），描述自己项目基本情况，运用哪些技术，自己如何解决遇到的问题，这部分自己写的代码基本没什么问题。 3.离职原因一个基本原则：不要说前公司不好（即使有，还是不要说） 其他理由，1.项目团队解散。2.女朋友 3.公司搬家 4.技术问题会就是会，不会就是不会。但是建议不会的部分，如果有机会，可以当场让面试官给你解答，体现对知识渴望和敬畏，每次笔试完，你可以拍照不会的问题，回去自己看看哪里不会。 5.个人发展规划这个看似开放，其实不然，千万不要说做管理什么之类。说发展规划，只是想知道你是否清楚明白自己在接下来往哪个方向走。前端你可以说，我想看看框架的源码、深入学习JavaScript语言、想去了解数据可视化等等之类，体现自己对前端知识深入了解程度和追求。 6.对公司有什么想要了解的自己千万不要说没有。问清楚公司的团队有多少人，主要做什么，这个岗位的职责是什么，现在的系统有没有上线，Boss是什么背景，公司的发展规划是什么。差不多问2个问题，这样体现你自己的水平。 7.期望薪水和入职时间期望薪水：给出一个范围，最高你希望多少，最低可以接受多少。不过一般而言，人事如果给你发offer,基本会在最低的要求上加一些，一般1K不等。 入职时间：给个准确入职时间，公司当然愿意你越早越好，这个看自己情况，如果想晚点，自己说明合理的原因获得人事同意，以公司意愿为主。 8.个人建议面试时，注意面试官的表述语句，你需要从中抓取关键信息，看看公司具体的需求，自己的回答得基本满足公司的需求，比如：你现在住哪里？你的回答应该围绕你不会影响你上班时间和对工作影响。还有就是，注意观察面试官的肢体动作和微表情，这些能体现他对你的回答的反馈信息，例如，你在回答时面试官一直翻阅简历，估计对你的回答不够满意，或者面试官一直和你有眼光交流，那你回答很对他的口味，哎呦，你有戏哦。 技术面试的时候该怎么样介绍自己？ 四、个人体会找工作还是蛮辛苦，不过话说回来，有什么事情是不辛苦的吗？首先一开始可能很困难，但是自己要相信自己，在每次面试后总结分析自己的问题，其次坚持下去，别放弃（鸡汤味有点浓了~~~），最后希望学习前端的同学们找到自己的理想工作！ 五、参考链接知乎 零基础的前端开发初学者应如何系统地学习? 找工作是去智联招聘、前程无忧，还是 58 、赶集？ IT修真院-xdyl 技术面试的时候该怎么样介绍自己？ 百度前端技术学院 百度前端技术学院 余博伦 知乎专栏 前端开发者如何写好简历]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F11%2F05%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
