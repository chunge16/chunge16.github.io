<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[杭州游记]]></title>
      <url>%2F2017%2F05%2F22%2F%E6%9D%AD%E5%B7%9E%E6%B8%B8%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[前言欲把西湖比西子，淡妆浓抹总相宜。 其实现在回想起来，其实不知道自己怎么就决定来杭州？我真的不知道，好像就是一个突然的想法，然后大致计划了一下。没什么重要的理由，有时候真的好像不需要理由吧，理由这东西更多的时候是给自己一个安慰和借口罢了。 第一天为了赶早上8点多的火车，我6点就起来收拾行李。其实就一个背包而已，重量还不到5斤左右，所以早早就出发了。 北京6点多的地铁人还是挺多的，虽然难得有座位，但是想到火车上又要坐那么久，所以就没有坐。赶车总是无聊的，闲没事看看周围事物打发一下时间，可能大家都起得早，所以普遍都是睡眠不足。只见有的人向后靠背，仰面朝天张大了嘴，看起来实在滑稽可笑。 由于距离发车还有一段时间，所以就自顾找了个地方吃早饭，稀里糊涂点不怎么喜欢的美式咖啡和三明治，果然没吃完。看来我是和文艺气息浓郁的咖啡注定无缘了。 火车晚了20分钟才到达杭州东站，虽然杭州也是和北京差不多的热，但是有所不同的是多了些湿热。 至此，我是真的到杭州了。我的杭州之游算是开始了。 杭州图书馆 我去到每个地方，都会特别想看看当地的图书馆，我是觉得图书馆能够一定反映这个地方文化和历史，另外我喜欢图书馆的安静，走走看看你的心自然而然静下来。当然图书馆自身就是设计出众的建筑艺术，也是值得看看的。如果你来杭州又喜欢安静的地方，我会推荐你去杭州图书馆，而且一楼的面包店很不错哦，特别是蛋挞！ 京杭运河 心满意足的欣赏杭州图书馆后，出发下一个地点：京杭运河。从武林门码头坐水上巴士去拱宸桥，可以沿途看运河的夜景。确实很漂亮，下船沿着河边散步，感受一下江南水乡的模样。一路上有很多咖啡馆、工艺品店和一些博物馆。在江南水乡由于水路众多，所以船是一种重要的交通工具，虽然杭州已经是交通现代化的城市，但是水上交通依旧还是生生不息。 龙翔桥商圈这个时候天已经黑了，肚子不争气叫唤起来。得找个地方吃东西，推荐骑个单车大致沿着运河南下，如果你喜欢时尚、购物和逛街之类，推荐杭州最繁华的龙翔桥商圈，银泰在附近，基本都是一些奢侈品商店。另外亚洲最大的苹果直营店也是在那里而且就在西湖边上。 其实西湖晚上人还是挺多的，毕竟晚上比白天凉快一些。很多本地人和游客都会选择夜游西湖，我从西湖北面的白堤出发，由于是晚上11点左右了，所以只是走完了白堤就回旅馆了。西湖白天和晚上完全是不一样的景色，晚上西湖是另外一种美丽。 第二天环游西湖 由于昨天晚上并没有欣赏到西湖全景，所以决定早点起来去环游西湖。骑着单车迎面吹来微凉的风的同时还可以一路观赏西湖的美景，真是安逸惨了。我是从北山路的白堤出发，然后回到起点，环游西湖一圈。白堤早上那会会有许多大爷放风筝，白堤过去后就是孤山，孤山上有当初乾隆皇帝为六下江南而设立的行宫，而后就是苏堤。其实很可惜，我也是第一次去西湖，后来才发现西湖一路上的博物馆、名人故居、公园、寺庙，名人墓地和好山好水等等太多了。我所见到的不过是冰山的一角而已。如果大家时间够多，建议一路慢慢浏览，时间比较紧的话，可以挑选自己比较喜欢的地方。 浙江美术馆 走过苏堤后，来到南山路你就会看见人突然多了起来，因为来到了雷峰塔景区。一走进景区大门，假石头伪装的音响不断响起熟悉的旋律：“千年等一回等一回啊~ 千年等一回我无悔啊~ ”，不过我还是喜欢《渡情》，就是那个：“西湖美景三月天哪，春雨如酒柳如烟哪”。由于我不是很感冒加上人太多了，我就在外面看看了雷峰塔，雷峰塔现在是多次修复而成的，听说里面很现代化，所以反而失去古塔的韵味。人们多少都是因为《新白娘子传奇》而熟知雷峰塔。而我直接去了我特别期待的 浙江美术馆。 自己运气还不错，刚好正在展览刘墉老师的书画，展览主题是 书卷江山，虽然我看不懂，不过确实很好看啊，中国的山水画拥有特殊的想象力。 西湖博物馆 浏览完了美术馆后，来到西湖博物馆。既然来到西湖，我们应该知道西湖的历史发展，而西湖博物馆将全面介绍西湖历史来源发展，让自己对西湖有更深的认识。建议大家来到西湖，都应该去参观一下西湖博物馆。 六合塔 之所以没去雷峰塔，是因为我发现 六合塔，相对雷峰塔的声名远播，六合塔估计很多人都不知道，但是确实值得一看，它位于钱塘江边，你可以登上塔顶位置俯瞰钱塘江美景。 六和塔位于西湖之南，钱塘江畔月轮山上。北宋开宝三年(公元970年)，当时杭州为吴越国国都，吴越王为镇住钱塘江潮水，派僧人智元禅师建造了六和塔，现在的六和塔塔身重建于南宋。取佛教“六和敬”之义，命名为六和塔。六和塔又名六合塔，取“天地四方”之意。 浙江大学（之江校区） 浙江大学之江校区前身是之江学院，如今是浙江大学光华法学院校舍。整个校园沿着钱塘江边的之江路依山而建，有保存相当完整的近代大学建筑群，被称为“杭州最美的大学校园”。这里游客很少，是拍照散心的好去处。 它绝对能进中国最美大学前十，有保存相当完整的近代大学建筑群，获“世界近代学府建筑完整保护建筑”第二名。 这是一座建在山中的学校，依山傍水，景致优美，这里哪是大学，分明是山中的秘境公园。 音乐喷泉 打字好累啊，之后大哥我一人骑了10公里回到起点，来看西湖边上的音乐喷泉，结果人超级多，还得安检进去。7点和8点各有2场，每次15分钟，大概3首歌左右。如果你想获得观看的最佳视野，你得提前2个小时来才行哦。 晚上手机拍不好，我盗图给你看看吧 宝石山 在西湖边上的北山路有座宝石山，推荐晚上爬山去看西湖夜景，包你满意。喜欢图书的爬山你会路过一个叫纯真年代的书店，值得一看。最重要的是人都超级少，不会有人打扰你安安静静的欣赏西湖的美丽。 手机拍得太烂了，实在是体现不出西湖夜晚的美，我又盗图了。。。 结尾到此我的杭州之旅结束了，我一次冲动的决定，冲动的出发，但是好像没有冲动的惩罚，反而结局还是不错的。有时目的性太强的旅行会失去旅行的意义。 我去旅行，是因为我决定了要去，并不是因为对风景的兴趣。– 加西亚-马尔克斯]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ASCII，Unicode和UTF-8 (Charset and Encoding)]]></title>
      <url>%2F2017%2F05%2F19%2FASCII%EF%BC%8CUnicode%E5%92%8CUTF-8-Charset-and-Encoding%2F</url>
      <content type="text"><![CDATA[前言：相信很多人都听说过ASCII，Unicode和UTF-8这些词汇，但可能还是不清楚其中的具体含义。当然一开始我也是粗略认识，所以自己决定重新深入学习一下，并且总结如下。 才疏学浅，多多指教！！！ 一、历史渊源关于历史来源，在此引用前人的总结，写的很清晰明了。自己截取其中主要部分并且加以修饰一下，正文如下： 很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们看到8个开关状态是好的，每个于是他们把这称为”字节“。再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为”计算机“。这就是计算机来源，每个晶体管只有0和1两个状态。现在计算机，8位二进制通常被称为一个字节，这是计算机最小存储单位。 计算机是美国人发明的。八位二进制一共可以组合出256(2的8次方)种不同的状态。 他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作。遇上0×10, 终端就换行，遇上0×07, 终端就向人们嘟嘟叫，例好遇上0x1b, 打印机就打印反白的字，或者终端就用彩色显示字母。他们看到这样很好，于是就把这些0×20以下的字节状态称为控制码。他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做 ANSI 的Ascii编码 （American Standard Code for Information Interchange，美国信息互换标准代码） 当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。 世界各地的都开始使用计算机，但是很多国家用的不是英文，他们的字母里有许多是ASCII里没有的，为了可以在计算机保存他们的文字，他们决定采用127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128到255这一页的字符集被称扩展字符集。 等到中国人民使用计算机后，发现没有中文怎么办呢？中国人的解决方案是：小于127号的还是继续使用，并且用2个大于127的字节表示一个中文字符，前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的 全角 字符，而原来在127号以下的那些就叫 半角 字符了。 中国人民看到这样很不错，于是就把这种汉字方案叫做 “GB2312“。GB2312 是对 ASCII 的中文扩展。 但是中文还是不够用，大家发现冷门生僻字和繁体字等等还是无法识别。于是就只是要求高字节大于127就认为是2字节的中文字符，这样结果扩展之后的编码方案被称为 GBK 标准，GBK包括了GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。但是还有少数民族同胞也需要使用电脑，于是有扩展少数民族字符，这样GBK扩成了 GB18030,从此之后，中华民族的文化就可以在计算机时代中传承了。 中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 DBCS（Double Byte Charecter Set 双字节字符集）。 但是每个国家都搞一套自己的字符编码，自己只能看自己，别人的看不来，这不符合web开放的文化啊。 正在这时一个叫 ISO（国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称 UCS, 俗称 Unicode。但是后来扩展标准，2或者4字节来表示字符编码。 Unicode开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用 两个字节 ，也就是16位来统一表示所有的字符，对于ASCII里的那些“半角”字符，unicode包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于”半角”英文符号只需要用到低8位，所以其高8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。 Unicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。目前最新Unicode标准分为17组编排，0x0000 至 0xFFFF，每组称为平面（Plane），而每平面拥有65536个码位，共1114112（65536*17）个。 但是Unicode同样也有2个问题 一、计算机怎么知道二个字节为一个字符，如何识别二个字节为什么一个字符？ 二、针对英文字符，如果使用大于1个字节来表示，那么低位的前面几个字节全是0。很奢侈浪费空间，因为现在计算机大部分内容还是英文。 二、Charset and Encoding大家了解一下历史后，应该对字符集有大致了解，那我们来说说字符集和字符编码，其实你可以这样理解： 字符集就是我们用十进制来表示世界上各种字符 字符编码就是通将十进制转换为计算机识别的二进制编码的规则 Charset (Character set) 字符集： 是对字符抽象表示的集合。包括世界上各种文字、符合和字符。 Encoding (Charset Encoding) 字符编码：建立字符集合和计算机系统对应的规则。简单来说就是，将字符转化为计算机可识别的二进制编码的规则。 三、ASCII计算机使用二进制保存指令和数据，字节作为计算接处理数据的基本单位，有256(2的8次方)种可能状态。这些状态被人们利用来标记指令和文字。最初前32(0x20)种状态被用来表示终端、打印机等设备的某些特殊动作，比如终端遇到字节0x10则换行，类似的还有回车(CR 0x0D)，震铃(BELL 0x07)等。这前32种状态又被称为控制码。除了这些特殊用途的状态外，还有256-32=224种状态没有被利用，资源浪费怎么能忍，何况除了控制指令外，咱们的文字还没有被表示。于是这些多出来的状态被用来表示文字(English Character)和符号标点等，如此这般，计算机就可以显示和记录文字了，这便是ASCII(American Standard Code for Information Interchange)最初的由来。 四、UnicodeUnicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准,包括字符集、编码方案等。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。 在表示一个Unicode的字符时，通常会用“U+”然后紧接着一组十六进制的数字来表示这一个字符。在基本多文种平面（英文为 Basic Multilingual Plane，简写 BMP。它又简称为“零号平面”, plane 0）里的所有字符，要用四位十六进制数（例如U+4AE0，共支持六万多个字符）；在零号平面以外的字符则需要使用五位或六位十六进制数了。Unicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。目前的Unicode字符分为17组编排，0x0000 至 0xFFFF，每组称为平面（Plane），而每平面拥有65536个码位，共1114112个。然而目前只用了少数平面。UTF-8、UTF-16、UTF-32都是将数字转换到程序数据的编码方案。 通用字符集（Universal Character Set, UCS）是由ISO制定的ISO 10646（或称ISO/IEC 10646）标准所定义的标准字符集。UCS-2用两个字节编码，UCS-4用4个字节编码。 UCS-4根据最高位为0的最高字节分成27=128个group。每个group再根据次高字节分为256个平面（plane）。每个平面根据第3个字节分为256行 （row），每行有256个码位（cell）。group 0的平面0被称作BMP（Basic Multilingual Plane）。如果UCS-4的前两个字节为全零，那么将UCS-4的BMP去掉前面的两个零字节就得到了UCS-2。每个平面有216=65536个码位。Unicode计划使用了17个平面，一共有17×65536=1114112个码位。 UTF(Unicode Transformation Format), Unicode字符集的编码方式，主要有UTF-8，UTF-16，UTF-32等。由于UTF-32采用定长四字节编码，这里不多说，下面主要介绍UTF-8，附带介绍UTF-16。 UTF-8UTF-8是变长编码，使用1~4个字节来表示一个字符，UTF-8的特点是对不同范围的字符使用不同长度的编码。 单字节表示对应Unicode码点0x0000-0x007F的字符，且此时首位为0，有效位7位，也就是说可以表示27=128种字符，这部分其实刚好兼容了ASCII编码规则，而Unicode0x0000-0x007F的字符也就是ASCII字符。 双字节表示对应Unicode码点0x0080-0x07FF的字符，且此时第一个字节以110开头，后面的字节以10开头，有效 位数为11位，可以表示2048种字符。其实由上图可以看到UTF-8变长编码的规律，为了让计算机知道以几个字节来断句（即翻译为一个字符），在首字节的前几位就有几个1，例如如果是双字节断句，则首字节开头以110，如果是三字节断句，则首字节以1110开头。 三字节表示对应Unicode码点0x0800-0xFFFF的字符，有效位为16位，可以容纳65536种字符，我们常用的中文字符也都落在三字节部分。因此UTF-8是以三个字节来表示常用汉字字符的，当然实际上汉字有将近十万个，65536无法容纳如此庞大的汉字体系，因此有些冷门汉字只能用四字节表示了。我们知道Unicode将人们常用的字符都放在BMP平面（U+0000-U+FFFF），而至此，UTF-8已经用1-3个字节表示了BMP平面的全部内容。 例1：“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将0x6C49写成二进制是：0110 1100 0100 1001， 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。 UTF-16UTF-16是以二字节或四字节表示一个字符的变长编码。Unicode在BMP平面的字符（U+0000~U+FFFF）用二字节来编码，其余字符用四字节来编码。对于二字节编码部分直接用码点值来编码，四字节编码部分的转换规则这里不再详述。我们只需记住常用的中英文字符在UTF-16中使用二字节表示即可。 乱码编码方式不兼容会导致乱码。例如，编码A和编码B采用不同方式来编码，当一个文件使用编码A在只有编码B的设备上解码时候，肯定是乱码，因为不识别啊。打个比方，抗张谍报的密码本，每次传递情报需要使用不同的密码本来解密，但是你用错了，当然翻译的内容是错乱的，读起来肯定不通顺。 文笔有限，才疏学浅，文中若有不对之处，还望告知。 参考链接 Charset and Encoding Java字符的编码解码与乱码问题 Unicode 和 UTF-8 有何区别？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[地下通道]]></title>
      <url>%2F2017%2F05%2F16%2F%E5%9C%B0%E4%B8%8B%E9%80%9A%E9%81%93%2F</url>
      <content type="text"><![CDATA[前言： 地下通道中一束光照射在路人身上，如同地狱中的希望之光。-《地狱》 地下通道这个地下通道其实很普通，它不过是这个城市渺小的一部分。但是我每天下班回家都会穿过这里到对面街道上去，所以对他格外熟悉一些。 每次走近通道向下阶梯的时候，人们的脚步声会变得清晰起来，熙熙攘攘的脚步声再次提醒我这是下班时间。不知道为什么，下班的时间里不管是年轻人还是人到中年的大叔和阿姨，大家都喜欢戴上耳机，不过有的人喜欢把放音乐的手机拿在手里、有的喜欢放在裤子前面的裤兜而女士一般都是放在包里，好像戴上耳机后可以短暂隔离这个世界，从而获得自己的空间和时间。 当然可能并且没那么复杂，可能只是简单的想通过音乐来消去一天的疲惫而已。其次还有一个现象比较奇特，就是不管男女老幼背书包比例比较大。小朋友书包里的课本和作业，对于大部分的小朋友来说都不感冒，我们童年的回忆里，没人会说作业和课本是美好的记忆吧。但是大人背包里的东西可能对他们的工作和生活都很重要，对他们而言没有讨厌、排斥的说法。 最后还有一个现象就是大家下班回家的步伐都是那么匆匆，有句话是这么说：“这个城市发展的速度，从人们走路的步伐就能看出来”。嗯，北京发展的节奏看来还是很迅速的。 我总想放慢自己步伐缓慢的回到家，但是每次穿过这个地下通道，当身边的人们行色匆匆的时候，我总会下意识的身子前倾、加快步伐而且用手把耳机塞得更紧一些了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[开发者关系大会的思考]]></title>
      <url>%2F2017%2F05%2F14%2F%E5%BC%80%E5%8F%91%E8%80%85%E5%85%B3%E7%B3%BB%E5%A4%A7%E4%BC%9A%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
      <content type="text"><![CDATA[参会经历说来惭愧，5月6日参加的大会，到现在才想起写一些东西。不过没关系，不要在意细节问题。。。我是通过FCC的微信公众号了解到这次活动，看了演讲的嘉宾的基本介绍，个人很是期待。感受一下高质量的技术交流，虽然我全程划水。。。 会议的举办给人严谨和有序的感觉，我第一次参加这样的IT活动，还是有些激动的。给活动组织者们点个赞，特别说明活动的下午茶真的特别赞，不要误会，我去之前不知道有下午茶而且这么丰富，我是抱着学习的态度去的，真的。 布道师的疑惑 七牛云首席布道师何李石老师提到“布道师”这个词汇，应该是我孤陋寡闻，我是第一次听到这个词，当时听老师演讲时候不是很明白到底是什么含义，回来之后自己大致了解了一下。 百度百科的解释：“技术布道是随着IT产业的兴起而兴起的职业。与传统的“宣传推广”不同，它是针对特殊产品、面向特殊人群、采用特殊方法进行“宣传推广”，百度百科解释还是一如既往的深刻晦涩。 布道这个词最早来源宗教，为了推广教义和宗教信仰，信徒们到处传播和推广，而他们就是扮演着布道师的角色。 什么是布道师？我觉得可以简单理解为“技术的传播者”。那这个职业存在的意义是什么呢？后来看过腾讯云的布道师贺嘉老师的文章，他的解释让我更加理解这个问题的答案。 布道师的价值在于消解技术复杂度，降低用户认知成本 如果你在公司内外部尝试推进react或是node.js这样的新技术，内外部的其他技术人员可能会这样回答你：“用了有啥好处？”、“你的技术能解决问题么？”、“不愿意换，现在的技术挺好的”。那么布道师就要去解答这些困惑并且让大家感受到新技术的魅力。 寄望人工智能(AI) CSDN创始人蒋涛老师演讲内容关于AI，最近几年时间里人工智能非常活跃，特别是IT巨头Google有意识推广人工智能概念。一场围棋比赛，把全世界的目光一下子吸引到“人工智能”这个热点上面，AlphaGo（阿尔法）战胜人类的消息，让大家吃惊不已。 并且5月23日，谷歌人工智能DeepMind的急先锋AlphaGo2.0，将披挂上阵，与人类最强棋手——柯洁，展开三番棋的较量。我有点替柯洁担心啊。 其实关于人工智能的想法很早之前就存在，并且那个时候就已经表达了对人工智能的担忧，人工智能到底对人类是敌是友？大家应该特别熟悉机器人三定律。1942年，阿西莫夫在短篇小说”Runaround”（《环舞》）中首次提出了三定律： 一 机器人不得伤害人类，或因不作为使人类受到伤害。 二 除非违背第一定律，机器人必须服从人类的命令。 三 除非违背第一及第二定律，机器人必须保护自己。 那个时候更多是对人工智能的担忧，认为它会对人类社会发展造成破坏。大家应该还记得电影 《终结者》 系列机器人破坏人类文明，《黑客帝国》 系列人类被智能控制而苟活，它从侧面再次反映人们对人工智能技术的担心甚至是反对。 而为什么今天反对的声音越来越弱呢？我想科技发展给人们带来实际有效的便捷，说白了就是尝到了甜头。我对人工智能是持开放的态度，科技发展必定是服务人类社会，它是社会发展的重要推动力。 当然，发展的过程中同样有许多问题产生，例如科技让人类缺乏真实的社交和沟通，网络世界让许多人沉沦，科技发展让人慢慢失去了人类的本性。我想说的是，我们应该包容，新生事物的发展必然会产生一系列的问题，但我们不应该全盘否定，合理分析控制让人工智能成为推动人类社会发展的新动力来源。 现在很多互联网公司都把 人工智能 当做下一个科技发展的浪潮，让我们一起期待寄望那个时代的到来吧！ 图片大部分来源：猿生态开发者社区，侵删。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[汶川大地震9周年忆]]></title>
      <url>%2F2017%2F05%2F12%2F%E6%B1%B6%E5%B7%9D%E5%A4%A7%E5%9C%B0%E9%9C%879%E5%91%A8%E5%B9%B4%E5%BF%86%2F</url>
      <content type="text"><![CDATA[前言 都说傻瓜最快乐，因为傻瓜什么事情都不会放在心上。 可能很多人都忘记9年前的今天一场大地震突然降临在四川，短短几分钟夺取几万人的生命。汶川大地震已经过去9年了，但它不能被遗忘，也不应该被遗忘。 那个下午我中午偶然看见一位四川老乡的朋友圈，当我看见汶川二字时，我急忙看看今天的日期。5月12日，汶川大地震都过去9年了啊，但是当我看见汶川二字的时候，时间一下子把我拉回2008年5月12日-14时28分那个时刻。 那一年到现在我都记得特别清楚，初中我在教室睡午觉，突然感觉桌子在晃动，一开始只是轻微的，我以为是前面同学在捣乱，但是后面越来越剧烈，看见水杯里的水急剧震荡，大家才发现不对劲。在此，我想特别向我初中历史老师致敬，她指挥大家有序跑出教室，最后自己才跑到空旷的地带。在生命的危急关头，老师她把学生放在第一位，只是但是大家被吓傻了，跑下来才知道老师还在里面，想回去找她时被其他老师拉住，最后看见老师她安全下来，班上很多女同学都哭了。 很可惜，我不记得老师的名字了，很惭愧。但是我9年后还记得你当初勇敢的为保护学生而做出的无私行为，在那一刻你是英雄和伟人。 后来恢复上课，大家商量历史老师来上课，大家全体起立向老师鞠个躬。我还是记得很清楚，老师哽咽了一会，眼泪不断留下，强忍住自己的眼泪对大家说了一声“谢谢”，当然大家都哭个不停。那个时候，才发现原来老师和学生是可以走到对方的心里的。那一年应该是我哭的最多的时候，实在是忍不住啊。 生命可贵这场灾难让我觉得生命真是伟大又可贵。地震带给人不单是痛苦，其实还有很多感动。我记得当时余秋雨老师说过，在那个时候他看见了中华民族的伟大。全国人们乃至全世界的华人几乎疯狂失去理性的募捐，在那一刻真是验证余老师所说。 灾难总是让人性体现得无比清楚，大地震让我看见了作为一个人的善良本性和一个生命的价值。背着亡妻的丈夫、抱着孩子尸体的父亲、选择救儿子放弃女儿的母亲和保护学生失去生命的老师等等。是他们用生命让我们明白作做人的基本本性和生命的价值的追求。 所以现在活着的人们应该珍惜自己的生命，因为生命太可贵了，这是用其他东西根本换不了。我们应该好好把握自己的生命，去追求和实现自己的生命的价值。 希望活着的人带着逝去的人的那份悲伤和幸福一起前进。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript的this的值到底是什么？]]></title>
      <url>%2F2017%2F04%2F29%2FJavaScript%E7%9A%84this-%E7%9A%84%E5%80%BC%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%2F</url>
      <content type="text"><![CDATA[前言JavaScript 有一套完全不同于其它语言的对 this 的处理机制。 一般有四种不同的情况下 ，this 指向的各不相同。但是有一个总的原则，那就是this指的是，调用函数的那个对象。 一、函数调用函数调用时，this指向全局对象，如果是在浏览器中中，这个对象是window。 请看下面这段代码： 12345678var fn = function() &#123; function test() &#123; console.log(this); // this 将会被设置为全局对象（译者注：浏览器环境中也就是 window 对象） &#125; test();&#125;fn() //执行函数fn，结果指向window 二、方法调用当函数作为对象的方法时，this指向该对象 请看下面这段代码： 123456789var age = 10;var xiaoming = &#123;&#125;;xiaoming.age = 18;xiaoming.getAge = function()&#123; console.log(this.age);&#125;xiaoming.getAge(); //18 之所以为18不是10，因为this指向xiaoming这个对象，所以打印出来是18 三、调用构造函数如果函数倾向于和 new 关键词一块使用，则我们称这个函数是 构造函数。 在函数内部，this 指向新创建的对象。 请看下面这段代码： 123456789var x = 0;function test()&#123; this.x = 1;&#125;var obj = new test();console.log(obj.x); // 1 打印出来为1不为0，表明this指向新对象obj，而不是全局对象。 四、显式的设置 this (apply和call)当使用 Function.prototype 上的 call 或者 apply 方法时，函数内的 this 将会被 显式设置为函数调用的第一个参数. 当第一参数为null 或者 undefined，在浏览器环境里那么window对象就是默认的this指向。123456789101112131415var age = 0;var xiaoming = &#123;&#125;;function setAge(age)&#123;this.age = age;&#125;xiaoming.age = 18;xiaoming.setAge = setAge;xiaoming.setAge.apply(null,[20]);xiaoming.age // 18age // 20xiaoming.setAge.call(xiaoming,25);xiaoming.age // 25age // 20 apply和call区别在于传递参数格式不同，call()接受一个参数列表，而apply()接受包含多个参数的数组（或类数组对象） 文笔有限，才疏学浅，文中若有不对之处，还望告知。 参考文章 this 的工作原理 this 的值到底是什么？一次说清楚 Javascript的this用法 Function.prototype.apply()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[说说Javascript原型链]]></title>
      <url>%2F2017%2F04%2F24%2F%E8%AF%B4%E8%AF%B4Javascript%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
      <content type="text"><![CDATA[前言在写复杂的 JavaScript 应用之前，充分理解原型链继承的工作方式是每个 JavaScript 程序员必修的功课。 JavaScript中并没有类（class）；Js是基于原型（prototype-based）来实现的面向对象（OOP）的编程范式的，但并不是所有的对象都拥有prototype这一属性 123456789var a = &#123;&#125;,b = 'shi';var fn = function()&#123;&#125;;a.prototype // undefinedb.prototype // undefinedfn.prototype // Object &#123;constructor: function&#125; prototype属性只有 function对象定义时才有，函数本身也是对象。想要明白原型问题我们先明白几个基本概念。 一、function、Function、Object和{} function是JavaScript的关键字，用于定义函数变量，一般有2种定义方式 123456789function f1()&#123; console.log('This is function f1!');&#125;typeof(f1); //=&gt; 'function'var f2 = function()&#123; console.log('This is function f2!');&#125;typeof(f2); //=&gt; 'function' Function是函数类型实例的构造函数（constructor）, 本质也是函数，类似还有Object或String、Number等，都是Js内置类型实例的构造函数，构造函数主要作用就是创建相应类型的实例，实现原型链。 12345var f3 = new Function("console.log('This is function f3!');"); f3(); //=&gt; 'This is function f3!' typeof(f3); //=&gt; 'function'typeof(Function); //=&gt; 'function' Object，它用于生成对象类型，其简写形式为{}，其实和function和Function的关系类似。 1234567var o1 = new Object(); typeof(o1); //=&gt; 'object'var o2 = &#123;&#125;; typeof(o2); //=&gt; 'object'typeof(Object); //=&gt; 'function' 二、prototype 和 __proto__prototype属性只有函数类型对象才有，上面说的很清楚了。而__proto__是所有JavaScript对象都内置的属性[[Prototype]]，而这个属性指向构造函数（类似父类）的prototype属性，从而继承属性. 通俗一点讲，prototype中定义的属性和方法都是留给自己的“后代”用的，因此，子类完全可以访问prototype中的属性和方法。 举个例子： 123456789101112var Person = function()&#123;&#125;; Person.prototype.type = 'Person'; Person.prototype.maxAge = 100;var p = new Person(); console.log(p.maxAge); p.name = 'rainy';// 修正Person.prototype.constructor为Person本身Person.prototype.constructor === Person; //=&gt; true p.__proto__ === Person.prototype; //=&gt; true console.log(p.prototype); //=&gt; undefined 一图胜千言 Person是一个函数类型的变量，因此自带了prototype属性，prototype属性中的constructor又指向Person本身；通过new关键字生成的Person类的实例p1，通过__proto__属性指向了Person的原型。 注意：遵循ECMAScript标准，someObject.[[Prototype]] 符号是用于指派 someObject 的原型。这个等同于 JavaScript 的 __proto__ 属性。从 ECMAScript 6 开始, [[Prototype]] 可以用Object.getPrototypeOf()和Object.setPrototypeOf()访问器来访问。 三、原型链原型链是基于 __proto__ 的。JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依此层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。 举例说明： 1234567891011121314151617// Nodevar Obj = function()&#123;&#125;; var o = new Obj(); o.__proto__ === Obj.prototype; //=&gt; true o.__proto__.constructor === Obj; //=&gt; trueObj.__proto__ === Function.prototype; //=&gt; true Obj.__proto__.constructor === Function; //=&gt; trueFunction.__proto__ === Function.prototype; //=&gt; true Object.__proto__ === Object.prototype; //=&gt; false Object.__proto__ === Function.prototype; //=&gt; trueFunction.__proto__.constructor === Function;//=&gt; true Function.__proto__.__proto__; //=&gt; &#123;&#125; Function.__proto__.__proto__ === o.__proto__.__proto__; //=&gt; true o.__proto__.__proto__.__proto__ === null; //=&gt; true 来张图更直观一些 到了这里，其实有个问题大家没注意，new关键词到底起了什么作用呢？ 其实开头的图已经给出答案：new关键词的作用就是完成上图所示实例与父类原型之间关系的串接，并创建一个新的对象.简单来说，new就是把父类的prototype赋值给实例的__proto__ 有兴趣深入看这里：JS 的 new 到底是干什么的？ 文笔有限，才疏学浅，文中若有不对之处，还望告知。 参考文章 继承与原型链 原型 图解Javascript原型链 关于js中,原型对象，原型链，构造函数，实例之间关系的理解与区别]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《一念无明》的感触]]></title>
      <url>%2F2017%2F04%2F16%2F%E3%80%8A%E4%B8%80%E5%BF%B5%E6%97%A0%E6%98%8E%E3%80%8B%2F</url>
      <content type="text"><![CDATA[一念无明，如坠地狱；众生皆苦，万念皆空。 其实每个人都有病，只是你自己不觉得而已！ 关于电影名“一念”来自佛家的说法，是指人不断产生的念想，“无明”是看不见，看不清楚。人们的想法最终导致人性的迷失，从而不断的产生矛盾和伤害。 对于这个电影名，导演自己之所以选择用“一念无明”作为片名，是希望以此呈现片中人物之间的状态：“他们都是爱对方的，他们都不是外人，电影里面我自己觉得没有外人”，但正是这样的一群人，因为无法看清自己，看清他人，看清人生，最终却在不停地互相伤害，“他们互相伤害的时候就是‘无明’的，看不清楚他真的要做什么。” 电影最后字幕用《小王子》的一句话来提醒观众: “只有用心才能看得清楚，真正重要的东西，用眼睛是看不见的”。 因果循环佛家一般讲究 “天地万物，因果循环”，一切有始有终。 母亲把失败婚姻和悲剧人生的怨念，无情地抱怨发泄在身边唯一亲人并且照顾自己的阿东的身上。父亲的逃避、母亲抱怨最终让阿东躁郁症的爆发并且让自己未婚妻的人生陷入谷底。阿东出院后，本来想和未婚妻和好如初，但是未婚妻的愤怒和仇恨让阿东再次病发。照顾发病的阿东，让父亲身心憔悴，父亲此时终于尝到当初自己对亲人的伤害的滋味。自己身边最亲近的人就这样互相伤害，让其中每个人都陷入无尽的伤痛。 从阿东的家庭来看，其实具有普遍性。基本每个人都能从这个家庭找到自己的影子，因为你也是父亲，母亲或者是父母的儿女。 阿东的父母应该是比较极端的，阿东从小几乎没有父母的爱和呵护，这个家对他而言似乎无关，家庭的冷漠导致阿东的人格缺陷。但是这样类似的悲剧在中国的家庭都曾经上演过，可能是中国儒家文化的根深蒂固，中国的父母缺乏和孩子的交流，一句“我是为你好”就可以完美的表达父母对孩子的爱，但问题是孩子自己接受吗、快乐吗、同意吗？这就是问题所在，父母认为我是为孩子着想，但是结局往往都是悲剧。 那些离家出走、跳楼自杀和绝望痛哭的孩子，社会对这些孩子的评价总结起来基本都是没出息，从来没有人去质问父母的问题，把问题产生的原因归结于孩子的身上。 人性的一面人和动物最大的区别，应该是人有着丰富的感情。 从社会角度去看，电影描述一个近乎“吃人”的香港社会，随着城市的高速、现代的发展，人这个物种似乎慢慢失去了情感，甚至变得麻木。孤独是现在描述“空巢青年”用得最多的词汇，因为城市的现实社会给人孤独感，陌生感和冷漠感。 科技进步和城市的发展带给人们物质的提升和享受，但是同时也改变了人的本质，我们失去了作为一个生命的价值，似乎作为一个人的价值慢慢从生命里流逝。 网络时代，大家把自己情绪和感情投入在虚拟的世界里，导致现实世界人性的缺失。都是去虚拟的世界学做人，反而在真实的世界忘记自己是人了。 问问自己，你有多久没有和你最亲近的人面对面的交流了呢？ “那时，我还没弄懂人性是如何矛盾，我不知道真诚中有多少做作，高贵中有多少卑鄙，或者，邪恶中有多少善良。”“如今我是充分懂得了，小气与大方、怨怼与仁慈、憎恨与热爱，是可以并存于同一颗心中的”－－《月亮与六便士》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初识JavaScript闭包]]></title>
      <url>%2F2017%2F04%2F02%2F%E5%88%9D%E8%AF%86JavaScript%E9%97%AD%E5%8C%85%2F</url>
      <content type="text"><![CDATA[前言：学习JavaScript的时候老是听说闭包，感觉他很厉害的样子，所以就来会会他吧！ 闭包是什么？闭包是指有权访问另外一个函数作用域里的变量和参数的函数 闭包的特点以及优缺点特点 函数嵌套函数 函数内部可以引用外部的参数和变量 参数和变量不会被垃圾回收机制回收 一般函数执行结束后，局部变量会被销毁（垃圾回收机制所回收），内存只会保存全局作用域的变量。 但是闭包就不同了，闭包会使变量继续保存在内存里，当然如果使用不当会增大内存使用量。 12345678910function aaa() &#123; var a = 1; return function()&#123; alert(a++) &#125;; &#125; var fun = aaa(); fun();// 1 执行后 a++，，然后a还在~ fun();// 2 fun = null;//a被回收！！ 优点 希望一个变量长期驻扎在内存中 避免全局变量的污染 私有成员的存在 缺点 闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。 循环中的闭包一个常见错误是在循环中使用变量，我们看个例子： 1234567891011121314function count() &#123; var arr = []; for (var i=1; i&lt;=3; i++) &#123; arr.push(function () &#123; return i * i; &#125;); &#125; return arr;&#125;var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2]; 你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是: 123f1(); // 16f2(); // 16f3(); // 16 原因很简单，当你执行返回的函数时，闭包继续保持对变量i的访问，此时for循环已经结束并且i = 4,所以结果都是16。 为了得到想要的结果，需要在每次循环中创建变量 i 的拷贝。为此我们一般采用自执行匿名函数 1234567891011121314151617181920function count() &#123; var arr = []; for (var i=1; i&lt;=3; i++) &#123; arr.push((function (n) &#123; return function () &#123; return n * n; &#125; &#125;)(i)); &#125; return arr;&#125;var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2];f1(); // 1f2(); // 4f3(); // 9 自执行匿名函数 创建一个自执行匿名函数123456(function (x) &#123; return x * x;&#125;)(3); // 9//另外一种写法(function (x) &#123; return x * x &#125;) (3); 总结很多初学者学了闭包后，可能也不懂到底在哪里才有用到，甚至不懂闭包到底有啥用。其实你写的每一个js函数都是闭包，一个js函数的顶层作用域就是window对象，js的执行环境本身就是一个scope（浏览器的window/node的global），我们通常称之为全局作用域。每个函数，不论多深，都可以认为是全局scope的子作用域，可以理解为闭包。 闭包的概念其实是针对作用域而言的，闭包的当前作用域总是能够访问外部作用域中的变量，因为 函数 是 JavaScript 中唯一拥有自身作用域的结构，因此闭包的创建依赖于函数。 文笔有限，才疏学浅，文中若有不对之处，还望告知。 参考文章 详解js闭包 JavaScript 秘密花园 廖雪峰JavaScript教程-闭包]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《秋菊打官司》观后感]]></title>
      <url>%2F2017%2F03%2F29%2F%E3%80%8A%E7%A7%8B%E8%8F%8A%E6%89%93%E5%AE%98%E5%8F%B8%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F%2F</url>
      <content type="text"><![CDATA[前言：在中国社会里，到底是情大于法，还是法大于情呢？ &#8194;&#8194;从影片最后的结尾来看，秋菊对这个结果是无奈的。她只是想要个说法，这个说法是基于情理上。但是迫于无奈她采取告状的方式，最后法律制度是给了秋菊一个明确的说法，但是从秋菊失望的脸上很明显告诉观众这不是她要的“说法”。 &#8194;&#8194;中国人普遍的意识里是大事化小，小事化了，法律一般是最后的手段。针对生活里的一般矛盾，人们更多倾向通过道德权威的情理方式去解决，自古以来道德文化一直是法律制度完美辅助。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[开发移动端页面时，字体自动变大]]></title>
      <url>%2F2017%2F03%2F23%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%8C%E5%AD%97%E4%BD%93%E8%87%AA%E5%8A%A8%E5%8F%98%E5%A4%A7%2F</url>
      <content type="text"><![CDATA[前言： 工作中开发移动端页面时会有部分内容字体无故变大，自己排查代码却没有解决，后来搜索问题才发现这是webkit内核下的特性 Text Autosizer」，又称「Font Boosting」、「Font Inflation」导致的。 问题描述之前开发移动端页面，发现同一个页面里有的内容字体大小会无故变大，有的却正常。例如，你设置font-size: 40px;,但是实际为60px。 解决之路没办法，自己搜索一下。一看还真有人遇到我和一样的问题。 首先，这个准确说不是由开发人员导致的bug,这是webkit内核移动浏览器特性导致的，这个特性被称做「Text Autosizer」，又称「Font Boosting」、「Font Inflation」，是 Webkit 给移动端浏览器提供的一个特性：当我们在手机上浏览网页时，很可能因为原始页面宽度较大，在手机屏幕上缩小后就看不清其中的文字了。而 Font Boosting 特性在这时会自动将其中的文字字体变大，保证在即不需要左右滑动屏幕，也不需要双击放大屏幕内容的前提下，也可以让人们方便的阅读页面中的文本。 问题解决思路：关闭该特性或让其无效，让字体无法变大 解决方法： 元素单独设置width或height或max-height； 推荐{max-height：100%;}，因为内容显示一般不会固定高和宽。 给元素设置 -webkit-text-size-adjust: none; 可禁用Text Autosizer，这个属性还能使得我们在移动端使用小于12px的字体。此属性在桌面版中无效。 WebKit 中应该有判断如果initial-scale=1时，不触发Text Autosizer目的是为了放大，而设置屏幕不能放大，自然Text Autosizer就失去的意义 123&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;&lt;!-- 或 --&gt;&lt;meta name ="viewport" content ="initial-scale=1, maximum-scale=1, minimum-scale=1"&gt; 个人思考什么条件下会触发这个Text Autosizer?? 个人水平有限，如有不对之处，还望指正！！！ 参考链接 webkit内核下，字号会自动放大的问题 做一个手机端页面时，遇到了一个奇怪的问题：字体的显示大小，与在CSS中指定的大小不一致]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正则表达式之入门]]></title>
      <url>%2F2017%2F03%2F14%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B9%8B%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[前言：自己有之前刷FCC的算法题，发现自己的正则了解的很少，所以自己找各种资料学习，并且总结了一下。 正则表达式是什么？ 正则表达式是用于匹配字符串中字符组合的模式。简单来说，用一种描述性语言去规定字符串的一种规则，如果符合，就匹配了，否则就是不匹配。 定义总是很枯燥不直观，我们来举个例子吧。假如你想从”hi my friend”里找出hi单词，我们定义正则表达式：/hi/，比如你想匹配三位数字 123，235等，你可以定义表达式/\d\d\d/,这里的\d我们称为元字符，它含义是匹配一个数字字符，那这里是3个\d所以就可以匹配3个数字，是不是很简单啊。 \d{3}表示匹配3个数字，例如’010’； \d{3,8}表示3-8个数字，例如’1234567’。 ‘00\d’可以匹配’007’，但无法匹配’00A’； 这里的{}也是元字符，后面会介绍。 正则表达式基本语法既然是一种描述性语言，那么就有自己特殊的语法，所以需要大致记忆一下。当然使用的多了，自然就熟悉了。 元字符具有特殊意义的正则表达式，这样可以更好描述需要匹配的字符串。 上面介绍过\d匹配一个数字字符，还有\w匹配一个单字字符（字母、数字或者下划线）,\s匹配任意的空白符. .(小数点）匹配除换行符之外的任何单个字符。 例如.b,就会匹配“bcd abc”中的ab,而不会匹配bc \b\w{6}\b 匹配6个字符的单词，{6}重复6次 ^和$都表示匹配一个位置，^表示字符串开头位置，$表示字符串结尾，例如我们匹配QQ号^\d{5,12}$,{5,12}重复5到12次，因为前后匹配位置，所以必须输入5到12位数字才能匹配。 限定符表示前面正则字符重复的次数 例如： bc*匹配 “bc”或“bcccccccccccccc” a+/匹配了在 “candy” 中的 ‘a’，和在 “caaaaaaandy” 中所有的 ‘a’ e?le? 匹配 “angel” 中的 ‘el’，和 “angle” 中的 ‘le’ 以及”oslo’ 中的’l’。 定位符定位符用来描述字符串或单词的边界 例如你要寻找字符串中hi，但是如果没有设置单词边界，就有可能匹配出him,history,high,但是使用\bhi\b就只会匹配hi单词。 而/B其实是\b的取反，oo\B可以匹配“foot”里的oo 字符转义如果你想查找本身具有特殊意义的元字符，如果直接使用就会产生问题，这时你就得使用\来取消这些字符的特殊意义。 因此，你应该使用\.和\*。当然，要查找\本身，你也得用\\. 字符类有的时候我只是想找元音字母a,e,i,o,u，其他字母不需要怎么办?很明显\w不适合的。 那我们应该自定义自己需要的字符集[a,e,i,o,u], 其实\d等于[0-9],而\w等于[a-z0-9A-Z_] 分枝条件x|y你可以理解为逻辑运算里“或” 例如：green|red匹配“green apple”中的‘green’和“red apple”中的‘red’ 分组我们可以重复单个字符多次，但是怎么可以重复多个字符多次呢？？你可以用小括号()来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了 模式 (foo) (bar) \1 \2 中的 ‘(foo)’ 和 ‘(bar)’ 匹配并记住字符串 &quot;foo bar foo bar&quot; 中前两个单词,每个小括号表示一个分组，1和2是组号而\1表示第一个分组匹配。 例如：\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, 或者kitty kitty 贪婪与懒惰正则表达式默认是尽可能匹配多的字符，以这个表达式为例：a.*b,这样，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。 但是很明显有时候我们需要尽可能匹配少的字符，那我们可以加限定符?,a.*?b,这样如果用它来搜索aabab的话，它会匹配整个字符串aab和ab 标志正则表达式有四个可选参数进行全局和不分大小写搜索。这些参数既可以单独使用也可以一起使用在任何顺序和包含正则表达式的部分中。 使用正则表达式创建一个正则表达式 正则表达式字面量 1234567/* /pattern/flags*/const regex = /ab+c/;const regex = /^[a-zA-Z]+[0-9]*\W?_$/gi; 调用RegExp对象的构造函数 123456789/* new RegExp(pattern [, flags])*/let regex = new RegExp("ab+c");let regex = new RegExp(/^[a-zA-Z]+[0-9]*\W?_$, "gi");let regex = new RegExp("^[a-zA-Z]+[0-9]*\W?_$", "gi"); 使用正则表达式的方法 正则表达式可以被用于RegExp的exec和test方法以及 String的match、replace、search和split方法。 个人水平有限，如有错误，还望指正，感激不尽！！！ 参考链接正则表达式 正则表达式30分钟入门教程 正则表达式 - 教程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS 属性 - 伪类和伪元素的区别]]></title>
      <url>%2F2017%2F03%2F13%2FCSS-%E5%B1%9E%E6%80%A7-%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[前言：之前自己一直没有弄清楚伪类和伪元素的区别，所以自己打算总结回顾一下。 一、伪类和伪元素的定义伪类(Pseudo-classes) CSS 伪类用于向某些选择器添加特殊的效果 伪元素 CSS 伪元素用于向某些选择器设置特殊效果。 分析一下有2点共同点： 作用于选择器 显示特殊效果 二、伪类和伪元素分类伪类的分类 伪元素分类 三、伪类和伪元素的区别这里用伪类 :first-child 和伪元素 ::first-letter 来进行比较。 123456789//css.par p:first-child&#123; color:red;&#125;&lt;div class='par'&gt; &lt;p class='one'&gt;123&lt;/p&gt; &lt;p class='two'&gt;456&lt;/p&gt;&lt;/div&gt; //伪类 :first-child将样式添加给第一个p子元素 但是如果不用伪类first-child，那么应该怎么显示这个效果呢？我们来试试 123456789//css.one&#123; color:red;&#125;&lt;div class='par'&gt; &lt;p class='one'&gt;123&lt;/p&gt; &lt;p class='two'&gt;456&lt;/p&gt;&lt;/div&gt; 效果是一样的，伪类 :first-child相当于给子元素添加一个类并且定义样式 我们来看看伪元素::first-letter 12345//CSS.text:first-letter&#123; color: red&#125; &lt;p class='text'&gt;文本啊&lt;/p&gt; 但是，如果我们不用伪元素::first-letter，应该怎么显示这个效果呢？我们继续来尝试一下 123456//css.text-one&#123; color: red;&#125;&lt;p&gt;&lt;span class='text-one'&gt;文&lt;/span&gt;本啊&lt;/p&gt; 到达这样的效果，我先添加元素span，然后添加样式。 到这里伪类和伪元素的区别已经很明显了 针对作用选择器的效果，伪类需要添加类来达到效果，而伪元素需要增加元素，所以一个叫伪类，另外一个叫伪元素。 由于二者之间产生的效果十分相似，所以CSS3标准里，为了区分二者已经规定伪类用单冒号:，伪元素用双冒号::，但是由于兼容性问题，大部分还是使用单冒号，如果不存在兼容问题，还是建议使用标准写法 :Pseudo-classes ::Pseudo-elements 个人水平有限，如有不对之处，还望指正！！！ 参考链接谈谈css的伪类和伪元素 详解 CSS 属性 - 伪类和伪元素的区别 CSS中伪类及伪元素用法详解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flex 布局入门]]></title>
      <url>%2F2017%2F03%2F13%2FFlex-%E5%B8%83%E5%B1%80%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[前言：相对float和position会更加灵活处理父元素和子元素之间布局关系，Flex让布局更加直观和灵活简单，你值得拥有。 Flex布局是什么？ W3C针对布局设计的新标准，相对float和position会更加灵活处理父元素和子元素之间布局关系，让布局更加直观和灵活简单。有效的针对不同屏幕宽度大小的情况下，让元素自动有效合理处理布局结构。 适用范围弹性盒子布局主要适用于应用程序的组件及小规模的布局，而（新兴的）栅格布局则针对大规模的布局。 Flex布局基本概念 弹性容器(Flex container)通过设置 display 属性的值为 flex 或 inline-flex来定义弹性容器。 弹性项目(Flex item)弹性容器里子元素自动成为弹性项目，并且弹性项目的float、clear和vertical-align属性将失效。 轴(Axis) 主轴（main axis） 交叉轴（cross axis）这个2个轴决定了容器里的项目整体布局效果。 Flex容器属性 flex-direction flex-wrap flex-flow justify-content align-items align-content flex-direction flex-direction决定主轴方向，默认情况下，元素都是从左到右地分布在主轴上 4个取值： 123456flex-direction: row | row-reverse | column column-reverse;row（默认值）：主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端。column：主轴为垂直方向，起点在上沿。column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap 是否可以换行（默认不换行），以及如果可以换行，如何排列 3个取值1234flex-wrap: nowrap | wrap | wrap-reverse;nowrap: 默认不换行wrap: 可以多行，第一行在上方wrap-reverse: 可以多行，第一行在下方 flex-flow flex-direction 和 flex-wrap 的简写,默认row nowrap 1flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; justify-content 决定项目在主轴上的对齐方式 5种取值： 1234567justify-content: flex-start | flex-end | center | space-between | space-around;flex-start: 左对齐（默认）flex-end: 右对齐center: 居中对齐space-between: 两端对齐，项目之间的间距相等space-around: 均匀对齐，每个项目两端的间距相等 align-items 决定交叉轴的对齐方式 1234567align-items: flex-start | flex-end | center | baseline | stretch;flex-start: 交叉轴起点对齐flex-end: 交叉轴终点对齐center: 交叉轴居中对齐baseline: 第一行文字的底部对齐stretch: （默认）如果项目木有设置高度或者高度为auto,那么项目拉伸充满整个交叉轴空间 注意：记住justify-content是沿着主轴的，align-items是沿着交叉轴的，而flex-direction是转换主轴的。这对整体移动元素很关键。 align-content 定义多行轴线的对齐方式（如果只有一行，该属性不起作用） 1234567align-content: flex-start | flex-end | center | space-between | space-around | stretch;flex-start: 交叉轴起点对齐flex-end: 交叉轴终点对齐space-between: 交叉轴两端对齐，行之间间距相等space-around: 交叉轴均匀对齐，行两端间距相等stretch: 平均分配交叉轴空间，相邻行间距相等（默认，前提如果项目木有设置高度或者高度为auto） 注意：当项目的高度之和小于容器的高度并且项目高度固定时，会以交叉轴起点对齐并且项目之间间距相等，但不是flex-start对齐方式，如果此时设置flex-start是没有间距的。 这里项目设置了固定高度，所以stretch无效 Flex项目属性 order align-self flex-grow flex-shrink flex-basis order 根据order的值定义项目排列顺序。数值越小，排列越靠前，默认为0 align-self 定义单个项目在交叉轴的对齐方式，可覆盖align-items属性 取值和align-items一样： flex-grow 定义项目放大比例，默认为0，当容器有剩余空间时不放大.重点在于，每个方块的 flex-grow 和其他方块的是成比例的。 1flex-grow: &lt;number&gt;; /* default 0 */ 第3个项目flex-grow 为3,其他5个项目为1，共 5+3 = 8,第3个占比为3/8,其他为1/8. flex-shrink 定义项目缩小比例。默认为1，随着容器缩小而等比例缩小。如果设置为0，项目将不缩小。基本和flex-grow类似，不过一个是缩小，一个是放大。 1flex-shrink: &lt;number&gt;; /* default 1 */ flex-basis 定义项目占据的主轴空间（main size）,默认是auto.还有就是它可能被其他flex属性所影响。 1flex-basis: &lt;length&gt; | auto; /* default auto */ 下面这个 GIF 表示的是它和 width 属性是可以互换的。（但是不完全是这样） 注意：flex-basis 和 width 不同的地方是，它是和 flex 坐标轴保持一致的，flex-basis是影响主轴上大小。 下面保持flex-basis不变，改变主轴方向 这个时候改变height，而不是width，flex-basis 根据 flex-direction 的不同会影响到 width 或者 height。 flex flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 12345678910/*简写auto (1 1 auto)none (0 0 auto)*/.square#one &#123; flex: 2 1 300px;&#125;.square#two &#123; flex: 1 2 300px;&#125; 最后注意：主轴和交叉轴需要特别注意方向，因为flex属性大部分是作用与轴上的,而方向不同就会导致不同布局效果。 参考链接通过动图形象地为你介绍 flexbox 是如何工作的（一） 通过动图形象地为你介绍 Flexbox 是如何工作的（二） Flex 布局教程：语法篇 flex基础布局详解 使用 CSS 弹性盒子]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP协议的初步认识]]></title>
      <url>%2F2017%2F02%2F20%2F%E5%89%8D%E7%AB%AF%E7%9A%84http%E5%88%9D%E8%AE%A4%2F</url>
      <content type="text"><![CDATA[前言： 对于前端而言除了那个前端“三剑客”以外，其实HTTP协议也是非常重要的。所以自己也就小小的总结一下，在此写下自己对前端部分HTTP的浅识。 http协议是什么？？ 协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。 简单来说，HTTP协议(HTTP-Hypertext transfer protocol)是一种详细规定了万维网不同设备之间互相通信的规则。 URL详解schema://host[:port#]/path/.../[;url-params][?query-string][#anchor] scheme: //有我们很熟悉的http、https、ftp以及著名的ed2k，迅雷的thunder等。 host: //HTTP服务器的IP地址或者域名 port#: //HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如tomcat的默认端口是8080 http://localhost:8080/ path: //访问资源的路径 url-params: //所带参数 query-string: //发送给http服务器的数据 anchor: //锚点定位 123456789101112http://www.mywebsite.com/sj/test;id=8079?name=sviergn&amp;x=true#stuffSchema: httphost: www.mywebsite.compath: /sj/testURL params: id=8079Query String: name=sviergn&amp;x=trueAnchor: stuff HTTP的工作流程第一步：建立TCP/IP连接，客户端与服务器通过Socket三次握手进行连接 三次握手涉及TCP协议，有兴趣请看关于三次握手 第二步：客户端向服务端发起HTTP请求（例如：POST/login.html http/1.1） 第三步：客户端发送请求头信息，请求内容，最后会发送一空白行，标示客户端请求完毕 第四步：服务器做出应答，表示对于客户端请求的应答，例如：HTTP/1.1 200 OK 第五步：服务器向客户端发送应答头信息 第六步：服务器向客户端发送请求头信息后，也会发送一空白行，标示应答头信息发送完毕，接着就以Content-type要求的数据格式发送数据给客户端 第七步：服务端关闭TCP连接，如果服务器或者客户端增Connection:keep-alive就表示客户端与服务器端继续保存连接，在下次请求时可以继续使用这次的连接 HTTP消息的结构Request 消息的结构 第一部分：请求行 Method表示请求方法，比如”POST”，”GET” Path-to-resoure表示请求的资源 Http/version-number 表示HTTP协议的版本号 第二部分：http header 第三部分：body（请求方法为get时为空）header和body之间有个空行 Response消息的结构 第一部分：request line 状态行 HTTP/version-number表示HTTP协议的版本号， status-code 和message 可另行了解 第二部分：request header 第三部分：body（请求方法为get时为空）header和body之间有个空行 HTTP请求详解 General Request URL：客户端请求服务器的URL地址 Request Method：请求的方式，最基本的有四种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息. Status Code：服务器响应请求后返回的code,code标示请求的状态，一般反应了通信的信息。 Remote Address：直译过来叫做远程地址，其实怎么理解呢？也就是说的是你请求发出的那个地址… Request Header 请求头 Accept：浏览器端可以接受的媒体类型 例如： Accept: text/html 代表浏览器可以接受服务器回发的类型为 text/html 也就是我们常说的html文档, Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）; Accept-Language: 浏览器申明自己接收的语言。 语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等； Cache-Control: 指定Response-Request遵循的缓存机制 Cache-Control:Public 可以被任何缓存所缓存 Cache-Control:Private 内容只缓存到私有缓存中 Cache-Control:no-cache 所有内容都不会被缓存 Connection: 客户端和服务器之间用于传输HTTP数据的TCP是否持续连接 Connection: keep-alive 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接 Connection: close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。 Cookie: 将cookie的所有值发送给HTTP 服务器 Host: 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的 Pragma: 防止页面被缓存，只有一个用法Pragma: no-cache Upgrade-Insecure-Requests: https页面不在显示http警告该指令用于让浏览器自动升级请求从http到https,用于大量包含http资源的http网页直接升级到https而不会报错.简洁的来讲,就相当于在http和https之间起的一个过渡作用. 详情查看Upgrade-Insecure-Requests User-Agent: 告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本. Response Headers Date：表明了响应的时间 -GMT(标准时间) Content-Type： 发送给客户端的实体正文的媒体类型 Connection： 允许客户端或服务器中任何一方关闭底层的连接双方都会要求在处理请求后关闭或者保持它们的TCP连接。 Server：服务器软件的信息 Transfer-Encoding:定义请求的传输编码 基础的状态码Response 消息中的第一行叫做状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。 状态码用来告诉HTTP客户端，HTTP服务器是否产生了预期的Response. HTTP/1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别 1XX 提示信息 - 表示请求已被成功接收，继续处理 2XX 成功 - 表示请求已被成功接收，理解，接受 3XX 重定向 - 要完成请求必须进行更进一步的处理 4XX 客户端错误 - 请求有语法错误或请求无法实现 5XX 服务器端错误 - 服务器未能实现合法的请求 文笔有限，才疏学浅，文中若有不正之处，还望告知。 参考文章 HTTP 协议详解 大前端学习笔记整理【七】HTTP协议以及http与https的区别 upgrade-insecure-requests “Upgrade-Insecure-Requests:1”表示什么意思？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《爱乐之城》观后感]]></title>
      <url>%2F2017%2F02%2F18%2F%E3%80%8A%E7%88%B1%E4%B9%90%E4%B9%8B%E5%9F%8E%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F%2F</url>
      <content type="text"><![CDATA[前言：梦想的公交车上你是司机，而其他人都是乘客，到站了就要下车。 之前偶然发现《爱乐之城》这部电影，看到很多对它的无尽的赞美之词，个人很是期待，所以今天去观看后感触很多，在此将自己的许多体会写下。 感受真实的梦想电影很好的体现一个人追求梦想的真实状态，梦想对每个人来说都很美好，但是实现的过程总是一路坎坷，自我怀疑或动摇。主角们最后都是实现了自己当初的梦想，但是结局似乎很无奈。电影在体现真实的梦想时，同时也给予人们温暖继续鼓励大家不要放弃梦想。尽管有些无奈和伤痛，但是整体而言还是美好。 如果没有如果电影最后的几分钟，给出主角们的另外一种完美的人生经历和选择，给观众一个十分美好几乎完美的人生过程。但是回到现实，镜头的最后分别给了男女主角，只是见他们相视一笑，各自的眼中满是无奈和伤痛，但是笑了说明他们接受自己当初的选择。是啊，人生没有如果，现实总是在你我的眼前。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端疲惫阅读感想]]></title>
      <url>%2F2016%2F12%2F27%2F%E5%89%8D%E7%AB%AF%E7%96%B2%E6%83%AB%E9%98%85%E8%AF%BB%E6%84%9F%E6%83%B3%2F</url>
      <content type="text"><![CDATA[前言 唐僧师徒四人去西天取经，一路克服重重困难而最终取得真经。记得悟空在路上一脸困惑的问师傅：“师傅，敢问路在何方？”，唐僧若有沉思缓缓回答道：“路在脚下”。悟空似乎明白了什么，又继续抬头赶路了。 今天读到一篇文章，文章名字叫前端疲惫，看着名就感受到一股程序员段子手的味道，细细阅读果然风趣幽默，让人有所沉思。 其实正如文章所说，水是喝不完的，游泳才是正道。我个人一直对目前前端各种新型技术充满困难，不知道自己的路在何方？看到这篇文章的时候，相信很多都会很有共鸣。这些新技术只是用来提高开发效率的，基础的东西是真的很重要。 另外作者给出如何应对目前的前端疲惫的建议 夯实基础基础的东西永远不会落后，计算机的底层知识永远是适用计算机各个领域的。 放松心态面对这些新东西，可以去了解，太过深入反而给自己压力，放松心态，专注于自己目前正在使用的技术栈。对于那些新技术，有兴趣当然可以去尝试，不去尝试也没有关系。不过，如果确实准备去尝试了，要专一不要贪心，千万别给自己列一堆新技术的学习计划，然后最后没有完成就只能变成无形的压力堆积在心里了。 实践最重要你见过谁学会游泳是通过看书学会的吗？？都是一头扎进水，反复尝试学会吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端页面开发适配-rem布局]]></title>
      <url>%2F2016%2F12%2F26%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91%E9%80%82%E9%85%8D-rem%E5%B8%83%E5%B1%80%2F</url>
      <content type="text"><![CDATA[前言：现在的手机终端各式各样，分辨率不同，逻辑像素不同 ，适口不同，所以为了让我们的页面在每个设备上都可以良好的展示，那么就需要为这些设备做统一的处理，这个过程就称为移动端适配，目前基本采用rem布局方式来适配。 在我们给出移动端适配的方法之前，我们首先了解一些基本概念 什么是PPI？PPI全称为Pixel Per Inch，译为每英寸像素取值，更确切的说法应该是像素密度，也就是衡量单位物理面积内拥有像素值的情况。一般来讲PPI越高，显示效果越清晰，当然不是越高越好，过高对图片的适配带来压力。另外，请记住，当我们在谈论一台显示设备的像素密度时，dpi与ppi是等价的 PPI的计算是物理像素除以物理尺寸，一般是采取对角线的数据PPI = 对角线的分辨率/对角线英寸，当然水平和垂直也是可以的。 什么是Pixel（像素）？针对前端开发，像素一般分为2种 物理像素 CSS像素 接下来我会分别解释上面2个概念： 物理像素买手机的时候会有一个 n*m 的分辨率，那是屏幕的n*m个呈像的点，一个点（小方格）为一个物理像素。它是屏幕能显示的最小粒度 CSS像素css的1px 和物理的1px有什么关系呢？？那么CSS中的1px是什么？浏览器是怎么渲染它的？ 网页在一个叫viewport的东西里渲染，可以理解为画布，画布被分成 N x M 个小方格，1个CSS像素，就是其中的一个小方格。 viewport又是什么？网页在viewport上渲染，可以想像在PS上画东西时，上面也有个画布，这个画布分割了 N x M 个方格，N是它的宽度，M是它的高度。宽高都可以任意设置，所以说viewport是虚拟的。假设设置宽度是400，那么浏览器显示区域的横向将被分为400份，CSS的1px占的宽度就是显示区域的 1/400。如果是980，那就是1/980。 viewport = 500 viewport = 900 viewport取不同值时，对布局会产生影响，很明显900的布局缩小了。例如我们只分析用户头像的图片，已知头像宽度是50px。 当viewport宽度为500时，屏幕横向被分为500份，每份1px，所以头像宽度是屏幕的1/10。（500/50=10） 当viewport宽度为900时，屏幕横向被分为900份，每份1px，所以头像宽度是屏幕的1/18。 （900/50=18） 所以，在CSS中，1px是指viewport中的一个小方格，而viewport宽度是可以任意设置的。 怎么合理设置viewport的宽度？viewport的宽度可以是数字和字符串”device-width”。device-width指设备宽度。 当取值为数字时，指不论是什么手机屏幕，viewport都被分为那么多份 当取值为device-width时，指的是手机屏幕的viewport宽度被设置为跟手机宽度一样。 因为很明显device-width的宽度值单位是CSS像素。所以当viewport设置为device-width时，我们必须明白一个概念就是：DevicePixelRatio DevicePixelRatio定义如下： window.devicePixelRatio = physical pixels / dips 分母dips全称为device-independent pixels，译为与设备无关像素。 更通俗的说应为与物理像素无关的CSS像素。 devicePixelRatio说白了就是手机的物理像素与实际使用像素的缩放比。 例如：某台安卓手机，分辨率是 1920*1080，屏幕对象线是5英寸。那么在这台手机上1个CSS像素，占了多少个物理像素？ 第一步：勾股定理算出对角线的分辨率，即 √(1920²+1080²)≈2203px 第二步：算出dpi。对角线的分辨率/对角线英寸 = 2203/5≈440dpi 第三步：得出转换系数。根据上面的图片，安卓手机440dpi，属于XXHDPI，转换系数是3 因此这台手机中，1个CSS像素 = 3*物理像素。即1个CSS像素占了3个物理像素。 这个转换系数，也等同于dpr，设备像素比。 该台安卓手机的device-width是1080/3 = 360，即viewport的宽度是 360 CSS像素。 注意devicePixelRatio并非是一个默认值。在默认情况下CSS像素是由手机默认的缩放决定的。但同时因为浏览器页面也可以被人为的进行缩放。比如iPhon4中默认的分辨率宽度为320px。浏览网页时我们完全可以自行放大两倍为160px。这样以来window.devicePixelRatio就变味了 640 / 160 = 4。通过改变dips而改变dpr. 多屏适配布局问题？业内比较流行的做法（参考阿里的flexible）阿里的flexible 基于rem的原理，针对不同手机屏幕尺寸和dpr动态的改变根节点html的font-size大小(基准值)。 设置viewport为设备宽度（这里不一定，但目前先这样足矣） 将viewport分成10rem，并计算出1rem在当前浏览器的像素值，把它赋予html标签的font-size（分成10rem只是为了方便计算而已,同时为了以后vw和vh） 写CSS代码时，遇到要适配的地方，比如width，margin，padding等，就不要再用px了，改成用rem 最后字体大小问题，一般还是基于dpr使用px 对于字体缩放问题，设计师原本的要求是这样的：任何手机屏幕上字体大小都要统一，所以我们针对不同的分辨率(dpr不同)，会做如下处理：1234font-size: 16px;[data-dpr=&quot;2&quot;] input &#123; font-size: 32px;&#125; (注意，字体不可以用rem，误差太大了，且不能满足任何屏幕下字体大小相同) 参考文章 移动适配-移动Web怎么做屏幕适配（三） 浅谈移动Web开发（上）：深入概念 移动端高清、多屏适配方案]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[爆裂鼓手观后感]]></title>
      <url>%2F2016%2F12%2F18%2F%E7%88%86%E8%A3%82%E9%BC%93%E6%89%8B%2F</url>
      <content type="text"><![CDATA[前言：比你牛逼的人比你还努力！！！ 首先这部电影在评价上有很多分歧，但是大家基本都认为这是一部还不错的电影，不管是技巧和艺术价值上。有巨大的分歧，说明电影让观众得到了不同的感受，这是成功的。正如一千个读者就有一千个哈姆雷特。 其次，我个人认为追求价值和梦想时，背后往往是黑暗、孤独等很多负面的东西，因为现实往往是残酷的。这点是大多数人应该认可的，当然不乏有天赋的人并没有经历这残酷的事实同样也获得个人价值的提升，但是有天赋的人毕竟是少数。 最后对我而言，让我觉得大多数的人（包括我自己）对梦想和个人价值的追求根本谈不上努力，看看安德鲁就知道了，那是要付出血的代价！！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F11%2F05%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
