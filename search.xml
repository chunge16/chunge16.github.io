<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[说说Javascript原型链]]></title>
      <url>%2F2017%2F04%2F24%2F%E8%AF%B4%E8%AF%B4Javascript%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
      <content type="text"><![CDATA[前言在写复杂的 JavaScript 应用之前，充分理解原型链继承的工作方式是每个 JavaScript 程序员必修的功课。 JavaScript中并没有类（class）；Js是基于原型（prototype-based）来实现的面向对象（OOP）的编程范式的，但并不是所有的对象都拥有prototype这一属性 123456789var a = &#123;&#125;,b = 'shi';var fn = function()&#123;&#125;;a.prototype // undefinedb.prototype // undefinedfn.prototype // Object &#123;constructor: function&#125; prototype属性只有 function对象定义时才有，函数本身也是对象。想要明白原型问题我们先明白几个基本概念。 一、function、Function、Object和{} function是JavaScript的关键字，用于定义函数变量，一般有2种定义方式 123456789function f1()&#123; console.log('This is function f1!');&#125;typeof(f1); //=&gt; 'function'var f2 = function()&#123; console.log('This is function f2!');&#125;typeof(f2); //=&gt; 'function' Function是函数类型实例的构造函数（constructor）, 本质也是函数，类似还有Object或String、Number等，都是Js内置类型实例的构造函数，构造函数主要作用就是创建相应类型的实例，实现原型链。 12345var f3 = new Function("console.log('This is function f3!');"); f3(); //=&gt; 'This is function f3!' typeof(f3); //=&gt; 'function'typeof(Function); //=&gt; 'function' Object，它用于生成对象类型，其简写形式为{}，其实和function和Function的关系类似。 1234567var o1 = new Object(); typeof(o1); //=&gt; 'object'var o2 = &#123;&#125;; typeof(o2); //=&gt; 'object'typeof(Object); //=&gt; 'function' 二、prototype 和 __proto__prototype属性只有函数类型对象才有，上面说的很清楚了。而__proto__是所有JavaScript对象都内置的属性[[Prototype]]，而这个属性指向构造函数（类似父类）的prototype属性，从而继承属性. 通俗一点讲，prototype中定义的属性和方法都是留给自己的“后代”用的，因此，子类完全可以访问prototype中的属性和方法。 举个例子： 123456789101112var Person = function()&#123;&#125;; Person.prototype.type = 'Person'; Person.prototype.maxAge = 100;var p = new Person(); console.log(p.maxAge); p.name = 'rainy';// 修正Person.prototype.constructor为Person本身Person.prototype.constructor === Person; //=&gt; true p.__proto__ === Person.prototype; //=&gt; true console.log(p.prototype); //=&gt; undefined 一图胜千言 Person是一个函数类型的变量，因此自带了prototype属性，prototype属性中的constructor又指向Person本身；通过new关键字生成的Person类的实例p1，通过__proto__属性指向了Person的原型。 注意：遵循ECMAScript标准，someObject.[[Prototype]] 符号是用于指派 someObject 的原型。这个等同于 JavaScript 的 __proto__ 属性。从 ECMAScript 6 开始, [[Prototype]] 可以用Object.getPrototypeOf()和Object.setPrototypeOf()访问器来访问。 三、原型链原型链是基于 __proto__ 的。JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依此层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。 举例说明： 1234567891011121314151617// Nodevar Obj = function()&#123;&#125;; var o = new Obj(); o.__proto__ === Obj.prototype; //=&gt; true o.__proto__.constructor === Obj; //=&gt; trueObj.__proto__ === Function.prototype; //=&gt; true Obj.__proto__.constructor === Function; //=&gt; trueFunction.__proto__ === Function.prototype; //=&gt; true Object.__proto__ === Object.prototype; //=&gt; false Object.__proto__ === Function.prototype; //=&gt; trueFunction.__proto__.constructor === Function;//=&gt; true Function.__proto__.__proto__; //=&gt; &#123;&#125; Function.__proto__.__proto__ === o.__proto__.__proto__; //=&gt; true o.__proto__.__proto__.__proto__ === null; //=&gt; true 来张图更直观一些 到了这里，其实有个问题大家没注意，new关键词到底起了什么作用呢？ 其实开头的图已经给出答案：new关键词的作用就是完成上图所示实例与父类原型之间关系的串接，并创建一个新的对象.简单来说，new就是把父类的prototype赋值给实例的__proto__ 有兴趣深入看这里：JS 的 new 到底是干什么的？ 文笔有限，才疏学浅，文中若有不对之处，还望告知。 参考文章 继承与原型链 原型 图解Javascript原型链 关于js中,原型对象，原型链，构造函数，实例之间关系的理解与区别]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《一念无明》的感触]]></title>
      <url>%2F2017%2F04%2F16%2F%E3%80%8A%E4%B8%80%E5%BF%B5%E6%97%A0%E6%98%8E%E3%80%8B%2F</url>
      <content type="text"><![CDATA[一念无明，如坠地狱；众生皆苦，万念皆空。 其实每个人都有病，只是你自己不觉得而已！ 关于电影名“一念”来自佛家的说法，是指人不断产生的念想，“无明”是看不见，看不清楚。人们的想法最终导致人性的迷失，从而不断的产生矛盾和伤害。 对于这个电影名，导演自己之所以选择用“一念无明”作为片名，是希望以此呈现片中人物之间的状态：“他们都是爱对方的，他们都不是外人，电影里面我自己觉得没有外人”，但正是这样的一群人，因为无法看清自己，看清他人，看清人生，最终却在不停地互相伤害，“他们互相伤害的时候就是‘无明’的，看不清楚他真的要做什么。” 中国式家庭悲剧但从阿东的家庭来看，其实具有普遍性。基本每个人都能从这个家庭找到自己的影子，因为你也是父亲，母亲或者是父母的儿女。 阿东的父母应该是比较极端的，阿东从小几乎没有父母的爱和呵护，这个家对他而言似乎无关，家庭的冷漠导致阿东的人格缺陷。但是这样类似的悲剧在中国的家庭都曾经上演过，可能是中国儒家文化的根深蒂固，中国的父母缺乏和孩子的交流，一句“我是为你好”就可以完美的表达父母对孩子的爱，但问题是孩子自己接受吗、快乐吗、同意吗？这就是问题所在，父母认为我是为孩子着想，但是结局往往都是悲剧。 那些离家出走、跳楼自杀和绝望痛哭的孩子，社会对这些孩子的评价总结起来基本都是没出息，从来没有人去质问父母的问题，把问题产生的原因归结于孩子的身上。 人性一面网络时代，大家把自己情绪和感情投入在虚拟的世界里，导致现实世界人性的缺失。都是去虚拟的世界学做人，反而在真实的世界忘记自己是人啦。 “那时，我还没弄懂人性是如何矛盾，我不知道真诚中有多少做作，高贵中有多少卑鄙，或者，邪恶中有多少善良。”“如今我是充分懂得了，小气与大方、怨怼与仁慈、憎恨与热爱，是可以并存于同一颗心中的”－－《月亮与六便士》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初识JavaScript闭包]]></title>
      <url>%2F2017%2F04%2F02%2F%E5%88%9D%E8%AF%86JavaScript%E9%97%AD%E5%8C%85%2F</url>
      <content type="text"><![CDATA[前言：学习JavaScript的时候老是听说闭包，感觉他很厉害的样子，所以就来会会他吧！ 闭包是什么？闭包是指有权访问另外一个函数作用域里的变量和参数的函数 闭包的特点以及优缺点特点 函数嵌套函数 函数内部可以引用外部的参数和变量 参数和变量不会被垃圾回收机制回收 一般函数执行结束后，局部变量会被销毁（垃圾回收机制所回收），内存只会保存全局作用域的变量。 但是闭包就不同了，闭包会使变量继续保存在内存里，当然如果使用不当会增大内存使用量。 12345678910function aaa() &#123; var a = 1; return function()&#123; alert(a++) &#125;; &#125; var fun = aaa(); fun();// 1 执行后 a++，，然后a还在~ fun();// 2 fun = null;//a被回收！！ 优点 希望一个变量长期驻扎在内存中 避免全局变量的污染 私有成员的存在 缺点 闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。 循环中的闭包一个常见错误是在循环中使用变量，我们看个例子： 1234567891011121314function count() &#123; var arr = []; for (var i=1; i&lt;=3; i++) &#123; arr.push(function () &#123; return i * i; &#125;); &#125; return arr;&#125;var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2]; 你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是: 123f1(); // 16f2(); // 16f3(); // 16 原因很简单，当你执行返回的函数时，闭包继续保持对变量i的访问，此时for循环已经结束并且i = 4,所以结果都是16。 为了得到想要的结果，需要在每次循环中创建变量 i 的拷贝。为此我们一般采用自执行匿名函数 1234567891011121314151617181920function count() &#123; var arr = []; for (var i=1; i&lt;=3; i++) &#123; arr.push((function (n) &#123; return function () &#123; return n * n; &#125; &#125;)(i)); &#125; return arr;&#125;var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2];f1(); // 1f2(); // 4f3(); // 9 自执行匿名函数 创建一个自执行匿名函数123456(function (x) &#123; return x * x;&#125;)(3); // 9//另外一种写法(function (x) &#123; return x * x &#125;) (3); 总结很多初学者学了闭包后，可能也不懂到底在哪里才有用到，甚至不懂闭包到底有啥用。其实你写的每一个js函数都是闭包，一个js函数的顶层作用域就是window对象，js的执行环境本身就是一个scope（浏览器的window/node的global），我们通常称之为全局作用域。每个函数，不论多深，都可以认为是全局scope的子作用域，可以理解为闭包。 闭包的概念其实是针对作用域而言的，闭包的当前作用域总是能够访问外部作用域中的变量，因为 函数 是 JavaScript 中唯一拥有自身作用域的结构，因此闭包的创建依赖于函数。 文笔有限，才疏学浅，文中若有不对之处，还望告知。 参考文章 详解js闭包 JavaScript 秘密花园 廖雪峰JavaScript教程-闭包]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《秋菊打官司》观后感]]></title>
      <url>%2F2017%2F03%2F29%2F%E3%80%8A%E7%A7%8B%E8%8F%8A%E6%89%93%E5%AE%98%E5%8F%B8%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F%2F</url>
      <content type="text"><![CDATA[前言：在中国社会里，到底是情大于法，还是法大于情呢？ &#8194;&#8194;从影片最后的结尾来看，秋菊对这个结果是无奈的。她只是想要个说法，这个说法是基于情理上。但是迫于无奈她采取告状的方式，最后法律制度是给了秋菊一个明确的说法，但是从秋菊失望的脸上很明显告诉观众这不是她要的“说法”。 &#8194;&#8194;中国人普遍的意识里是大事化小，小事化了，法律一般是最后的手段。针对生活里的一般矛盾，人们更多倾向通过道德权威的情理方式去解决，自古以来道德文化一直是法律制度完美辅助。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript数据结构与算法-二叉树]]></title>
      <url>%2F2017%2F03%2F29%2FJavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
      <content type="text"><![CDATA[前言：之前做百度前端练习题时，遇到二叉树遍历的问题，由于不了解二叉树这种数据机构，自己只好学习一番并且总结如下。 树的简介栈、队列、链表等数据结构，都是顺序数据结构。而树是非顺序数据结构。直观地，树型结构是以分支关系定义的层次结构。 基础概念树的定义树（Tree）是n（n&gt;=0）个结点的有限集。在一颗非空树里： 有且只有一个根节点（root） 当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1,T2,T3,…Tm，其中每一个集合本身又是一棵树，并且称为根的子树（Subtree）。 (a) 图只有一个根节点A ，（b）A是根节点，13个子节点，13个子节点分成3个互不相交的子集：T1={B,E,F,K,L},t2={D,H,I,J,M};T1,T2和T3都是根A的子树，且本身也是一棵树。 树的节点树中的每个元素，都叫做节点。树的结点包含一个数据元素及若干指向其子树的分支。该节点的子树被称为该节点的孩子并且该节点同时也是孩子的双亲 度：节点拥有的子树数目被称为度 例如（b）B节点的度为2，D节点的度为3，度为0的节点称为叶子或者终端结点,反之称为非终端结点或分支结点。该树的度为拥有节点的度的最大值 节点的层次节点的层次（Level）从根开始定义起，根为第一层，然后为第二层，依次顺序下去为n层。 深度： 树中节点的最大层数被称为树的深度或高度 例如 （b）树的深度为4 有序和无序树如果将树中节点的各子树看成从左至右是有次序的（即不能交换），则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。 森林森林（Forest）是m（m&gt;=0）棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。 二叉树二叉树（Binary Tree）是另一种树型结构，它的特点是每个结点至多只有两棵子树（即二叉树中不存在度大于2的结点），并且，二叉树的子树有左右之分（其次序不能任意颠倒。） 二叉树的性质 二叉树的第i层上最多有2的(i-1)方个节点。（i&gt;=1） 深度为k的树最多有2的k次方-1个节点。（k&gt;=1） 对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0 = n2 + 1; 一棵深度为k且有2的k次方-1个结点的二叉树称为满二叉树。 深度为k的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称之为完全二叉树。(我的理解是有限的节点个数里从左到右的编号要一一对应，否则不能称为完全二叉树) 注意：满二叉树一定是完全二叉树，但完全二叉树不一定是满二叉树。 二叉树的5个基本形态 空二叉树 只有一个根结点 根结点只有左子树 根结点只有右子树 根结点既有左子树又有右子树 二叉树的存储结构 顺序存储结构 用一维数组依照顺序存储树的节点，编号为i节点依次存储在数组下标i-1的元素里。i为0意味不存在此节点，这样的顺序存储适合完全二叉树。但是最坏的情况下，深刻为k并且只有k个节点的二叉树（每个节点的度小于2），那么意味着需要长度为2的k次方-1的一维数组来存储，非常浪费存储空间。 链式存储结构 二叉树的结点由一个数据元素和分别指向其左右子树的两个分支构成，则表示二叉树的链表中的结点至少包含三个域：数据域和左右指针域。有时，为了便于找到结点的双亲，则还可在结点结构中增加一个指向其双亲结点的指针域。利用这两种结构所得的二叉树的存储结构分别称之为二叉链表和三叉链表。在含有n个结点的二叉链表中有n+1个空链域，我们可以利用这些空链域存储其他有用信息，从而得到另一种链式存储结构—线索链表。 二叉树的遍历二叉树的遍历(traversing binary tree)是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。 二叉树的遍历有三种方式，如下： （1）前序遍历（DLR），首先访问根结点，然后遍历左子树，最后遍历右子树。简记根-左-右。 （2）中序遍历（LDR），首先遍历左子树，然后访问根结点，最后遍历右子树。简记左-根-右。 （3）后序遍历（LRD），首先遍历左子树，然后遍历右子树，最后访问根结点。简记左-右-根。 前序遍历（DLR）算法思路若二叉树为空，则遍历结束；否则 ⑴ 访问根结点； ⑵ 先序遍历左子树(递归调用本算法)； ⑶ 先序遍历右子树(递归调用本算法)。 遍历的顺序为：A B D H I E J C F K G 算法实现12345678//先序遍历function preOrder(node)&#123; if(!node == null)&#123; putstr(node.show()+ " "); preOrder(node.left); preOrder(node.right); &#125;&#125; 中序遍历（LDR）算法思路若二叉树为空，则遍历结束；否则 ⑴ 中序遍历左子树(递归调用本算法)； ⑵ 访问根结点； ⑶ 中序遍历右子树(递归调用本算法)。 遍历的顺序为：A B D H I E J C F K G 算法实现12345678//使用递归方式实现中序遍历function inOrder(node)&#123; if(!(node == null))&#123; inOrder(node.left);//先访问左子树 putstr(node.show()+ " ");//再访问根节点 inOrder(node.right);//最后访问右子树 &#125;&#125; 后序遍历（LRD）算法思路 若二叉树为空，则遍历结束；否则 ⑴ 后序遍历左子树(递归调用本算法)； ⑵ 后序遍历右子树(递归调用本算法) ； ⑶ 访问根结点 。 遍历的顺序为：H I D J E B K F G C A 算法实现12345678//后序遍历function postOrder(node)&#123; if(!node == null)&#123; postOrder(node.left); postOrder(node.right); putStr(node.show()+ " "); &#125;&#125; 个人水平有限，如有错误，还望指正，感激不尽！！！ 参考链接 javascript实现数据结构： 树和二叉树,二叉树的遍历和基本操作 JavaScript数据结构和算法之二叉树详解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[开发移动端页面时，字体自动变大]]></title>
      <url>%2F2017%2F03%2F23%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%8C%E5%AD%97%E4%BD%93%E8%87%AA%E5%8A%A8%E5%8F%98%E5%A4%A7%2F</url>
      <content type="text"><![CDATA[前言： 工作中开发移动端页面时会有部分内容字体无故变大，自己排查代码却没有解决，后来搜索问题才发现这是webkit内核下的特性 Text Autosizer」，又称「Font Boosting」、「Font Inflation」导致的。 问题描述之前开发移动端页面，发现同一个页面里有的内容字体大小会无故变大，有的却正常。例如，你设置font-size: 40px;,但是实际为60px。 解决之路没办法，自己搜索一下。一看还真有人遇到我和一样的问题。 首先，这个准确说不是由开发人员导致的bug,这是webkit内核移动浏览器特性导致的，这个特性被称做「Text Autosizer」，又称「Font Boosting」、「Font Inflation」，是 Webkit 给移动端浏览器提供的一个特性：当我们在手机上浏览网页时，很可能因为原始页面宽度较大，在手机屏幕上缩小后就看不清其中的文字了。而 Font Boosting 特性在这时会自动将其中的文字字体变大，保证在即不需要左右滑动屏幕，也不需要双击放大屏幕内容的前提下，也可以让人们方便的阅读页面中的文本。 问题解决思路：关闭该特性或让其无效，让字体无法变大 解决方法： 元素单独设置width或height或max-height； 推荐{max-height：100%;}，因为内容显示一般不会固定高和宽。 给元素设置 -webkit-text-size-adjust: none; 可禁用Text Autosizer，这个属性还能使得我们在移动端使用小于12px的字体。此属性在桌面版中无效。 WebKit 中应该有判断如果initial-scale=1时，不触发Text Autosizer目的是为了放大，而设置屏幕不能放大，自然Text Autosizer就失去的意义 123&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;&lt;!-- 或 --&gt;&lt;meta name ="viewport" content ="initial-scale=1, maximum-scale=1, minimum-scale=1"&gt; 个人思考什么条件下会触发这个Text Autosizer?? 个人水平有限，如有不对之处，还望指正！！！ 参考链接 webkit内核下，字号会自动放大的问题 做一个手机端页面时，遇到了一个奇怪的问题：字体的显示大小，与在CSS中指定的大小不一致]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正则表达式之入门]]></title>
      <url>%2F2017%2F03%2F14%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B9%8B%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[前言：自己有之前刷FCC的算法题，发现自己的正则了解的很少，所以自己找各种资料学习，并且总结了一下。 正则表达式是什么？ 正则表达式是用于匹配字符串中字符组合的模式。简单来说，用一种描述性语言去规定字符串的一种规则，如果符合，就匹配了，否则就是不匹配。 定义总是很枯燥不直观，我们来举个例子吧。假如你想从”hi my friend”里找出hi单词，我们定义正则表达式：/hi/，比如你想匹配三位数字 123，235等，你可以定义表达式/\d\d\d/,这里的\d我们称为元字符，它含义是匹配一个数字字符，那这里是3个\d所以就可以匹配3个数字，是不是很简单啊。 \d{3}表示匹配3个数字，例如’010’； \d{3,8}表示3-8个数字，例如’1234567’。 ‘00\d’可以匹配’007’，但无法匹配’00A’； 这里的{}也是元字符，后面会介绍。 正则表达式基本语法既然是一种描述性语言，那么就有自己特殊的语法，所以需要大致记忆一下。当然使用的多了，自然就熟悉了。 元字符具有特殊意义的正则表达式，这样可以更好描述需要匹配的字符串。 上面介绍过\d匹配一个数字字符，还有\w匹配一个单字字符（字母、数字或者下划线）,\s匹配任意的空白符. .(小数点）匹配除换行符之外的任何单个字符。 例如.b,就会匹配“bcd abc”中的ab,而不会匹配bc \b\w{6}\b 匹配6个字符的单词，{6}重复6次 ^和$都表示匹配一个位置，^表示字符串开头位置，$表示字符串结尾，例如我们匹配QQ号^\d{5,12}$,{5,12}重复5到12次，因为前后匹配位置，所以必须输入5到12位数字才能匹配。 限定符表示前面正则字符重复的次数 例如： bc*匹配 “bc”或“bcccccccccccccc” a+/匹配了在 “candy” 中的 ‘a’，和在 “caaaaaaandy” 中所有的 ‘a’ e?le? 匹配 “angel” 中的 ‘el’，和 “angle” 中的 ‘le’ 以及”oslo’ 中的’l’。 定位符定位符用来描述字符串或单词的边界 例如你要寻找字符串中hi，但是如果没有设置单词边界，就有可能匹配出him,history,high,但是使用\bhi\b就只会匹配hi单词。 而/B其实是\b的取反，oo\B可以匹配“foot”里的oo 字符转义如果你想查找本身具有特殊意义的元字符，如果直接使用就会产生问题，这时你就得使用\来取消这些字符的特殊意义。 因此，你应该使用\.和\*。当然，要查找\本身，你也得用\\. 字符类有的时候我只是想找元音字母a,e,i,o,u，其他字母不需要怎么办?很明显\w不适合的。 那我们应该自定义自己需要的字符集[a,e,i,o,u], 其实\d等于[0-9],而\w等于[a-z0-9A-Z_] 分枝条件x|y你可以理解为逻辑运算里“或” 例如：green|red匹配“green apple”中的‘green’和“red apple”中的‘red’ 分组我们可以重复单个字符多次，但是怎么可以重复多个字符多次呢？？你可以用小括号()来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了 模式 (foo) (bar) \1 \2 中的 ‘(foo)’ 和 ‘(bar)’ 匹配并记住字符串 &quot;foo bar foo bar&quot; 中前两个单词,每个小括号表示一个分组，1和2是组号而\1表示第一个分组匹配。 例如：\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, 或者kitty kitty 贪婪与懒惰正则表达式默认是尽可能匹配多的字符，以这个表达式为例：a.*b,这样，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。 但是很明显有时候我们需要尽可能匹配少的字符，那我们可以加限定符?,a.*?b,这样如果用它来搜索aabab的话，它会匹配整个字符串aab和ab 标志正则表达式有四个可选参数进行全局和不分大小写搜索。这些参数既可以单独使用也可以一起使用在任何顺序和包含正则表达式的部分中。 使用正则表达式创建一个正则表达式 正则表达式字面量 1234567/* /pattern/flags*/const regex = /ab+c/;const regex = /^[a-zA-Z]+[0-9]*\W?_$/gi; 调用RegExp对象的构造函数 123456789/* new RegExp(pattern [, flags])*/let regex = new RegExp("ab+c");let regex = new RegExp(/^[a-zA-Z]+[0-9]*\W?_$, "gi");let regex = new RegExp("^[a-zA-Z]+[0-9]*\W?_$", "gi"); 使用正则表达式的方法 正则表达式可以被用于RegExp的exec和test方法以及 String的match、replace、search和split方法。 个人水平有限，如有错误，还望指正，感激不尽！！！ 参考链接正则表达式 正则表达式30分钟入门教程 正则表达式 - 教程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS 属性 - 伪类和伪元素的区别]]></title>
      <url>%2F2017%2F03%2F13%2FCSS-%E5%B1%9E%E6%80%A7-%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[前言：之前自己一直没有弄清楚伪类和伪元素的区别，所以自己打算总结回顾一下。 一、伪类和伪元素的定义伪类(Pseudo-classes) CSS 伪类用于向某些选择器添加特殊的效果 伪元素 CSS 伪元素用于向某些选择器设置特殊效果。 分析一下有2点共同点： 作用于选择器 显示特殊效果 二、伪类和伪元素分类伪类的分类 伪元素分类 三、伪类和伪元素的区别这里用伪类 :first-child 和伪元素 ::first-letter 来进行比较。 123456789//css.par p:first-child&#123; color:red;&#125;&lt;div class='par'&gt; &lt;p class='one'&gt;123&lt;/p&gt; &lt;p class='two'&gt;456&lt;/p&gt;&lt;/div&gt; //伪类 :first-child将样式添加给第一个p子元素 但是如果不用伪类first-child，那么应该怎么显示这个效果呢？我们来试试 123456789//css.one&#123; color:red;&#125;&lt;div class='par'&gt; &lt;p class='one'&gt;123&lt;/p&gt; &lt;p class='two'&gt;456&lt;/p&gt;&lt;/div&gt; 效果是一样的，伪类 :first-child相当于给子元素添加一个类并且定义样式 我们来看看伪元素::first-letter 12345//CSS.text:first-letter&#123; color: red&#125; &lt;p class='text'&gt;文本啊&lt;/p&gt; 但是，如果我们不用伪元素::first-letter，应该怎么显示这个效果呢？我们继续来尝试一下 123456//css.text-one&#123; color: red;&#125;&lt;p&gt;&lt;span class='text-one'&gt;文&lt;/span&gt;本啊&lt;/p&gt; 到达这样的效果，我先添加元素span，然后添加样式。 到这里伪类和伪元素的区别已经很明显了 针对作用选择器的效果，伪类需要添加类来达到效果，而伪元素需要增加元素，所以一个叫伪类，另外一个叫伪元素。 由于二者之间产生的效果十分相似，所以CSS3标准里，为了区分二者已经规定伪类用单冒号:，伪元素用双冒号::，但是由于兼容性问题，大部分还是使用单冒号，如果不存在兼容问题，还是建议使用标准写法 :Pseudo-classes ::Pseudo-elements 个人水平有限，如有不对之处，还望指正！！！ 参考链接谈谈css的伪类和伪元素 详解 CSS 属性 - 伪类和伪元素的区别 CSS中伪类及伪元素用法详解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flex 布局入门]]></title>
      <url>%2F2017%2F03%2F13%2FFlex-%E5%B8%83%E5%B1%80%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[前言：相对float和position会更加灵活处理父元素和子元素之间布局关系，Flex让布局更加直观和灵活简单，你值得拥有。 Flex布局是什么？ W3C针对布局设计的新标准，相对float和position会更加灵活处理父元素和子元素之间布局关系，让布局更加直观和灵活简单。有效的针对不同屏幕宽度大小的情况下，让元素自动有效合理处理布局结构。 适用范围弹性盒子布局主要适用于应用程序的组件及小规模的布局，而（新兴的）栅格布局则针对大规模的布局。 Flex布局基本概念 弹性容器(Flex container)通过设置 display 属性的值为 flex 或 inline-flex来定义弹性容器。 弹性项目(Flex item)弹性容器里子元素自动成为弹性项目，并且弹性项目的float、clear和vertical-align属性将失效。 轴(Axis) 主轴（main axis） 交叉轴（cross axis）这个2个轴决定了容器里的项目整体布局效果。 Flex容器属性 flex-direction flex-wrap flex-flow justify-content align-items align-content flex-direction flex-direction决定主轴方向，默认情况下，元素都是从左到右地分布在主轴上 4个取值： 123456flex-direction: row | row-reverse | column column-reverse;row（默认值）：主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端。column：主轴为垂直方向，起点在上沿。column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap 是否可以换行（默认不换行），以及如果可以换行，如何排列 3个取值1234flex-wrap: nowrap | wrap | wrap-reverse;nowrap: 默认不换行wrap: 可以多行，第一行在上方wrap-reverse: 可以多行，第一行在下方 flex-flow flex-direction 和 flex-wrap 的简写,默认row nowrap 1flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; justify-content 决定项目在主轴上的对齐方式 5种取值： 1234567justify-content: flex-start | flex-end | center | space-between | space-around;flex-start: 左对齐（默认）flex-end: 右对齐center: 居中对齐space-between: 两端对齐，项目之间的间距相等space-around: 均匀对齐，每个项目两端的间距相等 align-items 决定交叉轴的对齐方式 1234567align-items: flex-start | flex-end | center | baseline | stretch;flex-start: 交叉轴起点对齐flex-end: 交叉轴终点对齐center: 交叉轴居中对齐baseline: 第一行文字的底部对齐stretch: （默认）如果项目木有设置高度或者高度为auto,那么项目拉伸充满整个交叉轴空间 注意：记住justify-content是沿着主轴的，align-items是沿着交叉轴的，而flex-direction是转换主轴的。这对整体移动元素很关键。 align-content 定义多行轴线的对齐方式（如果只有一行，该属性不起作用） 1234567align-content: flex-start | flex-end | center | space-between | space-around | stretch;flex-start: 交叉轴起点对齐flex-end: 交叉轴终点对齐space-between: 交叉轴两端对齐，行之间间距相等space-around: 交叉轴均匀对齐，行两端间距相等stretch: 平均分配交叉轴空间，相邻行间距相等（默认，前提如果项目木有设置高度或者高度为auto） 注意：当项目的高度之和小于容器的高度并且项目高度固定时，会以交叉轴起点对齐并且项目之间间距相等，但不是flex-start对齐方式，如果此时设置flex-start是没有间距的。 这里项目设置了固定高度，所以stretch无效 Flex项目属性 order align-self flex-grow flex-shrink flex-basis order 根据order的值定义项目排列顺序。数值越小，排列越靠前，默认为0 align-self 定义单个项目在交叉轴的对齐方式，可覆盖align-items属性 取值和align-items一样： flex-grow 定义项目放大比例，默认为0，当容器有剩余空间时不放大.重点在于，每个方块的 flex-grow 和其他方块的是成比例的。 1flex-grow: &lt;number&gt;; /* default 0 */ 第3个项目flex-grow 为3,其他5个项目为1，共 5+3 = 8,第3个占比为3/8,其他为1/8. flex-shrink 定义项目缩小比例。默认为1，随着容器缩小而等比例缩小。如果设置为0，项目将不缩小。基本和flex-grow类似，不过一个是缩小，一个是放大。 1flex-shrink: &lt;number&gt;; /* default 1 */ flex-basis 定义项目占据的主轴空间（main size）,默认是auto.还有就是它可能被其他flex属性所影响。 1flex-basis: &lt;length&gt; | auto; /* default auto */ 下面这个 GIF 表示的是它和 width 属性是可以互换的。（但是不完全是这样） 注意：flex-basis 和 width 不同的地方是，它是和 flex 坐标轴保持一致的，flex-basis是影响主轴上大小。 下面保持flex-basis不变，改变主轴方向 这个时候改变height，而不是width，flex-basis 根据 flex-direction 的不同会影响到 width 或者 height。 flex flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 12345678910/*简写auto (1 1 auto)none (0 0 auto)*/.square#one &#123; flex: 2 1 300px;&#125;.square#two &#123; flex: 1 2 300px;&#125; 最后注意：主轴和交叉轴需要特别注意方向，因为flex属性大部分是作用与轴上的,而方向不同就会导致不同布局效果。 参考链接通过动图形象地为你介绍 flexbox 是如何工作的（一） 通过动图形象地为你介绍 Flexbox 是如何工作的（二） Flex 布局教程：语法篇 flex基础布局详解 使用 CSS 弹性盒子]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP协议的初步认识]]></title>
      <url>%2F2017%2F02%2F20%2F%E5%89%8D%E7%AB%AF%E7%9A%84http%E5%88%9D%E8%AE%A4%2F</url>
      <content type="text"><![CDATA[前言： 对于前端而言除了那个前端“三剑客”以外，其实HTTP协议也是非常重要的。所以自己也就小小的总结一下，在此写下自己对前端部分HTTP的浅识。 http协议是什么？？ 协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。 简单来说，HTTP协议(HTTP-Hypertext transfer protocol)是一种详细规定了万维网不同设备之间互相通信的规则。 URL详解schema://host[:port#]/path/.../[;url-params][?query-string][#anchor] scheme: //有我们很熟悉的http、https、ftp以及著名的ed2k，迅雷的thunder等。 host: //HTTP服务器的IP地址或者域名 port#: //HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如tomcat的默认端口是8080 http://localhost:8080/ path: //访问资源的路径 url-params: //所带参数 query-string: //发送给http服务器的数据 anchor: //锚点定位 123456789101112http://www.mywebsite.com/sj/test;id=8079?name=sviergn&amp;x=true#stuffSchema: httphost: www.mywebsite.compath: /sj/testURL params: id=8079Query String: name=sviergn&amp;x=trueAnchor: stuff HTTP的工作流程第一步：建立TCP/IP连接，客户端与服务器通过Socket三次握手进行连接 三次握手涉及TCP协议，有兴趣请看关于三次握手 第二步：客户端向服务端发起HTTP请求（例如：POST/login.html http/1.1） 第三步：客户端发送请求头信息，请求内容，最后会发送一空白行，标示客户端请求完毕 第四步：服务器做出应答，表示对于客户端请求的应答，例如：HTTP/1.1 200 OK 第五步：服务器向客户端发送应答头信息 第六步：服务器向客户端发送请求头信息后，也会发送一空白行，标示应答头信息发送完毕，接着就以Content-type要求的数据格式发送数据给客户端 第七步：服务端关闭TCP连接，如果服务器或者客户端增Connection:keep-alive就表示客户端与服务器端继续保存连接，在下次请求时可以继续使用这次的连接 HTTP消息的结构Request 消息的结构 第一部分：请求行 Method表示请求方法，比如”POST”，”GET” Path-to-resoure表示请求的资源 Http/version-number 表示HTTP协议的版本号 第二部分：http header 第三部分：body（请求方法为get时为空）header和body之间有个空行 Response消息的结构 第一部分：request line 状态行 HTTP/version-number表示HTTP协议的版本号， status-code 和message 可另行了解 第二部分：request header 第三部分：body（请求方法为get时为空）header和body之间有个空行 HTTP请求详解 General Request URL：客户端请求服务器的URL地址 Request Method：请求的方式，最基本的有四种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息. Status Code：服务器响应请求后返回的code,code标示请求的状态，一般反应了通信的信息。 Remote Address：直译过来叫做远程地址，其实怎么理解呢？也就是说的是你请求发出的那个地址… Request Header 请求头 Accept：浏览器端可以接受的媒体类型 例如： Accept: text/html 代表浏览器可以接受服务器回发的类型为 text/html 也就是我们常说的html文档, Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）; Accept-Language: 浏览器申明自己接收的语言。 语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等； Cache-Control: 指定Response-Request遵循的缓存机制 Cache-Control:Public 可以被任何缓存所缓存 Cache-Control:Private 内容只缓存到私有缓存中 Cache-Control:no-cache 所有内容都不会被缓存 Connection: 客户端和服务器之间用于传输HTTP数据的TCP是否持续连接 Connection: keep-alive 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接 Connection: close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。 Cookie: 将cookie的所有值发送给HTTP 服务器 Host: 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的 Pragma: 防止页面被缓存，只有一个用法Pragma: no-cache Upgrade-Insecure-Requests: https页面不在显示http警告该指令用于让浏览器自动升级请求从http到https,用于大量包含http资源的http网页直接升级到https而不会报错.简洁的来讲,就相当于在http和https之间起的一个过渡作用. 详情查看Upgrade-Insecure-Requests User-Agent: 告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本. Response Headers Date：表明了响应的时间 -GMT(标准时间) Content-Type： 发送给客户端的实体正文的媒体类型 Connection： 允许客户端或服务器中任何一方关闭底层的连接双方都会要求在处理请求后关闭或者保持它们的TCP连接。 Server：服务器软件的信息 Transfer-Encoding:定义请求的传输编码 基础的状态码Response 消息中的第一行叫做状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。 状态码用来告诉HTTP客户端，HTTP服务器是否产生了预期的Response. HTTP/1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别 1XX 提示信息 - 表示请求已被成功接收，继续处理 2XX 成功 - 表示请求已被成功接收，理解，接受 3XX 重定向 - 要完成请求必须进行更进一步的处理 4XX 客户端错误 - 请求有语法错误或请求无法实现 5XX 服务器端错误 - 服务器未能实现合法的请求 文笔有限，才疏学浅，文中若有不正之处，还望告知。 参考文章 HTTP 协议详解 大前端学习笔记整理【七】HTTP协议以及http与https的区别 upgrade-insecure-requests “Upgrade-Insecure-Requests:1”表示什么意思？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《爱乐之城》观后感]]></title>
      <url>%2F2017%2F02%2F18%2F%E3%80%8A%E7%88%B1%E4%B9%90%E4%B9%8B%E5%9F%8E%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F%2F</url>
      <content type="text"><![CDATA[前言：梦想的公交车上你是司机，而其他人都是乘客，到站了就要下车。 之前偶然发现《爱乐之城》这部电影，看到很多对它的无尽的赞美之词，个人很是期待，所以今天去观看后感触很多，在此将自己的许多体会写下。 感受真实的梦想电影很好的体现一个人追求梦想的真实状态，梦想对每个人来说都很美好，但是实现的过程总是一路坎坷，自我怀疑或动摇。主角们最后都是实现了自己当初的梦想，但是结局似乎很无奈。电影在体现真实的梦想时，同时也给予人们温暖继续鼓励大家不要放弃梦想。尽管有些无奈和伤痛，但是整体而言还是美好。 如果没有如果电影最后的几分钟，给出主角们的另外一种完美的人生经历和选择，给观众一个十分美好几乎完美的人生过程。但是回到现实，镜头的最后分别给了男女主角，只是见他们相视一笑，各自的眼中满是无奈和伤痛，但是笑了说明他们接受自己当初的选择。是啊，人生没有如果，现实总是在你我的眼前。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端疲惫阅读感想]]></title>
      <url>%2F2016%2F12%2F27%2F%E5%89%8D%E7%AB%AF%E7%96%B2%E6%83%AB%E9%98%85%E8%AF%BB%E6%84%9F%E6%83%B3%2F</url>
      <content type="text"><![CDATA[前言 唐僧师徒四人去西天取经，一路克服重重困难而最终取得真经。记得悟空在路上一脸困惑的问师傅：“师傅，敢问路在何方？”，唐僧若有沉思缓缓回答道：“路在脚下”。悟空似乎明白了什么，又继续抬头赶路了。 今天读到一篇文章，文章名字叫前端疲惫，看着名就感受到一股程序员段子手的味道，细细阅读果然风趣幽默，让人有所沉思。 其实正如文章所说，水是喝不完的，游泳才是正道。我个人一直对目前前端各种新型技术充满困难，不知道自己的路在何方？看到这篇文章的时候，相信很多都会很有共鸣。这些新技术只是用来提高开发效率的，基础的东西是真的很重要。 另外作者给出如何应对目前的前端疲惫的建议 夯实基础基础的东西永远不会落后，计算机的底层知识永远是适用计算机各个领域的。 放松心态面对这些新东西，可以去了解，太过深入反而给自己压力，放松心态，专注于自己目前正在使用的技术栈。对于那些新技术，有兴趣当然可以去尝试，不去尝试也没有关系。不过，如果确实准备去尝试了，要专一不要贪心，千万别给自己列一堆新技术的学习计划，然后最后没有完成就只能变成无形的压力堆积在心里了。 实践最重要你见过谁学会游泳是通过看书学会的吗？？都是一头扎进水，反复尝试学会吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端页面开发适配-rem布局]]></title>
      <url>%2F2016%2F12%2F26%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91%E9%80%82%E9%85%8D-rem%E5%B8%83%E5%B1%80%2F</url>
      <content type="text"><![CDATA[前言：现在的手机终端各式各样，分辨率不同，逻辑像素不同 ，适口不同，所以为了让我们的页面在每个设备上都可以良好的展示，那么就需要为这些设备做统一的处理，这个过程就称为移动端适配，目前基本采用rem布局方式来适配。 在我们给出移动端适配的方法之前，我们首先了解一些基本概念 什么是PPI？PPI全称为Pixel Per Inch，译为每英寸像素取值，更确切的说法应该是像素密度，也就是衡量单位物理面积内拥有像素值的情况。一般来讲PPI越高，显示效果越清晰，当然不是越高越好，过高对图片的适配带来压力。另外，请记住，当我们在谈论一台显示设备的像素密度时，dpi与ppi是等价的 PPI的计算是物理像素除以物理尺寸，一般是采取对角线的数据PPI = 对角线的分辨率/对角线英寸，当然水平和垂直也是可以的。 什么是Pixel（像素）？针对前端开发，像素一般分为2种 物理像素 CSS像素 接下来我会分别解释上面2个概念： 物理像素买手机的时候会有一个 n*m 的分辨率，那是屏幕的n*m个呈像的点，一个点（小方格）为一个物理像素。它是屏幕能显示的最小粒度 CSS像素css的1px 和物理的1px有什么关系呢？？那么CSS中的1px是什么？浏览器是怎么渲染它的？ 网页在一个叫viewport的东西里渲染，可以理解为画布，画布被分成 N x M 个小方格，1个CSS像素，就是其中的一个小方格。 viewport又是什么？网页在viewport上渲染，可以想像在PS上画东西时，上面也有个画布，这个画布分割了 N x M 个方格，N是它的宽度，M是它的高度。宽高都可以任意设置，所以说viewport是虚拟的。假设设置宽度是400，那么浏览器显示区域的横向将被分为400份，CSS的1px占的宽度就是显示区域的 1/400。如果是980，那就是1/980。 viewport = 500 viewport = 900 viewport取不同值时，对布局会产生影响，很明显900的布局缩小了。例如我们只分析用户头像的图片，已知头像宽度是50px。 当viewport宽度为500时，屏幕横向被分为500份，每份1px，所以头像宽度是屏幕的1/10。（500/50=10） 当viewport宽度为900时，屏幕横向被分为900份，每份1px，所以头像宽度是屏幕的1/18。 （900/50=18） 所以，在CSS中，1px是指viewport中的一个小方格，而viewport宽度是可以任意设置的。 怎么合理设置viewport的宽度？viewport的宽度可以是数字和字符串”device-width”。device-width指设备宽度。 当取值为数字时，指不论是什么手机屏幕，viewport都被分为那么多份 当取值为device-width时，指的是手机屏幕的viewport宽度被设置为跟手机宽度一样。 因为很明显device-width的宽度值单位是CSS像素。所以当viewport设置为device-width时，我们必须明白一个概念就是：DevicePixelRatio DevicePixelRatio定义如下： window.devicePixelRatio = physical pixels / dips 分母dips全称为device-independent pixels，译为与设备无关像素。 更通俗的说应为与物理像素无关的CSS像素。 devicePixelRatio说白了就是手机的物理像素与实际使用像素的缩放比。 例如：某台安卓手机，分辨率是 1920*1080，屏幕对象线是5英寸。那么在这台手机上1个CSS像素，占了多少个物理像素？ 第一步：勾股定理算出对角线的分辨率，即 √(1920²+1080²)≈2203px 第二步：算出dpi。对角线的分辨率/对角线英寸 = 2203/5≈440dpi 第三步：得出转换系数。根据上面的图片，安卓手机440dpi，属于XXHDPI，转换系数是3 因此这台手机中，1个CSS像素 = 3*物理像素。即1个CSS像素占了3个物理像素。 这个转换系数，也等同于dpr，设备像素比。 该台安卓手机的device-width是1080/3 = 360，即viewport的宽度是 360 CSS像素。 注意devicePixelRatio并非是一个默认值。在默认情况下CSS像素是由手机默认的缩放决定的。但同时因为浏览器页面也可以被人为的进行缩放。比如iPhon4中默认的分辨率宽度为320px。浏览网页时我们完全可以自行放大两倍为160px。这样以来window.devicePixelRatio就变味了 640 / 160 = 4。通过改变dips而改变dpr. 多屏适配布局问题？业内比较流行的做法（参考阿里的flexible）阿里的flexible 基于rem的原理，针对不同手机屏幕尺寸和dpr动态的改变根节点html的font-size大小(基准值)。 设置viewport为设备宽度（这里不一定，但目前先这样足矣） 将viewport分成10rem，并计算出1rem在当前浏览器的像素值，把它赋予html标签的font-size（分成10rem只是为了方便计算而已,同时为了以后vw和vh） 写CSS代码时，遇到要适配的地方，比如width，margin，padding等，就不要再用px了，改成用rem 最后字体大小问题，一般还是基于dpr使用px 对于字体缩放问题，设计师原本的要求是这样的：任何手机屏幕上字体大小都要统一，所以我们针对不同的分辨率(dpr不同)，会做如下处理：1234font-size: 16px;[data-dpr=&quot;2&quot;] input &#123; font-size: 32px;&#125; (注意，字体不可以用rem，误差太大了，且不能满足任何屏幕下字体大小相同) 参考文章 移动适配-移动Web怎么做屏幕适配（三） 浅谈移动Web开发（上）：深入概念 移动端高清、多屏适配方案]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[爆裂鼓手观后感]]></title>
      <url>%2F2016%2F12%2F18%2F%E7%88%86%E8%A3%82%E9%BC%93%E6%89%8B%2F</url>
      <content type="text"><![CDATA[前言：比你牛逼的人比你还努力！！！ 首先这部电影在评价上有很多分歧，但是大家基本都认为这是一部还不错的电影，不管是技巧和艺术价值上。有巨大的分歧，说明电影让观众得到了不同的感受，这是成功的。正如一千个读者就有一千个哈姆雷特。 其次，我个人认为追求价值和梦想时，背后往往是黑暗、孤独等很多负面的东西，因为现实往往是残酷的。这点是大多数人应该认可的，当然不乏有天赋的人并没有经历这残酷的事实同样也获得个人价值的提升，但是有天赋的人毕竟是少数。 最后对我而言，让我觉得大多数的人（包括我自己）对梦想和个人价值的追求根本谈不上努力，看看安德鲁就知道了，那是要付出血的代价！！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F11%2F05%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
